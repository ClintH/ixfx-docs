import { c as createComponent, r as renderTemplate, a as renderComponent, u as unescapeHTML } from './astro/server__cawITtY.mjs';
import 'kleur/colors';
import { $ as $$MainLayout } from './MainLayout_BFrOPY-O.mjs';

const html = "<p><a href=\"https://clinth.github.io/ixfx/modules/Collections.Stacks.html\">API Docs: Stacks</a></p>\n<p>A stack stores items like a stack of plates. Items added get put on the top, and if you want to grab an item, you can only see, and grab from the top. This is useful if newer things have priority.</p>\n<p>In other words, it is LIFO (last in, first out). If you want first-in first out, see <a href=\"../queue/\">Queue</a>.</p>\n<p>The default implementation in ixfx is immutable, meaning that every operation that changes the stack returns a <em>new</em> stack. A stack instance itself never changes.</p>\n<script type=\"module\" hoist=\"\">\nimport '/src/components/data/collections/ArrayVisElement';\nimport '/src/components/data/collections/StackVis';\n</script>\n<div class=\"centered toolbar\">\n  <button id=\"btnPush\">Push</button>\n  <button id=\"btnPop\">Pop</button>\n</div>\n<div class=\"centered toolbar\">\n  <div id=\"peek\"></div>\n</div>\n<div id=\"vis\"></div>\n<h2 id=\"basics\">Basics</h2>\n<p><code>push</code> and <code>pop</code> are the main means of interacting with a stack.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> {Stacks} </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> \"https://unpkg.com/ixfx/collections.js\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> s </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Stacks.</span><span style=\"color:#B392F0\">immutable</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Items are pushed in order from start, so `c`</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// is on the \"top\" of the stack now.</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">push</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`a`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`b`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`c`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Yields `c`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s.peek;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Return a new stack with top-most item removed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> s.</span><span style=\"color:#B392F0\">pop</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"iterating\">Iterating</h2>\n<p>For the most part, you’re meant to just access the top-most item of a stack. If you find yourself needing to dig through a stack, it may not be the right data structure.</p>\n<p>That said, there are ways of iterating:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Iterate from bottom-to-top of stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s.</span><span style=\"color:#B392F0\">forEach</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">item</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // do something with item</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">})</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Iterate from top-to-bottom of stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s.</span><span style=\"color:#B392F0\">forEachFromTop</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#FFAB70\">item</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // do something with item</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"additional-properties\">Additional properties</h2>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// True if stack is empty</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s.isEmpty;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// How many items in stack</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns the underlying array</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// used by the stack. Be careful not to</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// modify or it may break the stack semantics</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">s.data;</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"capacity-limiting\">Capacity limiting</h2>\n<p>When creating the stack, it’s possible to set a capacity limit. This can be useful to avoid a <em>backlog</em> of data. For example, if you’re processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don’t really care about older things any longer.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> q </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> Stacks.</span><span style=\"color:#B392F0\">immutable</span><span style=\"color:#E1E4E8\">({capacity: </span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">, discardPolicy: </span><span style=\"color:#9ECBFF\">`newer`</span><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span></code></pre>\n<p>The <code>capacity</code> naturally sets the total number of items the stack will store. The <code>discardPolicy</code> determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is <em>pushed</em>.</p>\n<p>Values for <code>discardPolicy</code> are:</p>\n<ul>\n<li><code>older</code>: Removes existing items from the bottom of the stack to make room for additions. Ie. the oldest items are thrown away</li>\n<li><code>newer</code>: Removes existing items from the top of the stack to make room for additions. Ie. the newest items are thrown away</li>\n<li><code>additions</code>: Does not change the existing items, but rather throws away items that are being <em>pushed</em>.</li>\n</ul>\n<script type=\"module\" hoist=\"\">\nimport '/src/components/data/collections/ArrayVisElement';\nimport '/src/components/data/collections/StackDiscardVis';\n</script>\n<div class=\"centered toolbar\">\n  <button id=\"btnPushDiscard\">Push</button>\n  <button id=\"btnPopDiscard\">Pop</button>\n  <label for=\"selDiscard\" style=\"align-self: center\">Capacity 3.<br> Discard policy</label>\n  <select id=\"selDiscard\">\n    <option value=\"older\">older</option>\n    <option value=\"newer\">newer</option>\n    <option value=\"additions\">additions</option>\n  </select>\n</div>\n<div class=\"centered toolbar\">\n  <div id=\"peekDiscard\"></div>\n</div>\n<div id=\"visDiscard\"></div>";

				const frontmatter = {"title":"Stack","layout":"../../../layouts/MainLayout.astro"};
				const file = "/Users/af4766/repos/ixfx-docs/src/pages/data/collections/stack.md";
				const url = "/data/collections/stack";
				function rawContent() {
					return "\n[API Docs: Stacks](https://clinth.github.io/ixfx/modules/Collections.Stacks.html)\n\nA stack stores items like a stack of plates. Items added get put on the top, and if you want to grab an item, you can only see, and grab from the top. This is useful if newer things have priority.\n\nIn other words, it is LIFO (last in, first out). If you want first-in first out, see [Queue](../queue/).\n\nThe default implementation in ixfx is immutable, meaning that every operation that changes the stack returns a _new_ stack. A stack instance itself never changes.\n\n<script type=\"module\" hoist>\nimport '/src/components/data/collections/ArrayVisElement';\nimport '/src/components/data/collections/StackVis';\n</script>\n<div class=\"centered toolbar\">\n  <button id=\"btnPush\">Push</button>\n  <button id=\"btnPop\">Pop</button>\n</div>\n<div class=\"centered toolbar\">\n  <div id=\"peek\"></div>\n</div>\n<div id=\"vis\"></div>\n\n\n## Basics\n\n`push` and `pop` are the main means of interacting with a stack.\n\n```js\nimport {Stacks} from \"https://unpkg.com/ixfx/collections.js\"\n\n// Initialise\nlet s = Stacks.immutable();\n\n// Items are pushed in order from start, so `c`\n// is on the \"top\" of the stack now.\ns = s.push(`a`, `b`, `c`);\n\n// Yields `c`\ns.peek;\n\n// Return a new stack with top-most item removed\ns = s.pop();\n```\n\n## Iterating\n\nFor the most part, you're meant to just access the top-most item of a stack. If you find yourself needing to dig through a stack, it may not be the right data structure.\n\nThat said, there are ways of iterating:\n\n```js\n// Iterate from bottom-to-top of stack\ns.forEach(item => {\n  // do something with item\n})\n\n// Iterate from top-to-bottom of stack\ns.forEachFromTop(item => {\n  // do something with item\n});\n```\n\n## Additional properties\n\n```js\n// True if stack is empty\ns.isEmpty;\n\n// How many items in stack\ns.length;\n\n// Returns the underlying array\n// used by the stack. Be careful not to\n// modify or it may break the stack semantics\ns.data;\n```\n\n## Capacity limiting\n\nWhen creating the stack, it's possible to set a capacity limit. This can be useful to avoid a _backlog_ of data. For example, if you're processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don't really care about older things any longer.\n\n```js\nlet q = Stacks.immutable({capacity: 5, discardPolicy: `newer`});\n```\n\nThe `capacity` naturally sets the total number of items the stack will store. The `discardPolicy` determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is _pushed_.\n\nValues for `discardPolicy` are:\n* `older`: Removes existing items from the bottom of the stack to make room for additions. Ie. the oldest items are thrown away\n* `newer`: Removes existing items from the top of the stack to make room for additions. Ie. the newest items are thrown away\n* `additions`: Does not change the existing items, but rather throws away items that are being _pushed_. \n\n<script type=\"module\" hoist>\nimport '/src/components/data/collections/ArrayVisElement';\nimport '/src/components/data/collections/StackDiscardVis';\n</script>\n<div class=\"centered toolbar\">\n  <button id=\"btnPushDiscard\">Push</button>\n  <button id=\"btnPopDiscard\">Pop</button>\n  <label for=\"selDiscard\" style=\"align-self: center\">Capacity 3.<br /> Discard policy</label>\n  <select id=\"selDiscard\">\n    <option value=\"older\">older</option>\n    <option value=\"newer\">newer</option>\n    <option value=\"additions\">additions</option>\n  </select>\n</div>\n<div class=\"centered toolbar\">\n  <div id=\"peekDiscard\"></div>\n</div>\n<div id=\"visDiscard\"></div>";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"basics","text":"Basics"},{"depth":2,"slug":"iterating","text":"Iterating"},{"depth":2,"slug":"additional-properties","text":"Additional properties"},{"depth":2,"slug":"capacity-limiting","text":"Capacity limiting"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$MainLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html)}`
							})}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
