import { c as createComponent, r as renderTemplate, a as renderComponent, u as unescapeHTML } from './astro/server__cawITtY.mjs';
import 'kleur/colors';
import { $ as $$MainLayout } from './MainLayout_BFrOPY-O.mjs';

const html = "<script type=\"module\" hoist=\"\">\nimport '/src/components/ReplPad';\n</script>\n<div class=\"tip\">\n<ul>\n<li>Demos <a href=\"https://clinth.github.io/ixfx-demos/geometry/\">Geometry</a> (<a href=\"https://github.com/ClintH/ixfx-demos/tree/main/geometry\">source</a>)</li>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Geometry.Points.html\">Geometry.Points module</a></li>\n</ul></div>\n<p>A <em>vector</em> consists of <em>magnitude</em> (which can be thought of as length or distance) and <em>direction</em>. In essence, it describes how to go from <a href=\"./point\">Point</a> A to B.</p>\n<p>Read more:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Euclidean_vector\">Wikipedia</a></li>\n</ul>\n<h2 id=\"cartesian-and-polar\">Cartesian and Polar</h2>\n<p>Vectors can be described with <a href=\"../units/#cartesian\">Cartesian</a> or <a href=\"../units/#polar\">polar</a> coordinates. In ixfx, type <code>Vector = Points.Point | Polar.Coord</code>.</p>\n<p>Cartesian: <span id=\"vector-cartesian\">?</span><br>\nPolar: <span id=\"vector-polar\">?</span>\n</p>\n<p></p>\n<vector-element id=\"vectorIntro\" client:visible=\"\" width=\"300\" height=\"300\">\n<script type=\"module\" hoist=\"\">\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n</script>\n<p>When expressed in Cartesian coordinates, it’s not obvious that the vector expresses magnitude and direction. It would seem to be the <em>x</em> and <em>y</em> of a single point in space. Instead, the <em>x</em> value represents the movement along the horizontal axis from the origin, and <em>y</em> represents movement along the vertical axis from the origin.</p>\n<p>Click on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.</p>\n<p>Vectors in Polar coordinates are made up angle and magnitude. In ixfx, <code>angleRadian</code> and <code>distance</code> are used to denote these components. Polar coordinates better express the meaning of a vector, and you’re less likely to muddle them up with actual points on a plane.</p>\n<p>In ixfx, vectors can be converted back and forth:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Vectors } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> \"https://unpkg.com/ixfx/dist/geometry.js\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> vectorCartesian</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Vectors.</span><span style=\"color:#B392F0\">toCartesian</span><span style=\"color:#E1E4E8\">(somePolarCoordinate);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> vectorPolar</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Vectors.</span><span style=\"color:#B392F0\">toPolar</span><span style=\"color:#E1E4E8\">(someCartesianCoordinate);</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"uses\">Uses</h2>\n<p>Vectors are useful in calculating forces such as velocity and acceleration.</p>\n<p>For example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> computePosition</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">position</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">velocity</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    x: position.x </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> velocity.x,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    y: position.y </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> velocity.y</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> thing</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { x: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, y: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> velocity</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { x: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, y: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> newPosition</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> computePosition</span><span style=\"color:#E1E4E8\">(thing, velocity);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>To handle either kind of vector notation, we can instead use <code>Vectors.sum</code>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> thing</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { x: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">, y: </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Eg. with a Cartesian vector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> velocityCartesian</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { x: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, y: </span><span style=\"color:#79B8FF\">2</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> newPosition</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Vectors.</span><span style=\"color:#B392F0\">sum</span><span style=\"color:#E1E4E8\">(thing, velocityCartesian);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Eg. with a polar vector</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> velocityPolar</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { angleRadian: </span><span style=\"color:#79B8FF\">0.20</span><span style=\"color:#E1E4E8\">, distance: </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> newPosition2</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Vectors.</span><span style=\"color:#B392F0\">sum</span><span style=\"color:#E1E4E8\">(thing, velocityPolar);</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"computing\">Computing</h2>\n<p>Vectors can be computed from a line, where it is assumed that the line’s <em>a</em> property is the start, and <em>b</em> is the end. This gives us direction and magnitude.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Vectors } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> \"https://unpkg.com/ixfx/dist/geometry.js\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// A line</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> line</span><span style=\"color:#E1E4E8\">  { </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  a</span><span style=\"color:#E1E4E8\">: { </span><span style=\"color:#B392F0\">x</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">y</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\"> }, </span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  b</span><span style=\"color:#E1E4E8\">: { </span><span style=\"color:#B392F0\">x</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#B392F0\">y</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Vector in Cartesian coordinates</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> vectorCartesian</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Vectors.</span><span style=\"color:#B392F0\">fromLineCartesian</span><span style=\"color:#E1E4E8\">(line);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Yields: { x: ..., y: ... }</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Vector in Polar coordinates</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> vectorPolar</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Vectors.</span><span style=\"color:#B392F0\">fromLinePolar</span><span style=\"color:#E1E4E8\">(line);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Yields: { angleRadian: ..., distance: ... }</span></span>\n<span class=\"line\"></span></code></pre>\n<p>If you don’t already have a Line instance, a vector can be created from two given points using <code>Points.subtract</code></p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> vectorCartestian</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Points.</span><span style=\"color:#B392F0\">subtract</span><span style=\"color:#E1E4E8\">(a, b);</span></span>\n<span class=\"line\"></span></code></pre>\n<p><code>vectorCartesian</code> will thus be the distance and angle between <code>a</code> and <code>b</code>.</p>\n<h1 id=\"unit-vectors\">Unit vectors</h1>\n<p>A <em>unit vector</em>, or <em>normalised vector</em> is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.</p>\n<p>It can be produced using <code>normalise</code></p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Vectors } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> \"https://unpkg.com/ixfx/dist/geometry.js\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> unitVector</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> Vectors.</span><span style=\"color:#B392F0\">normalise</span><span style=\"color:#E1E4E8\">({ angleRadian: </span><span style=\"color:#F97583\">-</span><span style=\"color:#79B8FF\">0.52</span><span style=\"color:#E1E4E8\">, distance: </span><span style=\"color:#79B8FF\">50</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"></span></code></pre></vector-element>";

				const frontmatter = {"title":"Vector","layout":"../../../layouts/MainLayout.astro","setup":"import { DemoElement } from '../../../components/DemoElement.ts';\nimport {VectorElement} from '/src/components/geometry/VectorElement';\n"};
				const file = "/Users/af4766/repos/ixfx-docs/src/pages/types/geometry/vector.md";
				const url = "/types/geometry/vector";
				function rawContent() {
					return "\n<script type=\"module\" hoist>\nimport '/src/components/ReplPad';\n</script>\n\n<div class=\"tip\">\n<ul>\n<li>Demos <a href=\"https://clinth.github.io/ixfx-demos/geometry/\">Geometry</a> (<a href=\"https://github.com/ClintH/ixfx-demos/tree/main/geometry\">source</a>)</li>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Geometry.Points.html\">Geometry.Points module</a></li>\n</div>\n\nA _vector_ consists of _magnitude_ (which can be thought of as length or distance) and _direction_. In essence, it describes how to go from [Point](./point) A to B.\n\nRead more:\n* [Wikipedia](https://en.wikipedia.org/wiki/Euclidean_vector)\n\n\n## Cartesian and Polar\n\nVectors can be described with [Cartesian](../units/#cartesian) or [polar](../units/#polar) coordinates. In ixfx, type `Vector = Points.Point | Polar.Coord`.\n\n<p>Cartesian: <span id=\"vector-cartesian\">?</span><br />\nPolar: <span id=\"vector-polar\">?</span>\n</p>\n<p></p>\n<vector-element id=\"vectorIntro\" client:visible width=\"300\" height=\"300\"  />\n<script type=\"module\" hoist>\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n</script>\n\nWhen expressed in Cartesian coordinates, it's not obvious that the vector expresses magnitude and direction. It would seem to be the _x_ and _y_ of a single point in space. Instead, the _x_ value represents the movement along the horizontal axis from the origin, and _y_ represents movement along the vertical axis from the origin.\n\nClick on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.\n\nVectors in Polar coordinates are made up angle and magnitude. In ixfx, `angleRadian` and `distance` are used to denote these components. Polar coordinates better express the meaning of a vector, and you're less likely to muddle them up with actual points on a plane.\n\nIn ixfx, vectors can be converted back and forth:\n\n```js\nimport { Vectors } from \"https://unpkg.com/ixfx/dist/geometry.js\"\nconst vectorCartesian = Vectors.toCartesian(somePolarCoordinate);\nconst vectorPolar = Vectors.toPolar(someCartesianCoordinate);\n```\n\n## Uses\n\nVectors are useful in calculating forces such as velocity and acceleration. \n\nFor example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):\n\n```js\nconst computePosition = (position, velocity) => {\n  return {\n    x: position.x + velocity.x,\n    y: position.y + velocity.y\n  }\n}\n\nconst thing = { x: 100, y: 100 };\nconst velocity = { x: 1, y: 2 };\nconst newPosition = computePosition(thing, velocity);\n```\n\nTo handle either kind of vector notation, we can instead use `Vectors.sum`:\n\n```js\nconst thing = { x: 100, y: 100 };\n\n// Eg. with a Cartesian vector\nconst velocityCartesian = { x: 1, y: 2 };\nconst newPosition = Vectors.sum(thing, velocityCartesian);\n\n// Eg. with a polar vector\nconst velocityPolar = { angleRadian: 0.20, distance: 1 };\nconst newPosition2 = Vectors.sum(thing, velocityPolar);\n```\n\n\n## Computing\n\nVectors can be computed from a line, where it is assumed that the line's _a_ property is the start, and _b_ is the end. This gives us direction and magnitude.\n\n```js\nimport { Vectors } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n\n// repl-pad#1\n// A line\nconst line  { \n  a: { x: 10, y: 10 }, \n  b: { x: 20, y: 20 }\n};\n```\n\nVector in Cartesian coordinates\n\n```js\n// repl-pad#1\nconst vectorCartesian = Vectors.fromLineCartesian(line);\n// Yields: { x: ..., y: ... }\n```\n\nVector in Polar coordinates\n\n```js\n// repl-pad#1\nconst vectorPolar = Vectors.fromLinePolar(line);\n// Yields: { angleRadian: ..., distance: ... }\n```\n\nIf you don't already have a Line instance, a vector can be created from two given points using `Points.subtract`\n\n```js\nconst vectorCartestian = Points.subtract(a, b);\n```\n\n`vectorCartesian` will thus be the distance and angle between `a` and `b`.\n# Unit vectors\n\nA _unit vector_, or _normalised vector_ is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.\n\nIt can be produced using `normalise`\n\n```js\nimport { Vectors } from \"https://unpkg.com/ixfx/dist/geometry.js\"\nconst unitVector = Vectors.normalise({ angleRadian: -0.52, distance: 50 });\n```\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"cartesian-and-polar","text":"Cartesian and Polar"},{"depth":2,"slug":"uses","text":"Uses"},{"depth":2,"slug":"computing","text":"Computing"},{"depth":1,"slug":"unit-vectors","text":"Unit vectors"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$MainLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html)}`
							})}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
