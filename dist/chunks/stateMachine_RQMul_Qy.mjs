import { c as createComponent, r as renderTemplate, a as renderComponent, u as unescapeHTML } from './astro/server__cawITtY.mjs';
import 'kleur/colors';
import { $ as $$MainLayout } from './MainLayout_BFrOPY-O.mjs';

const html = "<script type=\"module\" hoist=\"\">\nimport '/src/components/ReplPad';\n</script>\n<div class=\"tip\"><ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Flow.StateMachine.html\">StateMachine</a></li>\n<li><a href=\"https://clinth.github.io/ixfx-demos/flow/\">Online demos</a></li>\n<li>Starter: <a href=\"https://github.com/ClintH/ixfx-demos/tree/main/flow/statemachine-starter\">GitHub</a>, <a href=\"https://glitch.com/edit/#!/ixfx-starter-statemachine\">Glitch</a>\n</li></ul></div>\n<p>A <em>state machine</em> allows for a controlled change from one state to another. It sets up a well-defined set of possible states and what transitions are possible between them. It’s up to you to ‘drive’ the machine, telling it when to transition.</p>\n<p>State machines are defined with a plain object. Properties list of possible states, with values being what state(s) that are possible to change to, or <em>null</em> if no further changes are possible.</p>\n<h2 id=\"machine-definition\">Machine definition</h2>\n<p>An example of a simple state machine is a light switch. It has two states: <em>on</em> and <em>off</em>. When the light is <em>on</em>, the only other state is <em>off</em>. And vice-versa:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  on</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"off\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  off</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"on\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<p>With this machine definition, it would be illegal to have a state <code>dimmed</code>, or to turn it <code>off</code> when it is already <code>off</code>. In this case, the machine never reaches a final state, it can always oscillate between <code>on</code> / <code>off</code>. Note too that we can automatically and reliably advance the state of the machine, because each state indicates what follows.</p>\n<p>It’s possible to have several possible next states by using a string array:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  on</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"off\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"half_bright\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  half_bright</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"on\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"off\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  off</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"on\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<p>The example below is intended to start with <code>plain</code> bread, with a few ways of getting to the eventual final state of <code>sprinkled_on_soup</code> or <code>eaten</code>. Once a machine is in its final state, it cannot change to another state unless it is <em>reset</em>.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">{</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  plain</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"toasted\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"buttered\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"eaten\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  toasted</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"buttered\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"eaten\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"diced\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  buttered</span><span style=\"color:#E1E4E8\">: [</span><span style=\"color:#9ECBFF\">\"eaten\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"marmaladed\"</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  marmaladed</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"eaten\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  diced</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">\"sprinkled_on_soup\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  sprinkled_on_soup</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">null</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  eaten</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#79B8FF\">null</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"why\">Why?</h2>\n<p>Behaving according to a current state is a common pattern in programming interactivity. This is often solved by using different variables track state. A downside is that you have to be mindful what variables or conditions alter state as well as when and where to enforce rules about state changes.</p>\n<p>A state machine therefore can help you catch errors and makes coding simpler when you know there are a fixed number of well-defined states to handle, and they are only activated according to a logic you have defined.</p>\n<h2 id=\"playground\">Playground</h2>\n<p>Try out some state machines in this playground.</p>\n<ol>\n<li>Edit the description or choose a demo</li>\n<li>Click <em>Use description</em> to load it have it checked for errors.</li>\n<li>If successful, you can see available states. Select a state and then ‘Change state’</li>\n</ol>\n<p>(Note that properties are enclosed in ” marks here because it’s represented as JSON)</p>\n<statemachineplay>\n<h2 id=\"simple-usage\">Simple usage</h2>\n<div class=\"tip\"><ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Flow.StateMachine.html\">StateMachine</a></li>\n<li><a href=\"https://clinth.github.io/ixfx-demos/flow/\">Online demos</a></li>\n<li>Starter: <a href=\"https://github.com/ClintH/ixfx-demos/tree/main/flow/statemachine-starter\">GitHub</a>, <a href=\"https://glitch.com/edit/#!/ixfx-starter-statemachine\">Glitch</a>\n</li></ul></div>\n<p>A simple way of using the state machine is the functional, immutable approach. Create the machine with its <em>description</em> and <em>initial state</em>:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> machine</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">({</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  on: </span><span style=\"color:#9ECBFF\">\"off\"</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  off: </span><span style=\"color:#9ECBFF\">\"on\"</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#9ECBFF\">\"on\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>The machine description is a simple object that 1) lists all possible states (as its top-level properties), and 2) for each state, what other state(s) can be transitioned to, or <code>null</code> if it is a final state.</p>\n<p>The following example has four possible states (<code>wakeup, sleep, coffee, breakfast, bike</code>). <code>sleep</code> can only transition to the <code>wakeup</code> state, while <code>wakeup</code> can transition to either <code>coffee</code> or <code>breakfast</code>.</p>\n<p>Use <em>null</em> to signify the final state. Multiple states can terminate the machine if desired.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#1</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { StateMachine } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> \"https://unpkg.com/ixfx/dist/flow.js\"</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> description</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> sleep: </span><span style=\"color:#9ECBFF\">`wakeup`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> wakeup: [</span><span style=\"color:#9ECBFF\">`coffee`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`breakfast`</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> coffee: </span><span style=\"color:#9ECBFF\">`bike`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> breakfast: </span><span style=\"color:#9ECBFF\">`bike`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> bike: </span><span style=\"color:#79B8FF\">null</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> sm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(description, </span><span style=\"color:#9ECBFF\">`sleep`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span></code></pre>\n<p><code>StateMachine.init</code> returns <a href=\"https://clinth.github.io/ixfx/types/Flow.StateMachine.MachineState.html\"><code>MachineState</code></a> which captures the definition of the machine and its current state:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Current state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.value; </span><span style=\"color:#6A737D\">// eg. 'bike'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// List of unique states visited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.visited; </span><span style=\"color:#6A737D\">// eg. ['sleep', 'wakeup']</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Original machine definition</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.machine; </span></span>\n<span class=\"line\"></span></code></pre>\n<p>To attempt to change state, use <a href=\"https://clinth.github.io/ixfx/functions/Flow.StateMachine.to.html\"><code>StateMachine.to</code></a></p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Transition existing machine to state 'wakeup'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">to</span><span style=\"color:#E1E4E8\">(sm, </span><span style=\"color:#9ECBFF\">'wakeup'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.value; </span><span style=\"color:#6A737D\">// 'wakeup'</span></span>\n<span class=\"line\"></span></code></pre>\n<p>If this is a legal transition, you’ll get a new <code>MachineState</code> object. If not, an exception will be thrown. Note that the state is immutable - a transition results in a new object.</p>\n<p>Here are some helper functions:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#1</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// String array of possible next states</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">StateMachine.</span><span style=\"color:#B392F0\">possible</span><span style=\"color:#E1E4E8\">(sm);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Returns _true_ if state machine cannot transition further</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">StateMachine.</span><span style=\"color:#B392F0\">done</span><span style=\"color:#E1E4E8\">(sm);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Try to automatically move to next state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">next</span><span style=\"color:#E1E4E8\">(sm);</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"class-based-usage\">Class-based usage</h2>\n<p>ixfx has a class <a href=\"https://clinth.github.io/ixfx/classes/Flow.StateMachine.WithEvents.html\"><code>StateMachine.WithEvents</code></a> which wraps the functional implementation described above and also provides events for listening for event changes.</p>\n<p>The same format is used to define possible transitions. Now there’s an mutable object, so <code>const</code> can be used:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#2</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { StateMachine } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> \"https://unpkg.com/ixfx/dist/flow.js\"</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> description</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> sleep: </span><span style=\"color:#9ECBFF\">`wakeup`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> wakeup: [</span><span style=\"color:#9ECBFF\">`coffee`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`breakfast`</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> coffee: </span><span style=\"color:#9ECBFF\">`bike`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> breakfast: </span><span style=\"color:#9ECBFF\">`bike`</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> bike: </span><span style=\"color:#79B8FF\">null</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> sm</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">WithEvents</span><span style=\"color:#E1E4E8\">(description, { initial: </span><span style=\"color:#9ECBFF\">\"sleep\"</span><span style=\"color:#E1E4E8\"> });</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Change the state by name:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.state </span><span style=\"color:#F97583\">=</span><span style=\"color:#9ECBFF\"> `wakeup`</span></span>\n<span class=\"line\"></span></code></pre>\n<p>In some cases, you might want to ask the machine to transition to its next possible state, regardless of its current state. If multiple states are possible, it will use the first one.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.</span><span style=\"color:#B392F0\">next</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Reset the machine back to its initial state with <code>reset()</code>. This is the only way to continue after reaching the final state.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#2</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.</span><span style=\"color:#B392F0\">reset</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Check status</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (sm.state </span><span style=\"color:#F97583\">===</span><span style=\"color:#9ECBFF\"> `coffee`</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (sm.isDone) </span><span style=\"color:#F97583\">...</span></span>\n<span class=\"line\"></span></code></pre>\n<p>The <code>change</code> event is fired whenever state changes, and <code>stop</code> when the machine reaches a final state.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">sm.</span><span style=\"color:#B392F0\">addEventListener</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`change`</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">evt</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`State change from ${</span><span style=\"color:#E1E4E8\">evt</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">priorState</span><span style=\"color:#9ECBFF\">} -> ${</span><span style=\"color:#E1E4E8\">evt</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">newState</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> // Prints for example:</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\"> // State change from wakeup -> breakfast</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">sm.</span><span style=\"color:#B392F0\">addEventListener</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`stop`</span><span style=\"color:#E1E4E8\">, (</span><span style=\"color:#FFAB70\">evt</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\"> console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`Machine has finished in state: ${</span><span style=\"color:#E1E4E8\">evt</span><span style=\"color:#9ECBFF\">.</span><span style=\"color:#E1E4E8\">newState</span><span style=\"color:#9ECBFF\">}`</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"simple-machines\">Simple machines</h2>\n<p><a href=\"https://clinth.github.io/ixfx/functions/Flow.StateMachine.fromList.html\"><code>StateMachine.fromList</code></a> creates transitions that steps through a series of states and then terminates.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { StateMachine } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> \"https://unpkg.com/ixfx/dist/flow.js\"</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Machine that can go: init -> one -> two -> three -> [end]</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> sm1</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(StateMachine.</span><span style=\"color:#B392F0\">fromList</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`init`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`one`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`two`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`three`</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Once in the ‘three’ state, will be considered <em>done</em>, since there is no possible transition from there.</p>\n<p><a href=\"https://clinth.github.io/ixfx/functions/Flow.StateMachine.fromListBidirectional.html\"><code>StateMachine.fromListBidirectional</code></a> is the same idea, but allow back-and-forth between states.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad#3</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Machine that can go: init &#x3C;-> one &#x3C;-> two &#x3C;-> three</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> sm2</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">init</span><span style=\"color:#E1E4E8\">(StateMachine.</span><span style=\"color:#B392F0\">fromListBidirectional</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`init`</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#9ECBFF\">`one`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`two`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">`three`</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"></span></code></pre>\n<p>In the above example, <code>sm2</code> will never be <em>done</em>, because it’s always possible for it to transition to some state.</p>\n<h2 id=\"driver\">Driver</h2>\n<div class=\"tip\"><ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/functions/Flow.StateMachine.driver.html\">StateMachine.driver</a></li>\n<li><a href=\"https://github.com/ClintH/ixfx-demos/tree/main/flow/statemachine-regions\">Example code</a>, <a href=\"https://clinth.github.io/ixfx-demos/flow/statemachine-regions/\">Online demo</a></li>\n<li><a href=\"https://glitch.com/edit/#!/ixix-state-machines-driver?path=index.html%3A1%3A0\">Glitch example</a></li>\n</ul></div>\n<p>When using state machines, it’s common to have a big <code>switch</code> statement (or lots of <code>if</code>s) to alter behaviour depending on the current state. These behaviours in turn might trigger a state change. Since this is such a common pattern, the\n<a href=\"https://clinth.github.io/ixfx/functions/Flow.StateMachine.driver.html\"><code>StateMachine.driver</code></a> is provided.</p>\n<p>With it, you set up <em>state handlers</em> for different states and guiding the machine to subsequent states.</p>\n<p>Each handler has an <code>if</code> field, a single string or array of strings corresponding to the state(s) that handler applies to. While one handler can handle multiple different states, there can’t be multiple handlers per state.</p>\n<p>The other part of the handler is <code>then</code> field. At its simplest, it is an object that tells what state to transition to, for example:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> handlers</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  if: </span><span style=\"color:#9ECBFF\">`sleeping`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#6A737D\">// If we're in the 'sleeping' state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  then: { next: </span><span style=\"color:#9ECBFF\">'walking'</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#6A737D\">// Go to 'walking' state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}]</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Note: The use of <code>if</code> and <code>then</code> for the handlers shouldn’t be mistaken for regular Javascript <code>if .. else</code> control structures.</p>\n<p>The <code>then</code> field can be an array of functions, all of which return the same kind of object. When the handler is run, it executes these functions to determine what to do. Functions defined under <code>then</code> don’t have to return a value - they could just be things you want to run when the state machine is in that state.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> handlers</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [{</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  if: </span><span style=\"color:#9ECBFF\">`walking`</span><span style=\"color:#E1E4E8\">,  </span><span style=\"color:#6A737D\">// If we're in the 'walking' state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  then: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {  </span><span style=\"color:#6A737D\">// Randomly either go to 'resting' or 'running' state next</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      if</span><span style=\"color:#E1E4E8\"> (Math.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">return</span><span style=\"color:#E1E4E8\"> { next: </span><span style=\"color:#9ECBFF\">'resting'</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">      else</span><span style=\"color:#F97583\"> return</span><span style=\"color:#E1E4E8\"> { next: </span><span style=\"color:#9ECBFF\">'running'</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}];</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Once we have the state machine and the handlers, the driver can be initialised. This would likely happen once when your sketch is initialised.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Set up driver (note the use of await for both lines)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> driver</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">driver</span><span style=\"color:#E1E4E8\">(states, handlers);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>And then, perhaps in a timing-based loop, call <code>run()</code>, which will execute a state handler for the current state.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Call .run every second</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">setInterval</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#F97583\">async</span><span style=\"color:#E1E4E8\"> () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  await</span><span style=\"color:#E1E4E8\"> driver.</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}, </span><span style=\"color:#79B8FF\">1000</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Here’s a complete example:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// States</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> states</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  sleeping: </span><span style=\"color:#9ECBFF\">'waking'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  waking: [</span><span style=\"color:#9ECBFF\">'resting'</span><span style=\"color:#E1E4E8\">,</span><span style=\"color:#9ECBFF\">'sleeping'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  resting: [</span><span style=\"color:#9ECBFF\">'sleeping'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'walking'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  walking: [</span><span style=\"color:#9ECBFF\">'running'</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">'resting'</span><span style=\"color:#E1E4E8\">],</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  running: [</span><span style=\"color:#9ECBFF\">'walking'</span><span style=\"color:#E1E4E8\">]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> handlers</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  { </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we're in the 'sleeping' state, move to next state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    if: </span><span style=\"color:#9ECBFF\">'sleeping'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    then: { next: </span><span style=\"color:#79B8FF\">true</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  { </span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">    // If we're in the 'waking' state, randomly either go to 'resting' or 'sleeping' state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    if: </span><span style=\"color:#9ECBFF\">'waking'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    then: [</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">        if</span><span style=\"color:#E1E4E8\"> (Math.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#E1E4E8\">() </span><span style=\"color:#F97583\">></span><span style=\"color:#79B8FF\"> 0.5</span><span style=\"color:#E1E4E8\">) {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          return</span><span style=\"color:#E1E4E8\"> { next: </span><span style=\"color:#9ECBFF\">'resting'</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        } </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">          return</span><span style=\"color:#E1E4E8\"> { next: </span><span style=\"color:#9ECBFF\">'sleeping'</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">        }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Set up driver</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> driver</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> StateMachine.</span><span style=\"color:#B392F0\">driver</span><span style=\"color:#E1E4E8\">(states, handlers);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Once you have the state machine and driver set up, you need to call .run() whenever you want the driver to do its thing. This might be called for example in a loop based on a timer.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">driver.</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span></code></pre>\n<p>If you use asynchronous event handlers, call <code>await driver.run()</code> instead.</p>\n<p>Some other things to do with the driver:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Check current state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">driver.</span><span style=\"color:#B392F0\">getValue</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// eg. 'resting'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Manually transition state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">driver.</span><span style=\"color:#B392F0\">to</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">'walking'</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>So far, handlers have returned an object describing what state to transition. Instead of hardcoding the state, you can use <code>{ next: true }</code> to transition to next available state. An alternative is <code>{ reset: true }</code>. When that is returned, the machine goes back to its initial state.</p>\n<p>Each result can also have a <code>score</code> field. This is only useful if you have several results under <code>then</code>. By default, the highest scoring result determines what happens.</p>\n<p>With this in mind, we can re-write the earlier example, assigning random scores for each possible next state:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  { </span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'waking'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    then</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Two functions, each returns a result with a random score each time they are executed</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\">  { </span><span style=\"color:#B392F0\">score</span><span style=\"color:#E1E4E8\">: Math.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">next</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'resting'</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      () </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\">  { </span><span style=\"color:#B392F0\">score</span><span style=\"color:#E1E4E8\">: Math.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#E1E4E8\">(), </span><span style=\"color:#B392F0\">next</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'sleeping'</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">...</span></span>\n<span class=\"line\"></span></code></pre>\n<p>In practice you might want to weight the random values so one choice is more or less likely than another. See <a href=\"../../gen/random/\">Random</a> for more on that.</p>\n<p>Each handler also has an optional <code>resultChoice</code> field, which can be ‘first’, ‘highest’, ‘lowest’ or ‘random’. By default, ‘highest’ is used, picking the highest scoring result. In our example, we might use <code>resultChoice: 'random'</code> to evenly pick between choices. With that enabled, we no longer need scores.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">    if</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'waking'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    resultChoice</span><span style=\"color:#E1E4E8\">: </span><span style=\"color:#9ECBFF\">'random'</span><span style=\"color:#E1E4E8\">,</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">    then</span><span style=\"color:#E1E4E8\">: [</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // Because of resultChoice 'random', the driver</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">      // will randomly pick one of these options when in the 'waking' state</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      { next: </span><span style=\"color:#9ECBFF\">'resting'</span><span style=\"color:#E1E4E8\"> },</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">      { next: </span><span style=\"color:#9ECBFF\">'sleeping'</span><span style=\"color:#E1E4E8\"> }</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  }</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">...</span></span>\n<span class=\"line\"></span></code></pre>\n<p>When calling <code>driver.run()</code>, a result is returned with some status information, if that’s needed:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> result</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#E1E4E8\"> driver.</span><span style=\"color:#B392F0\">run</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result.value;   </span><span style=\"color:#6A737D\">// state at the end of .run()</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result.visited; </span><span style=\"color:#6A737D\">// string array of unique states that have been visited</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">result.machine; </span><span style=\"color:#6A737D\">// original machine description</span></span>\n<span class=\"line\"></span></code></pre>\n<h3 id=\"demo\">Demo</h3>\n<p>In the demo below, the driver is used to autonomously change states based on an ‘energy’ level, also affected by current activity.</p>\n<demo-element title=\"State machine driver\" src=\"/flow/statemachine-agent/\"></demo-element></statemachineplay>";

				const frontmatter = {"title":"State Machine","layout":"../../layouts/MainLayout.astro","setup":"import { DemoElement } from '/src/components/DemoElement.ts';\nimport StateMachinePlay from './StateMachinePlay.astro';\n"};
				const file = "/Users/af4766/repos/ixfx-docs/src/pages/flow/stateMachine.md";
				const url = "/flow/stateMachine";
				function rawContent() {
					return "\n<script type=\"module\" hoist>\nimport '/src/components/ReplPad';\n</script>\n\n<div class=\"tip\"><ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Flow.StateMachine.html\">StateMachine</a></li>\n<li><a href=\"https://clinth.github.io/ixfx-demos/flow/\">Online demos</a></li>\n<li>Starter: <a href=\"https://github.com/ClintH/ixfx-demos/tree/main/flow/statemachine-starter\">GitHub</a>, <a href=\"https://glitch.com/edit/#!/ixfx-starter-statemachine\">Glitch</a>\n</ul></div>\n\nA _state machine_ allows for a controlled change from one state to another. It sets up a well-defined set of possible states and what transitions are possible between them. It's up to you to 'drive' the machine, telling it when to transition.\n\nState machines are defined with a plain object. Properties list of possible states, with values being what state(s) that are possible to change to, or _null_ if no further changes are possible.\n\n## Machine definition\n\nAn example of a simple state machine is a light switch. It has two states: _on_ and _off_. When the light is _on_, the only other state is _off_. And vice-versa:\n\n```js\n{\n  on: \"off\",\n  off: \"on\"\n}\n```\n\nWith this machine definition, it would be illegal to have a state `dimmed`, or to turn it `off` when it is already `off`. In this case, the machine never reaches a final state, it can always oscillate between `on` / `off`. Note too that we can automatically and reliably advance the state of the machine, because each state indicates what follows.\n\nIt's possible to have several possible next states by using a string array:\n\n```js\n{\n  on: [\"off\", \"half_bright\"],\n  half_bright: [\"on\", \"off\"],\n  off: \"on\"\n}\n```\n\nThe example below is intended to start with `plain` bread, with a few ways of getting to the eventual final state of `sprinkled_on_soup` or `eaten`. Once a machine is in its final state, it cannot change to another state unless it is _reset_.\n\n```js\n{\n  plain: [\"toasted\", \"buttered\", \"eaten\"],\n  toasted: [\"buttered\", \"eaten\", \"diced\"],\n  buttered: [\"eaten\", \"marmaladed\"],\n  marmaladed: \"eaten\",\n  diced: \"sprinkled_on_soup\",\n  sprinkled_on_soup: null,\n  eaten: null\n}\n```\n\n## Why?\n\nBehaving according to a current state is a common pattern in programming interactivity. This is often solved by using different variables track state. A downside is that you have to be mindful what variables or conditions alter state as well as when and where to enforce rules about state changes.\n\nA state machine therefore can help you catch errors and makes coding simpler when you know there are a fixed number of well-defined states to handle, and they are only activated according to a logic you have defined.\n\n## Playground\n\nTry out some state machines in this playground. \n\n1. Edit the description or choose a demo\n2. Click _Use description_ to load it have it checked for errors.\n3. If successful, you can see available states. Select a state and then 'Change state'\n\n(Note that properties are enclosed in \" marks here because it's represented as JSON)\n\n<StateMachinePlay />\n\n## Simple usage\n\n<div class=\"tip\"><ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Flow.StateMachine.html\">StateMachine</a></li>\n<li><a href=\"https://clinth.github.io/ixfx-demos/flow/\">Online demos</a></li>\n<li>Starter: <a href=\"https://github.com/ClintH/ixfx-demos/tree/main/flow/statemachine-starter\">GitHub</a>, <a href=\"https://glitch.com/edit/#!/ixfx-starter-statemachine\">Glitch</a>\n</ul></div>\n\nA simple way of using the state machine is the functional, immutable approach. Create the machine with its _description_ and _initial state_:\n\n```js\nconst machine = StateMachine.init({\n  on: \"off\",\n  off: \"on\"\n}, \"on\");\n```\n\nThe machine description is a simple object that 1) lists all possible states (as its top-level properties), and 2) for each state, what other state(s) can be transitioned to, or `null` if it is a final state.\n\nThe following example has four possible states (`wakeup, sleep, coffee, breakfast, bike`). `sleep` can only transition to the `wakeup` state, while `wakeup` can transition to either `coffee` or `breakfast`. \n\nUse _null_ to signify the final state. Multiple states can terminate the machine if desired.\n\n```js\n// repl-pad#1\nimport { StateMachine } from \"https://unpkg.com/ixfx/dist/flow.js\"\n\nconst description = { \n sleep: `wakeup`,\n wakeup: [`coffee`, `breakfast`],\n coffee: `bike`,\n breakfast: `bike`,\n bike: null\n}\nlet sm = StateMachine.init(description, `sleep`);\n```\n\n`StateMachine.init` returns [`MachineState`](https://clinth.github.io/ixfx/types/Flow.StateMachine.MachineState.html) which captures the definition of the machine and its current state:\n\n```js\n// repl-pad#1\n// Current state\nsm.value; // eg. 'bike'\n// List of unique states visited\nsm.visited; // eg. ['sleep', 'wakeup']\n// Original machine definition\nsm.machine; \n```\n\nTo attempt to change state, use [`StateMachine.to`](https://clinth.github.io/ixfx/functions/Flow.StateMachine.to.html)\n\n```js\n// repl-pad#1\n// Transition existing machine to state 'wakeup'\nsm = StateMachine.to(sm, 'wakeup');\nsm.value; // 'wakeup'\n```\n\nIf this is a legal transition, you'll get a new `MachineState` object. If not, an exception will be thrown. Note that the state is immutable - a transition results in a new object.\n\nHere are some helper functions:\n```js\n// repl-pad#1\n// String array of possible next states\nStateMachine.possible(sm);\n\n// Returns _true_ if state machine cannot transition further\nStateMachine.done(sm);\n\n// Try to automatically move to next state\nsm = StateMachine.next(sm);\n```\n\n## Class-based usage\n\nixfx has a class [`StateMachine.WithEvents`](https://clinth.github.io/ixfx/classes/Flow.StateMachine.WithEvents.html) which wraps the functional implementation described above and also provides events for listening for event changes.\n\nThe same format is used to define possible transitions. Now there's an mutable object, so `const` can be used:\n\n```js\n// repl-pad#2\nimport { StateMachine } from \"https://unpkg.com/ixfx/dist/flow.js\"\nconst description = { \n sleep: `wakeup`,\n wakeup: [`coffee`, `breakfast`],\n coffee: `bike`,\n breakfast: `bike`,\n bike: null\n}\nconst sm = new StateMachine.WithEvents(description, { initial: \"sleep\" });\n```\n\nChange the state by name:\n\n```js\n// repl-pad#2\nsm.state = `wakeup`\n```\n\nIn some cases, you might want to ask the machine to transition to its next possible state, regardless of its current state. If multiple states are possible, it will use the first one.\n\n```js\n// repl-pad#2\nsm.next();\n```\n\nReset the machine back to its initial state with `reset()`. This is the only way to continue after reaching the final state.\n\n```js\n// repl-pad#2\nsm.reset();\n```\n\nCheck status\n\n```js\nif (sm.state === `coffee`) ...\nif (sm.isDone) ...\n```\n\nThe `change` event is fired whenever state changes, and `stop` when the machine reaches a final state.\n\n```js\nsm.addEventListener(`change`, (evt) => {\n console.log(`State change from ${evt.priorState} -> ${evt.newState}`);\n\n // Prints for example:\n // State change from wakeup -> breakfast\n});\n\nsm.addEventListener(`stop`, (evt) => {\n console.log(`Machine has finished in state: ${evt.newState}`);\n});\n```\n\n## Simple machines\n\n[`StateMachine.fromList`](https://clinth.github.io/ixfx/functions/Flow.StateMachine.fromList.html) creates transitions that steps through a series of states and then terminates.\n\n```js\n// repl-pad#3\nimport { StateMachine } from \"https://unpkg.com/ixfx/dist/flow.js\"\n// Machine that can go: init -> one -> two -> three -> [end]\nconst sm1 = StateMachine.init(StateMachine.fromList(`init`, `one`, `two`, `three`));\n```\n\nOnce in the 'three' state, will be considered _done_, since there is no possible transition from there.\n\n[`StateMachine.fromListBidirectional`](https://clinth.github.io/ixfx/functions/Flow.StateMachine.fromListBidirectional.html) is the same idea, but allow back-and-forth between states.\n\n```js\n// repl-pad#3\n// Machine that can go: init <-> one <-> two <-> three\nconst sm2 = StateMachine.init(StateMachine.fromListBidirectional(`init`,`one`, `two`, `three`));\n```\n\nIn the above example, `sm2` will never be _done_, because it's always possible for it to transition to some state.\n\n## Driver\n\n<div class=\"tip\"><ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/functions/Flow.StateMachine.driver.html\">StateMachine.driver</a></li>\n<li><a href=\"https://github.com/ClintH/ixfx-demos/tree/main/flow/statemachine-regions\">Example code</a>, <a href=\"https://clinth.github.io/ixfx-demos/flow/statemachine-regions/\">Online demo</a></li>\n<li><a href=\"https://glitch.com/edit/#!/ixix-state-machines-driver?path=index.html%3A1%3A0\">Glitch example</a></li>\n</ul></div>\n\nWhen using state machines, it's common to have a big `switch` statement (or lots of `if`s) to alter behaviour depending on the current state. These behaviours in turn might trigger a state change. Since this is such a common pattern, the \n[`StateMachine.driver`](https://clinth.github.io/ixfx/functions/Flow.StateMachine.driver.html) is provided.\n\nWith it, you set up _state handlers_ for different states and guiding the machine to subsequent states. \n\nEach handler has an `if` field, a single string or array of strings corresponding to the state(s) that handler applies to. While one handler can handle multiple different states, there can't be multiple handlers per state.\n\nThe other part of the handler is `then` field. At its simplest, it is an object that tells what state to transition to, for example:\n```js\nconst handlers = [{\n  if: `sleeping`, // If we're in the 'sleeping' state\n  then: { next: 'walking' } // Go to 'walking' state\n}]\n```\n\nNote: The use of `if` and `then` for the handlers shouldn't be mistaken for regular Javascript `if .. else` control structures.\n\nThe `then` field can be an array of functions, all of which return the same kind of object. When the handler is run, it executes these functions to determine what to do. Functions defined under `then` don't have to return a value - they could just be things you want to run when the state machine is in that state.\n\n```js\nconst handlers = [{\n  if: `walking`,  // If we're in the 'walking' state\n  then: [\n    () => {  // Randomly either go to 'resting' or 'running' state next\n      if (Math.random() > 0.5) return { next: 'resting' }\n      else return { next: 'running' }\n    }\n  ]\n}];\n```\n\nOnce we have the state machine and the handlers, the driver can be initialised. This would likely happen once when your sketch is initialised.\n\n```js\n// Set up driver (note the use of await for both lines)\nconst driver = await StateMachine.driver(states, handlers);\n```\n\nAnd then, perhaps in a timing-based loop, call `run()`, which will execute a state handler for the current state.\n\n```js\n// Call .run every second\nsetInterval(async () => {\n  await driver.run();\n}, 1000);\n```\n\nHere's a complete example:\n\n```js\n// States\nconst states = {\n  sleeping: 'waking',\n  waking: ['resting','sleeping'],\n  resting: ['sleeping', 'walking'],\n  walking: ['running', 'resting'],\n  running: ['walking']\n};\n\nconst handlers = [\n  { \n    // If we're in the 'sleeping' state, move to next state\n    if: 'sleeping',\n    then: { next: true }\n  },\n  { \n    // If we're in the 'waking' state, randomly either go to 'resting' or 'sleeping' state\n    if: 'waking',\n    then: [\n      () => {\n        if (Math.random() > 0.5) {\n          return { next: 'resting' }\n        } else {\n          return { next: 'sleeping' }\n        }\n      }\n    ]\n  }\n];\n\n// Set up driver\nconst driver = await StateMachine.driver(states, handlers);\n```\n\nOnce you have the state machine and driver set up, you need to call .run() whenever you want the driver to do its thing. This might be called for example in a loop based on a timer.\n```js\ndriver.run();\n```\n\nIf you use asynchronous event handlers, call `await driver.run()` instead.\n\nSome other things to do with the driver:\n```js\n// Check current state\ndriver.getValue(); // eg. 'resting'\n\n// Manually transition state\ndriver.to('walking');\n```\n\nSo far, handlers have returned an object describing what state to transition. Instead of hardcoding the state, you can use `{ next: true }` to transition to next available state. An alternative is `{ reset: true }`. When that is returned, the machine goes back to its initial state.\n\nEach result can also have a `score` field. This is only useful if you have several results under `then`. By default, the highest scoring result determines what happens. \n\nWith this in mind, we can re-write the earlier example, assigning random scores for each possible next state:\n\n```js\n...\n  { \n    if: 'waking',\n    then: [\n      // Two functions, each returns a result with a random score each time they are executed\n      () =>  { score: Math.random(), next: 'resting' },\n      () =>  { score: Math.random(), next: 'sleeping' }\n    ]\n  }\n...\n```\n\nIn practice you might want to weight the random values so one choice is more or less likely than another. See [Random](../../gen/random/) for more on that.\n\nEach handler also has an optional `resultChoice` field, which can be 'first', 'highest', 'lowest' or 'random'. By default, 'highest' is used, picking the highest scoring result. In our example, we might use `resultChoice: 'random'` to evenly pick between choices. With that enabled, we no longer need scores.\n\n```js\n...\n  {\n    if: 'waking',\n    resultChoice: 'random',\n    then: [\n      // Because of resultChoice 'random', the driver\n      // will randomly pick one of these options when in the 'waking' state\n      { next: 'resting' },\n      { next: 'sleeping' }\n    ]\n  }\n...\n```\n\nWhen calling `driver.run()`, a result is returned with some status information, if that's needed:\n\n```js\nconst result = await driver.run();\nresult.value;   // state at the end of .run()\nresult.visited; // string array of unique states that have been visited\nresult.machine; // original machine description\n```\n\n### Demo\n\nIn the demo below, the driver is used to autonomously change states based on an 'energy' level, also affected by current activity.\n\n<demo-element title=\"State machine driver\" src=\"/flow/statemachine-agent/\" />\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"machine-definition","text":"Machine definition"},{"depth":2,"slug":"why","text":"Why?"},{"depth":2,"slug":"playground","text":"Playground"},{"depth":2,"slug":"simple-usage","text":"Simple usage"},{"depth":2,"slug":"class-based-usage","text":"Class-based usage"},{"depth":2,"slug":"simple-machines","text":"Simple machines"},{"depth":2,"slug":"driver","text":"Driver"},{"depth":3,"slug":"demo","text":"Demo"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$MainLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html)}`
							})}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
