import { c as createComponent, r as renderTemplate, a as renderComponent, u as unescapeHTML } from './astro/server__cawITtY.mjs';
import 'kleur/colors';
import { $ as $$MainLayout } from './MainLayout_BFrOPY-O.mjs';

const html = "<script type=\"module\" hoist=\"\">\n  import '/src/components/ReplPad';\n</script>\n<div class=\"tip\">\n<ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Data.html\">Data module</a></li>\n<li>See also: <a href=\"../trackers/#numbers\">Number trackers</a>\n</li></ul></div>\n<h2 id=\"noise\">Noise</h2>\n<p>Data can be noisy or jittery: instead of a convienent smooth line of a sensor going up and down, there might be all kinds of spikes, or perhaps the value is never static, always wavering up and down.</p>\n<p>While we typically want to respond with nuance to input (be it from a human action, sensor, machine learning inference etc), we don’t necessarily want to work with single data points in isolation. Because if we express a currently very low reading, it might be an erroneous spike in the data, not reflecting the average of the data, or the qualitative aspect we are working with.</p>\n<p>Examples sources with noise and jitter:</p>\n<ul>\n<li>Pointer move events on a touch screen: <em>x</em> and <em>y</em> will move slightly, even though we might feel like we’re not moving a finger</li>\n<li>Audio level input: a very jittery input</li>\n<li>Ultrasound sensor: signals might hit different angles of the same object, giving each pulse a different value</li>\n<li>Pose detection via machine learning: a very jittery collection of points which shift around and snap in and out of existence</li>\n</ul>\n<demo-element style=\"height:40vh\" title=\"Moving average\" src=\"/data/moving-average-audio/\">\n<p>Even the humble physical button can exhibit jitter, where a single physical press is actually registered as several presses. In code, this is solved through a <a href=\"https://clinth.github.io/ixfx/functions/Flow.debounce.html\"><code>debounce</code></a> function. Noise from physical sensors - particularly analog sensors - can also sometimes be reduced in the hardware domain.</p>\n<h2 id=\"averaging-a-data-set\">Averaging a data set</h2>\n<p>If you have all the values you want to average in advance, it’s straightforward calculate using</p>\n<ul>\n<li>Simple averaging: <a href=\"https://clinth.github.io/ixfx/functions/Collections.Arrays.average.html\"><code>Arrays.average</code></a>, or</li>\n<li>Weighted averaging: <a href=\"https://clinth.github.io/ixfx/functions/Collections.Arrays.averageWeighted.html\"><code>Arrays.averageWeighted</code></a></li>\n</ul>\n<h3 id=\"simple\">Simple</h3>\n<p>The basic way to average is to add up all the values and divide by the number of values.</p>\n<p>This is easy to do from ‘first principles’:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> average</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">numbers</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> total</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> numbers.</span><span style=\"color:#B392F0\">reduce</span><span style=\"color:#E1E4E8\">((</span><span style=\"color:#FFAB70\">acc</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">v</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> acc </span><span style=\"color:#F97583\">+</span><span style=\"color:#E1E4E8\"> v, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  return</span><span style=\"color:#E1E4E8\"> total </span><span style=\"color:#F97583\">/</span><span style=\"color:#E1E4E8\"> numbers.</span><span style=\"color:#79B8FF\">length</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">average</span><span style=\"color:#E1E4E8\">([</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Yields: 20</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Or otherwise, using ixfx’s <a href=\"https://clinth.github.io/ixfx/functions/Collections.Arrays.average.html\"><code>Arrays.average</code></a>. It silently ignores non-numbers (<em>undefined</em>, <em>null</em>, <em>NaN</em> etc), which can be useful.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Arrays } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/collections.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pass in an array:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Arrays.</span><span style=\"color:#B392F0\">average</span><span style=\"color:#E1E4E8\">([</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">]);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>If you have a set of numbers to average not already in an array, <a href=\"https://clinth.github.io/ixfx/functions/Numbers.average.html\"><code>Numbers.average</code></a> is effectively the same as <code>Arrays.average</code>, but takes in a spread set of parameters:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#79B8FF\"> *</span><span style=\"color:#F97583\"> as</span><span style=\"color:#E1E4E8\"> Numbers </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/numbers.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Numbers.</span><span style=\"color:#B392F0\">average</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">30</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> a</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> b</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 20</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> c</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 30</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Numbers.</span><span style=\"color:#B392F0\">average</span><span style=\"color:#E1E4E8\">(a, b, c);</span></span>\n<span class=\"line\"></span></code></pre>\n<h3 id=\"weighted-averaging\">Weighted averaging</h3>\n<p>Rather than give all recorded values equal prominence in the average calculation, it’s possible to weight them. For example, giving higher priority to more recent values.</p>\n<p>ixfx’s <a href=\"https://clinth.github.io/ixfx/functions/Collections.Arrays.averageWeighted.html\"><code>Arrays.averageWeighted</code></a> can help with this.</p>\n<p>A simple approach is to use a function which calculates the weighting of a given element. Here we can use one of the <a href=\"../../modulation/easing/\">easing functions</a>.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Arrays } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/collections.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Easings } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/modulation.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> data</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [ </span><span style=\"color:#79B8FF\">1</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\"> ];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Gaussian will weigh middle elements most heavily</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Yields: 25</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Arrays.</span><span style=\"color:#B392F0\">averageWeighted</span><span style=\"color:#E1E4E8\">(data, Easings.</span><span style=\"color:#B392F0\">gaussian</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// quadIn will weigh most recent (end-of-array) elements most heavily</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Yields: 97</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">Arrays.</span><span style=\"color:#B392F0\">averageWeighted</span><span style=\"color:#E1E4E8\">(data, Easings.</span><span style=\"color:#B392F0\">get</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`quadIn`</span><span style=\"color:#E1E4E8\">));</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"averaging-streams\">Averaging streams</h2>\n<p>When averaging a stream, we don’t have the ‘full picture’ of all the data to average perfectly. This is because it’s infeasible to keep a store of all data and it’s not certain what data will arrive next. It’s similiar issue we face when <a href=\"../normalising/#stream\">normalising streams</a>.</p>\n<h3 id=\"tracker\">Tracker</h3>\n<p>Ixfx has several <a href=\"../trackers/\">‘trackers’</a>, intended for monitoring the range of data in a stream. By default they don’t record each data point, but rather keep a running total and average.</p>\n<p>Here’s the <a href=\"https://clinth.github.io/ixfx/functions/Data.numberTracker.html\"><code>numberTracker</code></a> illustrated:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { numberTracker } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/data.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Initialise</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> t</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> numberTracker</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add some random values</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">;i</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">;i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) t.</span><span style=\"color:#B392F0\">seen</span><span style=\"color:#E1E4E8\">(Math.</span><span style=\"color:#B392F0\">floor</span><span style=\"color:#E1E4E8\">(Math.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#E1E4E8\">()</span><span style=\"color:#F97583\">*</span><span style=\"color:#79B8FF\">100</span><span style=\"color:#E1E4E8\">)));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Get average</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">t.avg</span></span>\n<span class=\"line\"></span></code></pre>\n<p>These trackers are not great at adapting to temporal changes because by default they track the global average of stream (or at least, the data seen thus far). Typically we’d want to only consider the average of <em>recent</em> data, which is where <a href=\"#moving-average\">moving averages</a> are better.</p>\n<p>It is, however, possible to set some options on the tracker to automatically reset itself after <em>n</em> samples, or to reset it yourself.</p>\n<h3 id=\"moving-average\">Moving average</h3>\n<p>The moving averaging technique (AKA <em>moving</em> or <em>sliding window</em>) keeps track of the last <em>n</em> values for the purposes of averaging. This way we only record a small chunk of recent data rather than attempt to store everything.</p>\n<p>When using moving averaging, a key tuning parameter is the size of the ‘window’: how many items to keep track of. A larger window size will smooth noise at the expense of being less responsive to change. A smaller window size will more noisy but more accurately track the current data.</p>\n<p>This tuning also needs to be done with respect to speed at which data is added. There’s a big difference to a window size of 5 items if you’re adding 100 items per millisecond versus one item per minute.</p>\n<p><a href=\"https://clinth.github.io/ixfx/functions/Data.movingAverage.html\"><code>movingAverage</code></a> takes a parameter for how many items to track. <code>movingAverage</code> returns an object to add or clear the moving average.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> {movingAverage} </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/data.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Keep track of the last 10 items</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> ma</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> movingAverage</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Each call to `add` returns the current average</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ma.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ma.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">);  </span><span style=\"color:#6A737D\">// 7.5</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Use <code>clear</code> to clear data, or <code>compute</code> to calculate the average without adding new data</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#E1E4E8\">ma.</span><span style=\"color:#B392F0\">compute</span><span style=\"color:#E1E4E8\">(); </span><span style=\"color:#6A737D\">// Yields current average</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ma.</span><span style=\"color:#B392F0\">clear</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"></span></code></pre>\n<h3 id=\"exponential-weighted-moving-average\">Exponential weighted moving average</h3>\n<p>An alternative approach is an <em>exponential weighted moving average</em>, which can calculate an average without storing data samples. This is a common technique on microcontrollers.</p>\n<p>It’s implemented as <a href=\"https://clinth.github.io/ixfx/functions/Data.movingAverageLight.html\"><code>movingAverageLight</code></a>. Instead of passing the number of samples to record, a <em>scale</em> parameter is used. 1 means the latest value is used - that is, no averaging. Higher numbers blend in the latest value with increasingly lower priority. 3 is the default scaling if the parameter is not provided.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { movingAverageLight } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/data.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Init with a scaling of 3</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> ma</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> movingAverageLight</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">3</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ma.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">10</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// 10</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">ma.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">5</span><span style=\"color:#E1E4E8\">); </span><span style=\"color:#6A737D\">// 7.5</span></span>\n<span class=\"line\"></span></code></pre>\n<h3 id=\"moving-average-timed\">Moving average timed</h3>\n<p>Consider calculating the average speed of the pointer. Pointer events are tracked, with the distance travelled and elapsed time used to calculate the speed at that instant. The speed is then averaged via <code>movingAverageLight()</code>. This is fine while the pointer is moving, but if the pointer stops, there won’t be any events. Consequentially, the average won’t drop down to zero speed over time because the events are no longer flowing.</p>\n<p>One solution to this is using <a href=\"https://clinth.github.io/ixfx/functions/Data.movingAverageTimed.html\"><code>Data.movingAverageTimed</code></a>. This takes in an update rate (milliseconds) and a default value that gets added to the averager. It’s based on <code>movingAverageLight</code>, so the same <em>scale</em> parameter is there too.</p>\n<p>If the interval has elapsed since the last value is added to the averager, it will automatically add the default value. In the case of calculating speed, we might want to automatically add <code>0</code>, since the speed must be zero if there are no events.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { movingAverageTimed } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/data.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// movingAverageTimed(updateRateMs, value, scaling): MovingAverage</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Init averager</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> avgSpeed</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> movingAverageTimed</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#79B8FF\">500</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Based on pointermove, calculate a speed and add to averager</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">document.</span><span style=\"color:#B392F0\">addEventListener</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">`pointermove`</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#FFAB70\">evt</span><span style=\"color:#F97583\"> =></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> speed</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> calcSpeed</span><span style=\"color:#E1E4E8\">(evt);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  avgSpeed.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(speed);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">});</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"case-averaging-complex-data\">Case: Averaging complex data</h2>\n<p>Let us say you want to average more complex data over time, say a rectangle from a machine learning library. The rectangle has <em>x</em>, <em>y</em>, <em>width</em> and <em>height</em> properties, and each of these we want to average seperately.</p>\n<p>To do so, we initialise a moving average for each property, and when new data comes in, update the approprate averager. A cumulative average rectangle is kept track of as well, so elsewhere in the code we can always read the current average.</p>\n<p>ixfx’s <code>mapObject</code> is used to map each property of an empty rectangle (x, y, width &#x26; height) to a new moving averager. In this way, <code>movingAverageRect</code> becomes a set of automatically-generated moving averagers.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"js\"><code><span class=\"line\"><span style=\"color:#6A737D\">// repl-pad</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { movingAverage } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/data.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { Rects } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/geometry.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">import</span><span style=\"color:#E1E4E8\"> { mapObject } </span><span style=\"color:#F97583\">from</span><span style=\"color:#9ECBFF\"> 'https://unpkg.com/ixfx/dist/util.js'</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// How many samples to average over for each property</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> samples</span><span style=\"color:#F97583\"> =</span><span style=\"color:#79B8FF\"> 10</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Create an average for each of the rect's properties (x, y, width, height)</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> movingAverageRect</span><span style=\"color:#F97583\"> =</span><span style=\"color:#B392F0\"> mapObject</span><span style=\"color:#E1E4E8\">(Rects.empty, </span><span style=\"color:#FFAB70\">v</span><span style=\"color:#F97583\"> =></span><span style=\"color:#B392F0\"> movingAverage</span><span style=\"color:#E1E4E8\">(samples));</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Continually-updated average rectangle</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> averageRect </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { x: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, y: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, width: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">, height: </span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">};</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add a new rectangle to be averaged</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#B392F0\"> add</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#FFAB70\">r</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#F97583\">=></span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#E1E4E8\"> { </span><span style=\"color:#79B8FF\">x</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">y</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">width</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#79B8FF\">height</span><span style=\"color:#E1E4E8\"> } </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> movingAverageRect;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Add each of the properties of the input rectangle 'r'</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // to separate averagers. We then collect all the averages</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // in 'averageRect'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  averageRect </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { </span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    x: x.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(r.x),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    y: y.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(r.y),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    width: width.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(r.width),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">    height: height.</span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(r.height)};</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Add 20 random rectangles</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">for</span><span style=\"color:#E1E4E8\"> (</span><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> i</span><span style=\"color:#F97583\">=</span><span style=\"color:#79B8FF\">0</span><span style=\"color:#E1E4E8\">;i</span><span style=\"color:#F97583\">&#x3C;</span><span style=\"color:#79B8FF\">20</span><span style=\"color:#E1E4E8\">;i</span><span style=\"color:#F97583\">++</span><span style=\"color:#E1E4E8\">) </span><span style=\"color:#B392F0\">add</span><span style=\"color:#E1E4E8\">(Rects.</span><span style=\"color:#B392F0\">random</span><span style=\"color:#E1E4E8\">());</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// This is the average after 20 random rects...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">averageRect;</span></span>\n<span class=\"line\"></span></code></pre>\n<demo-element title=\"Moving average pointer\" src=\"/data/moving-average-pointer/\"></demo-element></demo-element>";

				const frontmatter = {"title":"Averaging","layout":"../../layouts/MainLayout.astro","setup":"import { DemoElement } from '../../components/DemoElement.ts';\n"};
				const file = "/Users/af4766/repos/ixfx-docs/src/pages/data/averaging.md";
				const url = "/data/averaging";
				function rawContent() {
					return "\n<script type=\"module\" hoist>\n  import '/src/components/ReplPad';\n</script>\n\n<div class=\"tip\">\n<ul>\n<li>API Reference <a href=\"https://clinth.github.io/ixfx/modules/Data.html\">Data module</a></li>\n<li>See also: <a href=\"../trackers/#numbers\">Number trackers</a>\n</div>\n\n## Noise\n\nData can be noisy or jittery: instead of a convienent smooth line of a sensor going up and down, there might be all kinds of spikes, or perhaps the value is never static, always wavering up and down.\n\nWhile we typically want to respond with nuance to input (be it from a human action, sensor, machine learning inference etc), we don't necessarily want to work with single data points in isolation. Because if we express a currently very low reading, it might be an erroneous spike in the data, not reflecting the average of the data, or the qualitative aspect we are working with.\n\nExamples sources with noise and jitter:\n* Pointer move events on a touch screen: _x_ and _y_ will move slightly, even though we might feel like we're not moving a finger\n* Audio level input: a very jittery input\n* Ultrasound sensor: signals might hit different angles of the same object, giving each pulse a different value\n* Pose detection via machine learning: a very jittery collection of points which shift around and snap in and out of existence\n\n<demo-element style=\"height:40vh\" title=\"Moving average\" src=\"/data/moving-average-audio/\" />\n\nEven the humble physical button can exhibit jitter, where a single physical press is actually registered as several presses. In code, this is solved through a [`debounce`](https://clinth.github.io/ixfx/functions/Flow.debounce.html) function. Noise from physical sensors - particularly analog sensors - can also sometimes be reduced in the hardware domain.\n\n## Averaging a data set\n\nIf you have all the values you want to average in advance, it's straightforward calculate using\n* Simple averaging: [`Arrays.average`](https://clinth.github.io/ixfx/functions/Collections.Arrays.average.html), or\n* Weighted averaging: [`Arrays.averageWeighted`](https://clinth.github.io/ixfx/functions/Collections.Arrays.averageWeighted.html)\n\n\n### Simple\n\nThe basic way to average is to add up all the values and divide by the number of values.\n\nThis is easy to do from 'first principles':\n\n```js\nconst average = (numbers) => {\n  const total = numbers.reduce((acc, v) => acc + v, 0);\n  return total / numbers.length;\n};\naverage([10, 20, 30]);\n// Yields: 20\n```\n\nOr otherwise, using ixfx's [`Arrays.average`](https://clinth.github.io/ixfx/functions/Collections.Arrays.average.html). It silently ignores non-numbers (_undefined_, _null_, _NaN_ etc), which can be useful.\n\n```js\n// repl-pad\nimport { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\n\n// Pass in an array:\nArrays.average([10, 20, 30]);\n```\n\nIf you have a set of numbers to average not already in an array, [`Numbers.average`](https://clinth.github.io/ixfx/functions/Numbers.average.html) is effectively the same as `Arrays.average`, but takes in a spread set of parameters:\n\n```js\n// repl-pad\nimport * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n\nNumbers.average(10, 20, 30);\n\nconst a = 10;\nconst b = 20;\nconst c = 30;\nNumbers.average(a, b, c);\n```\n\n### Weighted averaging\n\nRather than give all recorded values equal prominence in the average calculation, it's possible to weight them. For example, giving higher priority to more recent values.\n\nixfx's [`Arrays.averageWeighted`](https://clinth.github.io/ixfx/functions/Collections.Arrays.averageWeighted.html) can help with this. \n\nA simple approach is to use a function which calculates the weighting of a given element. Here we can use one of the [easing functions](../../modulation/easing/).\n\n```js\n// repl-pad\nimport { Arrays } from 'https://unpkg.com/ixfx/dist/collections.js';\nimport { Easings } from 'https://unpkg.com/ixfx/dist/modulation.js';\n\nconst data = [ 1, 10, 100 ];\n\n// Gaussian will weigh middle elements most heavily\n// Yields: 25\nArrays.averageWeighted(data, Easings.gaussian());\n\n// quadIn will weigh most recent (end-of-array) elements most heavily\n// Yields: 97\nArrays.averageWeighted(data, Easings.get(`quadIn`));\n```\n\n## Averaging streams\n\nWhen averaging a stream, we don't have the 'full picture' of all the data to average perfectly. This is because it's infeasible to keep a store of all data and it's not certain what data will arrive next. It's similiar issue we face when [normalising streams](../normalising/#stream).\n\n### Tracker\n\nIxfx has several ['trackers'](../trackers/), intended for monitoring the range of data in a stream. By default they don't record each data point, but rather keep a running total and average.\n\nHere's the [`numberTracker`](https://clinth.github.io/ixfx/functions/Data.numberTracker.html) illustrated:\n\n```js\n// repl-pad\nimport { numberTracker } from 'https://unpkg.com/ixfx/dist/data.js';\n\n// Initialise\nconst t = numberTracker();\n\n// Add some random values\nfor (let i=0;i<10;i++) t.seen(Math.floor(Math.random()*100)));\n\n// Get average\nt.avg\n```\n\nThese trackers are not great at adapting to temporal changes because by default they track the global average of stream (or at least, the data seen thus far). Typically we'd want to only consider the average of _recent_ data, which is where [moving averages](#moving-average) are better.\n\nIt is, however, possible to set some options on the tracker to automatically reset itself after _n_ samples, or to reset it yourself.\n\n### Moving average\n\nThe moving averaging technique (AKA _moving_ or _sliding window_) keeps track of the last _n_ values for the purposes of averaging. This way we only record a small chunk of recent data rather than attempt to store everything.\n\nWhen using moving averaging, a key tuning parameter is the size of the 'window': how many items to keep track of. A larger window size will smooth noise at the expense of being less responsive to change. A smaller window size will more noisy but more accurately track the current data.\n\nThis tuning also needs to be done with respect to speed at which data is added. There's a big difference to a window size of 5 items if you're adding 100 items per millisecond versus one item per minute.\n\n[`movingAverage`](https://clinth.github.io/ixfx/functions/Data.movingAverage.html) takes a parameter for how many items to track. `movingAverage` returns an object to add or clear the moving average.\n\n```js\n// repl-pad\nimport {movingAverage} from 'https://unpkg.com/ixfx/dist/data.js';\n\n// Keep track of the last 10 items\nconst ma = movingAverage(10);\n\n// Each call to `add` returns the current average\nma.add(10); // 10\nma.add(5);  // 7.5\n```\n\nUse `clear` to clear data, or `compute` to calculate the average without adding new data\n\n```js\nma.compute(); // Yields current average\nma.clear();\n```\n\n\n### Exponential weighted moving average\n\nAn alternative approach is an _exponential weighted moving average_, which can calculate an average without storing data samples. This is a common technique on microcontrollers. \n\nIt's implemented as [`movingAverageLight`](https://clinth.github.io/ixfx/functions/Data.movingAverageLight.html). Instead of passing the number of samples to record, a _scale_ parameter is used. 1 means the latest value is used - that is, no averaging. Higher numbers blend in the latest value with increasingly lower priority. 3 is the default scaling if the parameter is not provided.\n\n```js\n// repl-pad\nimport { movingAverageLight } from 'https://unpkg.com/ixfx/dist/data.js';\n\n// Init with a scaling of 3\nconst ma = movingAverageLight(3);\nma.add(10); // 10\nma.add(5); // 7.5\n```\n\n### Moving average timed\n\nConsider calculating the average speed of the pointer. Pointer events are tracked, with the distance travelled and elapsed time used to calculate the speed at that instant. The speed is then averaged via `movingAverageLight()`. This is fine while the pointer is moving, but if the pointer stops, there won't be any events. Consequentially, the average won't drop down to zero speed over time because the events are no longer flowing.\n\nOne solution to this is using [`Data.movingAverageTimed`](https://clinth.github.io/ixfx/functions/Data.movingAverageTimed.html). This takes in an update rate (milliseconds) and a default value that gets added to the averager. It's based on `movingAverageLight`, so the same _scale_ parameter is there too.\n\nIf the interval has elapsed since the last value is added to the averager, it will automatically add the default value. In the case of calculating speed, we might want to automatically add `0`, since the speed must be zero if there are no events.\n\n```js\nimport { movingAverageTimed } from 'https://unpkg.com/ixfx/dist/data.js';\n// movingAverageTimed(updateRateMs, value, scaling): MovingAverage\n\n// Init averager\nconst avgSpeed = movingAverageTimed(500, 0);\n\n// Based on pointermove, calculate a speed and add to averager\ndocument.addEventListener(`pointermove`, evt => {\n  const speed = calcSpeed(evt);\n  avgSpeed.add(speed);\n});\n```\n\n## Case: Averaging complex data\n\nLet us say you want to average more complex data over time, say a rectangle from a machine learning library. The rectangle has _x_, _y_, _width_ and _height_ properties, and each of these we want to average seperately.\n\nTo do so, we initialise a moving average for each property, and when new data comes in, update the approprate averager. A cumulative average rectangle is kept track of as well, so elsewhere in the code we can always read the current average.\n\nixfx's `mapObject` is used to map each property of an empty rectangle (x, y, width & height) to a new moving averager. In this way, `movingAverageRect` becomes a set of automatically-generated moving averagers.\n\n```js\n// repl-pad\nimport { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\nimport { Rects } from 'https://unpkg.com/ixfx/dist/geometry.js';\nimport { mapObject } from 'https://unpkg.com/ixfx/dist/util.js';\n\n// How many samples to average over for each property\nconst samples = 10;\n\n// Create an average for each of the rect's properties (x, y, width, height)\nconst movingAverageRect = mapObject(Rects.empty, v => movingAverage(samples));\n\n// Continually-updated average rectangle\nlet averageRect = { x: 0, y: 0, width: 0, height: 0};\n\n// Add a new rectangle to be averaged\nconst add = (r) => {\n  const { x, y, width, height } = movingAverageRect;\n\n  // Add each of the properties of the input rectangle 'r'\n  // to separate averagers. We then collect all the averages\n  // in 'averageRect'\n  averageRect = { \n    x: x.add(r.x),\n    y: y.add(r.y),\n    width: width.add(r.width),\n    height: height.add(r.height)};\n}\n\n// Add 20 random rectangles\nfor (let i=0;i<20;i++) add(Rects.random());\n\n// This is the average after 20 random rects...\naverageRect;\n```\n\n<demo-element title=\"Moving average pointer\" src=\"/data/moving-average-pointer/\" />\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"noise","text":"Noise"},{"depth":2,"slug":"averaging-a-data-set","text":"Averaging a data set"},{"depth":3,"slug":"simple","text":"Simple"},{"depth":3,"slug":"weighted-averaging","text":"Weighted averaging"},{"depth":2,"slug":"averaging-streams","text":"Averaging streams"},{"depth":3,"slug":"tracker","text":"Tracker"},{"depth":3,"slug":"moving-average","text":"Moving average"},{"depth":3,"slug":"exponential-weighted-moving-average","text":"Exponential weighted moving average"},{"depth":3,"slug":"moving-average-timed","text":"Moving average timed"},{"depth":2,"slug":"case-averaging-complex-data","text":"Case: Averaging complex data"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$MainLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html)}`
							})}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
