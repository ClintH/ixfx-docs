import { c as createMetadata, a as createAstro, b as createComponent, r as render, d as renderComponent } from './chunks/index.7bfc2e7e.mjs';
import { $ as $$module1, a as $$MainLayout } from './chunks/MainLayout.fae6d6b7.mjs';
import 'shorthash';
import 'serialize-javascript';
import 'preact/hooks';
import 'preact/jsx-runtime';
import 'lit';

const metadata = { "headers": [{ "depth": 2, "slug": "background", "text": "Background" }, { "depth": 2, "slug": "count", "text": "Count" }, { "depth": 2, "slug": "numeric-range", "text": "Numeric range" }, { "depth": 2, "slug": "percentages", "text": "Percentages" }, { "depth": 2, "slug": "ping-pong", "text": "Ping pong" }, { "depth": 2, "slug": "generator-helper-functions", "text": "Generator helper functions" }], "source": '\n<script type="module" hoist>\n  import \'/src/components/ReplPad\';\n<\/script>\n\n<div class="tip">\n<ul>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Generators.html">Generators module</a></li>\n</ul>\n</div>\n\nGenerators are a [language feature of Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) that essentially allows a function to output multiple values, potentially asynchronously.\n\nixfx includes:\n* [count](#count): yields a series of integers counting up (or down) from zero\n* [numericRange](#numeric-range): yields a series of numbers with a defined interval, start and end. Can reset back to start and loop\n* [ping pong](#ping-pong): same as numeric range, but it counts back down to start before looping\n* [oscillators](../../modulation/oscillator/): ixfx\'s oscillators are implemented as generators\n\nUses:\n\n* [interval](../../flow/loops/#interval): an _asynchronous_ generator, `interval` calls and returns a result at a specified interval.\n\n\nImporting tips:\n\n```js\n// Import as a module, meaning you have to prefix functions with Generators.\nimport * as Generators from \'ixfx/lib/generators.js\';\n// Or, import as a module from the web directly\nimport * as Generators from "https://unpkg.com/ixfx/dist/generators.js"\n// Or, import a single function, eg interval\nimport { interval } from \'ixfx/lib/generators.js\';\n```\n\n## Background\n\nGenerators are a form of _iterator_, an object that allows you to traverse - that is, to step through - some other data. Objects are _iterable_ if they provide an iterator on request, that is, the give the possibility for stepping through their contents in some manner. The familiar [collections](../../data/collections/) - arrays, maps and so on - are all iterables.\n\n`for .. of` is the usual way of working with an iterator. In this case, we\'re iterating over an array (which is _iterable_):\n\n```js\nfor (const v of someArray) {\n\n}\n```\n\nIterators allow us to traverse over data in different order, or perhaps returning different views over the data. For example, `Object.keys()` and `Object.values()` both return an iterators over whatever object you provide as a parameter. One yields a series of _keys_, the other _values_.\n\n```js\nconst something = {\n  colour: `red`,\n  size: 10\n}\n\n// Iterate keys (ie fields) of an object\nfor (const key of Object.keys(something)) {\n  // `colour`, `size` ...  \n}\n\n// Different iterator yields a series of values,\n// even though input is the same\nfor (const value of Object.values(something)) {\n  // `red`, 10 ...\n}\n```\n\nIterators can be used in `for .. of` loops as above, but it\'s not always the case that you want to access every item at the same time. For example, maybe you want to fetch a new item from an iterable every minute. \n\nIn this case, you can work with the iterator manually. Iterators have a `next()` function which both moves the iterator to the next position, and returns `{done, value}`, where `done` is _true/false_ and `value` is the current value of iterator.\n\nHere we move the iterator and use the value:\n\n```js\nconst {value, done} = iter.next();\nif (done)  { /* handle when iterator is complete? */ }\nelse {\n  // Use value...\n}\n```\n\nThat kind of code could be called in a timer, fetching and using the value every _x_ seconds, for example. Below gives an example of setting `state.value` with a new item from the iterator every 60 seconds. When/if the iterator finishes, it stops the interval and sets the value to _undefined_.\n\n```js\nconst iterInterval = setInterval(() => {\n  // This code runs every 60secs...\n  const {value, done} = iter.next();\n  if (!done) {\n    // Update `state.value` to the next thing from the iterator\n    state = { ...state, value }\n  } else {\n    // Set `state.value` to undefined and stop interval\n    state = { ...state, value: undefined }\n    clearInterval(iterInterval);\n  }\n}, 60*1000); // 60 seconds \n```\n\nTip: ixfx\'s [interval](../../flow/loops/#interval) makes iterating with delay easy.\n\nIterables can be converted into an array:\n\n```js\nconst asArray = Array.from(iterable);\n\n// Or alternatively:\nconst asArray =[...iterable];\n```\n\nWhat\'s interesting about iterables is that they aren\'t an actual collection or set of things, but rather _generate_ values on-demand. This means it\'s possible to have an iterable that never ends.\n\n## Count\n\n[`count`](https://clinth.github.io/ixfx/functions/Generators.count.html) yields a series of integers, counting by one: `0 1 2 3 ... `\n\nAs the examples show, `count` can be a useful way of running a chunk of code _x_ number of times. It might be more readable and robust than a typical `do`/`while` or `for` loop because there\'s only one thing you need to express: the amount of times to loop.\n\n\n```js\n// repl-pad\nimport { count } from "https://unpkg.com/ixfx/dist/generators.js"\n\n// count(amount:number, offset:number = 0);\n// Yields the array: [ 0, 1, 2, 3, 4 ]\nconst a = [...count(5)];\n```\n\nOr the more common style for using generators is to loop over them:\n```js\n// repl-pad\nimport { count } from "https://unpkg.com/ixfx/dist/generators.js"\nfor (const i of count(5)) {\n  // Loop runs five times, with i being 0, 1, 2, 3 and then 4\n  console.log(i);\n}\n```\n\nA negative `amount` counts backwards from zero:\n\n```js\nimport {count} from "https://unpkg.com/ixfx/dist/generators.js"\nimport {forEach} from "https://unpkg.com/ixfx/dist/flow.js"\n\n// Prints Hi! 0, Hi! -1 ... Hi! -4\n[...count(-5)].forEach(i => {\n  console.log(`Hi! ${i}`);\n});\n```\n\nIf an offset is supplied, it is added to the result:\n\n```js\n// Yields [ 1, 2, 3, 4, 5 ]\nconst a = [...count(5,1)];\n```\n\nFor more complicated counting, consider [`numericRange`](#numeric-range), which allows you to set the counting interval, and whether counting resets.\n\n<a name="numericRange"></a>\n\n## Numeric range\n\n[`numericRange`](https://clinth.github.io/ixfx/functions/Generators.numericRange.html) yields a series of numbers from `start` to `end`, with a specified `interval`. Unlike [`count`](#count), it can increment by and return fractional values.\n\n```js\nimport {numericRange} from "https://unpkg.com/ixfx/dist/generators.js"\n\n// numericRange(interval, start, end, repeating)\n\n// Counts from 0-100, by 0.1\nfor (const v of numericRange(0.1, 0, 100)) { }\n\n// Counts in twos from 0-100, and repeats from 0 again after 100\nfor (const v of numericRange(2, 0, 100, true)) { \n  // Caution: this generator never ends by itself, so you need\n  // a `break` statement somewhere in the for loop\n}\n\n// Generators can be used manually as well...\nconst range = numericRange(1, 0, 100);\nrange.next().value;\n```\n\nIf you just want to simply count from 0 to some number, consider using `count` instead.\n\n[`Numbers.linearSpace`](https://clinth.github.io/ixfx/functions/Numbers.linearSpace.html) generates a set number of steps between a start and end number.\n\n```js\n// repl-pad\nimport { linearSpace } from "https://unpkg.com/ixfx/dist/numbers.js"\n// linearSpace(start, end, steps);\n// Break up 1..5 in six steps\nconst values = [...linearSpace(1, 5, 6)];\n// Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n```\n## Percentages \nTo constrain the range to the percentage scale (0-1), use `numericPercent`:\n\n```js\nimport {numericPercent} from "https://unpkg.com/ixfx/dist/generators.js"\n\n// numericPercent(interval, repeating, start, end)\n\n// Counts from 0 to 1 by 10%\nfor (const v of numericPercent(0.1)) { \n  // 0, 0.1, 0.2 ...\n}\n\n// Counts from 0 to 1 by 10%, looping from 0\nfor (const v of numericPercent(0.1, true)) { \n  // 0, 0.1, 0.2 ... 1.0, 0.0, 0.1, 0.2 ...  \n  // Warning: infinite generator, make sure you `break` at some point\n}\n\n// Constant rotation\nconst r = numericPercent(0.1); // Setup once\n// Per animation loop, calculate new rotation\nconst angle = Math.PI*2*r.next().value; \n```\n\n\n## Ping pong\n\n[`pingPong`](https://clinth.github.io/ixfx/functions/Generators.pingPong.html) is like a repeating `numericRange` but it counts up and back down again when looping, rather than resetting to the start.\n\n```js\nimport { pingPong } from "https://unpkg.com/ixfx/dist/generators.js"\n\n// pingPong(interval, start, end, offset)\n\n// Counts up and down to 100 in 10s\nfor (const v of pingPong(10, 0, 100)) {\n  // 0, 10, 20 ... 100, 90, 80 ...0, 10, 20 ...\n  // Warning: infinite generator, make sure you `break` at some point\n}\n```\n\n[`pingPongPercent`](https://clinth.github.io/ixfx/functions/Generators.pingPongPercent.html) is a variation of `pingPong`, but it locks everything to a scale of 0-1.\n\n```js\nimport { pingPongPercent } from "https://unpkg.com/ixfx/dist/generators.js"\n\nfor (const v of pingPongPercent(0.01)) {\n  // Up and down from 0->1 by 1%\n  // Warning: infinite generator, make sure you `break` at some point\n}\n\n// Loops between 20-80% by 10%\nconst pp = pingPongPercent(0.1, 0.2, 0.8);\nconst v = pp.next().value;\n```\n\n## Generator helper functions\n\nIn the [Sync](https://clinth.github.io/ixfx/modules/Generators.Sync.html) and [Async](https://clinth.github.io/ixfx/modules/Generators.Async.html) sub-modules, there are a bunch of functions for working with generators or iterables.\n\nFor example:\n```js\nimport { Async, Sync } from "https://unpkg.com/ixfx/dist/generators.js"\n\nfor await (const v of Async.chunk(iterable, 5)) {\n  // v is array of length 5, contains chunks of `iterable`\n}\n```\n\nHere is a brief overview of available functions in these modules:\n\n* chunks: grab chunks of an iterable\n* concat: return the combined results from one or more iterables\n* dropWhile: ignore values that do not meet a predicate (opposite of `filter`)\n* equals: returns _true_ if values in two iterables are the same\n* every: returns _true_ if every value in iterable matches a predicate\n* fill: returns a replacement value for every value of the iterable\n* filter: returns items that match the predicate (opposite of `dropWhile``\n* forEach: run a function for each value\n* fromArray: creates an async generator from an array source\n* fromIterable: creates an async generator from an iterable/generator\n* map: returns value passed through a transform function\n* max/min: returns largest/smallest value seen\n* range: returns range of value seen\n* reduce: reduce values of iterable into one\n* slice: returns a section of an iterable\n* some: returns _true_ and exits when a predicate function matches\n* takeWhile: returns items for which predicate returns true\n* toArray: copies contents of iterable to an array\n* unique: only yields items not yet seen\n* zip: combines the items from several iterables at same position\n\nOnly in Sync module\n* chunksOverlapping: like `chunks`, but start of a chunk is the same element as last of the previous chunk\n* find: returns the first value that matches a predicate. While `some` returns a boolean.\n* first/last: returns first/last value from an iterable\n* flatten: unnests values which are arrays\n* uniqueByValue: only yields unique values\n* yieldNumber: returns the numeric value from a generator', "html": '<script type="module" hoist>\n  import \'/src/components/ReplPad\';\n<\/script>\n<div class="tip">\n<ul>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Generators.html">Generators module</a></li>\n</ul>\n</div>\n<p>Generators are a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">language feature of Javascript</a> that essentially allows a function to output multiple values, potentially asynchronously.</p>\n<p>ixfx includes:</p>\n<ul>\n<li><a href="#count">count</a>: yields a series of integers counting up (or down) from zero</li>\n<li><a href="#numeric-range">numericRange</a>: yields a series of numbers with a defined interval, start and end. Can reset back to start and loop</li>\n<li><a href="#ping-pong">ping pong</a>: same as numeric range, but it counts back down to start before looping</li>\n<li><a href="../../modulation/oscillator/">oscillators</a>: ixfx\'s oscillators are implemented as generators</li>\n</ul>\n<p>Uses:</p>\n<ul>\n<li><a href="../../flow/loops/#interval">interval</a>: an <em>asynchronous</em> generator, <code is:raw>interval</code> calls and returns a result at a specified interval.</li>\n</ul>\n<p>Importing tips:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Import as a module, meaning you have to prefix functions with Generators.</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">\'ixfx/lib/generators.js\'</span><span class="token punctuation">;</span>\n<span class="token comment">// Or, import as a module from the web directly</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token comment">// Or, import a single function, eg interval</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> interval <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'ixfx/lib/generators.js\'</span><span class="token punctuation">;</span></code></pre>\n<h2 id="background">Background</h2>\n<p>Generators are a form of <em>iterator</em>, an object that allows you to traverse - that is, to step through - some other data. Objects are <em>iterable</em> if they provide an iterator on request, that is, the give the possibility for stepping through their contents in some manner. The familiar <a href="../../data/collections/">collections</a> - arrays, maps and so on - are all iterables.</p>\n<p><code is:raw>for .. of</code> is the usual way of working with an iterator. In this case, we\'re iterating over an array (which is <em>iterable</em>):</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> someArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span></code></pre>\n<p>Iterators allow us to traverse over data in different order, or perhaps returning different views over the data. For example, <code is:raw>Object.keys()</code> and <code is:raw>Object.values()</code> both return an iterators over whatever object you provide as a parameter. One yields a series of <em>keys</em>, the other <em>values</em>.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> something <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">colour</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">red</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Iterate keys (ie fields) of an object</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// `colour`, `size` ...  </span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Different iterator yields a series of values,</span>\n<span class="token comment">// even though input is the same</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// `red`, 10 ...</span>\n<span class="token punctuation">}</span></code></pre>\n<p>Iterators can be used in <code is:raw>for .. of</code> loops as above, but it\'s not always the case that you want to access every item at the same time. For example, maybe you want to fetch a new item from an iterable every minute.</p>\n<p>In this case, you can work with the iterator manually. Iterators have a <code is:raw>next()</code> function which both moves the iterator to the next position, and returns <code is:raw>{done, value}</code>, where <code is:raw>done</code> is <em>true/false</em> and <code is:raw>value</code> is the current value of iterator.</p>\n<p>Here we move the iterator and use the value:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment">/* handle when iterator is complete? */</span> <span class="token punctuation">}</span>\n<span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Use value...</span>\n<span class="token punctuation">}</span></code></pre>\n<p>That kind of code could be called in a timer, fetching and using the value every <em>x</em> seconds, for example. Below gives an example of setting <code is:raw>state.value</code> with a new item from the iterator every 60 seconds. When/if the iterator finishes, it stops the interval and sets the value to <em>undefined</em>.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> iterInterval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// This code runs every 60secs...</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Update `state.value` to the next thing from the iterator</span>\n    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> value <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Set `state.value` to undefined and stop interval</span>\n    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">}</span>\n    <span class="token function">clearInterval</span><span class="token punctuation">(</span>iterInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 60 seconds </span></code></pre>\n<p>Tip: ixfx\'s <a href="../../flow/loops/#interval">interval</a> makes iterating with delay easy.</p>\n<p>Iterables can be converted into an array:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> asArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Or alternatively:</span>\n<span class="token keyword">const</span> asArray <span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span>iterable<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>What\'s interesting about iterables is that they aren\'t an actual collection or set of things, but rather <em>generate</em> values on-demand. This means it\'s possible to have an iterable that never ends.</p>\n<h2 id="count">Count</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.count.html"><code is:raw>count</code></a> yields a series of integers, counting by one: <code is:raw>0 1 2 3 ... </code></p>\n<p>As the examples show, <code is:raw>count</code> can be a useful way of running a chunk of code <em>x</em> number of times. It might be more readable and robust than a typical <code is:raw>do</code>/<code is:raw>while</code> or <code is:raw>for</code> loop because there\'s only one thing you need to express: the amount of times to loop.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// count(amount:number, offset:number = 0);</span>\n<span class="token comment">// Yields the array: [ 0, 1, 2, 3, 4 ]</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>Or the more common style for using generators is to loop over them:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> i <span class="token keyword">of</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Loop runs five times, with i being 0, 1, 2, 3 and then 4</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n<p>A negative <code is:raw>amount</code> counts backwards from zero:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span>forEach<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/flow.js"</span>\n\n<span class="token comment">// Prints Hi! 0, Hi! -1 ... Hi! -4</span>\n<span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>If an offset is supplied, it is added to the result:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Yields [ 1, 2, 3, 4, 5 ]</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>For more complicated counting, consider <a href="#numeric-range"><code is:raw>numericRange</code></a>, which allows you to set the counting interval, and whether counting resets.</p>\n<a name="numericRange">\n</a>\n<h2 id="numeric-range">Numeric range</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.numericRange.html"><code is:raw>numericRange</code></a> yields a series of numbers from <code is:raw>start</code> to <code is:raw>end</code>, with a specified <code is:raw>interval</code>. Unlike <a href="#count"><code is:raw>count</code></a>, it can increment by and return fractional values.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericRange<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// numericRange(interval, start, end, repeating)</span>\n\n<span class="token comment">// Counts from 0-100, by 0.1</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// Counts in twos from 0-100, and repeats from 0 again after 100</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// Caution: this generator never ends by itself, so you need</span>\n  <span class="token comment">// a `break` statement somewhere in the for loop</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Generators can be used manually as well...</span>\n<span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nrange<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre>\n<p>If you just want to simply count from 0 to some number, consider using <code is:raw>count</code> instead.</p>\n<p><a href="https://clinth.github.io/ixfx/functions/Numbers.linearSpace.html"><code is:raw>Numbers.linearSpace</code></a> generates a set number of steps between a start and end number.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> linearSpace <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/numbers.js"</span>\n<span class="token comment">// linearSpace(start, end, steps);</span>\n<span class="token comment">// Break up 1..5 in six steps</span>\n<span class="token keyword">const</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">linearSpace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]</span></code></pre>\n<h2 id="percentages">Percentages</h2>\n<p>To constrain the range to the percentage scale (0-1), use <code is:raw>numericPercent</code>:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericPercent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// numericPercent(interval, repeating, start, end)</span>\n\n<span class="token comment">// Counts from 0 to 1 by 10%</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 0, 0.1, 0.2 ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Counts from 0 to 1 by 10%, looping from 0</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 0, 0.1, 0.2 ... 1.0, 0.0, 0.1, 0.2 ...  </span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Constant rotation</span>\n<span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Setup once</span>\n<span class="token comment">// Per animation loop, calculate new rotation</span>\n<span class="token keyword">const</span> angle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span> </code></pre>\n<h2 id="ping-pong">Ping pong</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPong.html"><code is:raw>pingPong</code></a> is like a repeating <code is:raw>numericRange</code> but it counts up and back down again when looping, rather than resetting to the start.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPong <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// pingPong(interval, start, end, offset)</span>\n\n<span class="token comment">// Counts up and down to 100 in 10s</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPong</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 0, 10, 20 ... 100, 90, 80 ...0, 10, 20 ...</span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span></code></pre>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPongPercent.html"><code is:raw>pingPongPercent</code></a> is a variation of <code is:raw>pingPong</code>, but it locks everything to a scale of 0-1.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPongPercent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Up and down from 0->1 by 1%</span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Loops between 20-80% by 10%</span>\n<span class="token keyword">const</span> pp <span class="token operator">=</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> v <span class="token operator">=</span> pp<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre>\n<h2 id="generator-helper-functions">Generator helper functions</h2>\n<p>In the <a href="https://clinth.github.io/ixfx/modules/Generators.Sync.html">Sync</a> and <a href="https://clinth.github.io/ixfx/modules/Generators.Async.html">Async</a> sub-modules, there are a bunch of functions for working with generators or iterables.</p>\n<p>For example:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Async<span class="token punctuation">,</span> Sync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> Async<span class="token punctuation">.</span><span class="token function">chunk</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// v is array of length 5, contains chunks of `iterable`</span>\n<span class="token punctuation">}</span></code></pre>\n<p>Here is a brief overview of available functions in these modules:</p>\n<ul>\n<li>chunks: grab chunks of an iterable</li>\n<li>concat: return the combined results from one or more iterables</li>\n<li>dropWhile: ignore values that do not meet a predicate (opposite of <code is:raw>filter</code>)</li>\n<li>equals: returns <em>true</em> if values in two iterables are the same</li>\n<li>every: returns <em>true</em> if every value in iterable matches a predicate</li>\n<li>fill: returns a replacement value for every value of the iterable</li>\n<li>filter: returns items that match the predicate (opposite of `dropWhile``</li>\n<li>forEach: run a function for each value</li>\n<li>fromArray: creates an async generator from an array source</li>\n<li>fromIterable: creates an async generator from an iterable/generator</li>\n<li>map: returns value passed through a transform function</li>\n<li>max/min: returns largest/smallest value seen</li>\n<li>range: returns range of value seen</li>\n<li>reduce: reduce values of iterable into one</li>\n<li>slice: returns a section of an iterable</li>\n<li>some: returns <em>true</em> and exits when a predicate function matches</li>\n<li>takeWhile: returns items for which predicate returns true</li>\n<li>toArray: copies contents of iterable to an array</li>\n<li>unique: only yields items not yet seen</li>\n<li>zip: combines the items from several iterables at same position</li>\n</ul>\n<p>Only in Sync module</p>\n<ul>\n<li>chunksOverlapping: like <code is:raw>chunks</code>, but start of a chunk is the same element as last of the previous chunk</li>\n<li>find: returns the first value that matches a predicate. While <code is:raw>some</code> returns a boolean.</li>\n<li>first/last: returns first/last value from an iterable</li>\n<li>flatten: unnests values which are arrays</li>\n<li>uniqueByValue: only yields unique values</li>\n<li>yieldNumber: returns the numeric value from a generator</li>\n</ul>' };
const frontmatter = { "title": "Generators", "astro": { "headers": [{ "depth": 2, "slug": "background", "text": "Background" }, { "depth": 2, "slug": "count", "text": "Count" }, { "depth": 2, "slug": "numeric-range", "text": "Numeric range" }, { "depth": 2, "slug": "percentages", "text": "Percentages" }, { "depth": 2, "slug": "ping-pong", "text": "Ping pong" }, { "depth": 2, "slug": "generator-helper-functions", "text": "Generator helper functions" }], "source": '\n<script type="module" hoist>\n  import \'/src/components/ReplPad\';\n<\/script>\n\n<div class="tip">\n<ul>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Generators.html">Generators module</a></li>\n</ul>\n</div>\n\nGenerators are a [language feature of Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) that essentially allows a function to output multiple values, potentially asynchronously.\n\nixfx includes:\n* [count](#count): yields a series of integers counting up (or down) from zero\n* [numericRange](#numeric-range): yields a series of numbers with a defined interval, start and end. Can reset back to start and loop\n* [ping pong](#ping-pong): same as numeric range, but it counts back down to start before looping\n* [oscillators](../../modulation/oscillator/): ixfx\'s oscillators are implemented as generators\n\nUses:\n\n* [interval](../../flow/loops/#interval): an _asynchronous_ generator, `interval` calls and returns a result at a specified interval.\n\n\nImporting tips:\n\n```js\n// Import as a module, meaning you have to prefix functions with Generators.\nimport * as Generators from \'ixfx/lib/generators.js\';\n// Or, import as a module from the web directly\nimport * as Generators from "https://unpkg.com/ixfx/dist/generators.js"\n// Or, import a single function, eg interval\nimport { interval } from \'ixfx/lib/generators.js\';\n```\n\n## Background\n\nGenerators are a form of _iterator_, an object that allows you to traverse - that is, to step through - some other data. Objects are _iterable_ if they provide an iterator on request, that is, the give the possibility for stepping through their contents in some manner. The familiar [collections](../../data/collections/) - arrays, maps and so on - are all iterables.\n\n`for .. of` is the usual way of working with an iterator. In this case, we\'re iterating over an array (which is _iterable_):\n\n```js\nfor (const v of someArray) {\n\n}\n```\n\nIterators allow us to traverse over data in different order, or perhaps returning different views over the data. For example, `Object.keys()` and `Object.values()` both return an iterators over whatever object you provide as a parameter. One yields a series of _keys_, the other _values_.\n\n```js\nconst something = {\n  colour: `red`,\n  size: 10\n}\n\n// Iterate keys (ie fields) of an object\nfor (const key of Object.keys(something)) {\n  // `colour`, `size` ...  \n}\n\n// Different iterator yields a series of values,\n// even though input is the same\nfor (const value of Object.values(something)) {\n  // `red`, 10 ...\n}\n```\n\nIterators can be used in `for .. of` loops as above, but it\'s not always the case that you want to access every item at the same time. For example, maybe you want to fetch a new item from an iterable every minute. \n\nIn this case, you can work with the iterator manually. Iterators have a `next()` function which both moves the iterator to the next position, and returns `{done, value}`, where `done` is _true/false_ and `value` is the current value of iterator.\n\nHere we move the iterator and use the value:\n\n```js\nconst {value, done} = iter.next();\nif (done)  { /* handle when iterator is complete? */ }\nelse {\n  // Use value...\n}\n```\n\nThat kind of code could be called in a timer, fetching and using the value every _x_ seconds, for example. Below gives an example of setting `state.value` with a new item from the iterator every 60 seconds. When/if the iterator finishes, it stops the interval and sets the value to _undefined_.\n\n```js\nconst iterInterval = setInterval(() => {\n  // This code runs every 60secs...\n  const {value, done} = iter.next();\n  if (!done) {\n    // Update `state.value` to the next thing from the iterator\n    state = { ...state, value }\n  } else {\n    // Set `state.value` to undefined and stop interval\n    state = { ...state, value: undefined }\n    clearInterval(iterInterval);\n  }\n}, 60*1000); // 60 seconds \n```\n\nTip: ixfx\'s [interval](../../flow/loops/#interval) makes iterating with delay easy.\n\nIterables can be converted into an array:\n\n```js\nconst asArray = Array.from(iterable);\n\n// Or alternatively:\nconst asArray =[...iterable];\n```\n\nWhat\'s interesting about iterables is that they aren\'t an actual collection or set of things, but rather _generate_ values on-demand. This means it\'s possible to have an iterable that never ends.\n\n## Count\n\n[`count`](https://clinth.github.io/ixfx/functions/Generators.count.html) yields a series of integers, counting by one: `0 1 2 3 ... `\n\nAs the examples show, `count` can be a useful way of running a chunk of code _x_ number of times. It might be more readable and robust than a typical `do`/`while` or `for` loop because there\'s only one thing you need to express: the amount of times to loop.\n\n\n```js\n// repl-pad\nimport { count } from "https://unpkg.com/ixfx/dist/generators.js"\n\n// count(amount:number, offset:number = 0);\n// Yields the array: [ 0, 1, 2, 3, 4 ]\nconst a = [...count(5)];\n```\n\nOr the more common style for using generators is to loop over them:\n```js\n// repl-pad\nimport { count } from "https://unpkg.com/ixfx/dist/generators.js"\nfor (const i of count(5)) {\n  // Loop runs five times, with i being 0, 1, 2, 3 and then 4\n  console.log(i);\n}\n```\n\nA negative `amount` counts backwards from zero:\n\n```js\nimport {count} from "https://unpkg.com/ixfx/dist/generators.js"\nimport {forEach} from "https://unpkg.com/ixfx/dist/flow.js"\n\n// Prints Hi! 0, Hi! -1 ... Hi! -4\n[...count(-5)].forEach(i => {\n  console.log(`Hi! ${i}`);\n});\n```\n\nIf an offset is supplied, it is added to the result:\n\n```js\n// Yields [ 1, 2, 3, 4, 5 ]\nconst a = [...count(5,1)];\n```\n\nFor more complicated counting, consider [`numericRange`](#numeric-range), which allows you to set the counting interval, and whether counting resets.\n\n<a name="numericRange"></a>\n\n## Numeric range\n\n[`numericRange`](https://clinth.github.io/ixfx/functions/Generators.numericRange.html) yields a series of numbers from `start` to `end`, with a specified `interval`. Unlike [`count`](#count), it can increment by and return fractional values.\n\n```js\nimport {numericRange} from "https://unpkg.com/ixfx/dist/generators.js"\n\n// numericRange(interval, start, end, repeating)\n\n// Counts from 0-100, by 0.1\nfor (const v of numericRange(0.1, 0, 100)) { }\n\n// Counts in twos from 0-100, and repeats from 0 again after 100\nfor (const v of numericRange(2, 0, 100, true)) { \n  // Caution: this generator never ends by itself, so you need\n  // a `break` statement somewhere in the for loop\n}\n\n// Generators can be used manually as well...\nconst range = numericRange(1, 0, 100);\nrange.next().value;\n```\n\nIf you just want to simply count from 0 to some number, consider using `count` instead.\n\n[`Numbers.linearSpace`](https://clinth.github.io/ixfx/functions/Numbers.linearSpace.html) generates a set number of steps between a start and end number.\n\n```js\n// repl-pad\nimport { linearSpace } from "https://unpkg.com/ixfx/dist/numbers.js"\n// linearSpace(start, end, steps);\n// Break up 1..5 in six steps\nconst values = [...linearSpace(1, 5, 6)];\n// Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n```\n## Percentages \nTo constrain the range to the percentage scale (0-1), use `numericPercent`:\n\n```js\nimport {numericPercent} from "https://unpkg.com/ixfx/dist/generators.js"\n\n// numericPercent(interval, repeating, start, end)\n\n// Counts from 0 to 1 by 10%\nfor (const v of numericPercent(0.1)) { \n  // 0, 0.1, 0.2 ...\n}\n\n// Counts from 0 to 1 by 10%, looping from 0\nfor (const v of numericPercent(0.1, true)) { \n  // 0, 0.1, 0.2 ... 1.0, 0.0, 0.1, 0.2 ...  \n  // Warning: infinite generator, make sure you `break` at some point\n}\n\n// Constant rotation\nconst r = numericPercent(0.1); // Setup once\n// Per animation loop, calculate new rotation\nconst angle = Math.PI*2*r.next().value; \n```\n\n\n## Ping pong\n\n[`pingPong`](https://clinth.github.io/ixfx/functions/Generators.pingPong.html) is like a repeating `numericRange` but it counts up and back down again when looping, rather than resetting to the start.\n\n```js\nimport { pingPong } from "https://unpkg.com/ixfx/dist/generators.js"\n\n// pingPong(interval, start, end, offset)\n\n// Counts up and down to 100 in 10s\nfor (const v of pingPong(10, 0, 100)) {\n  // 0, 10, 20 ... 100, 90, 80 ...0, 10, 20 ...\n  // Warning: infinite generator, make sure you `break` at some point\n}\n```\n\n[`pingPongPercent`](https://clinth.github.io/ixfx/functions/Generators.pingPongPercent.html) is a variation of `pingPong`, but it locks everything to a scale of 0-1.\n\n```js\nimport { pingPongPercent } from "https://unpkg.com/ixfx/dist/generators.js"\n\nfor (const v of pingPongPercent(0.01)) {\n  // Up and down from 0->1 by 1%\n  // Warning: infinite generator, make sure you `break` at some point\n}\n\n// Loops between 20-80% by 10%\nconst pp = pingPongPercent(0.1, 0.2, 0.8);\nconst v = pp.next().value;\n```\n\n## Generator helper functions\n\nIn the [Sync](https://clinth.github.io/ixfx/modules/Generators.Sync.html) and [Async](https://clinth.github.io/ixfx/modules/Generators.Async.html) sub-modules, there are a bunch of functions for working with generators or iterables.\n\nFor example:\n```js\nimport { Async, Sync } from "https://unpkg.com/ixfx/dist/generators.js"\n\nfor await (const v of Async.chunk(iterable, 5)) {\n  // v is array of length 5, contains chunks of `iterable`\n}\n```\n\nHere is a brief overview of available functions in these modules:\n\n* chunks: grab chunks of an iterable\n* concat: return the combined results from one or more iterables\n* dropWhile: ignore values that do not meet a predicate (opposite of `filter`)\n* equals: returns _true_ if values in two iterables are the same\n* every: returns _true_ if every value in iterable matches a predicate\n* fill: returns a replacement value for every value of the iterable\n* filter: returns items that match the predicate (opposite of `dropWhile``\n* forEach: run a function for each value\n* fromArray: creates an async generator from an array source\n* fromIterable: creates an async generator from an iterable/generator\n* map: returns value passed through a transform function\n* max/min: returns largest/smallest value seen\n* range: returns range of value seen\n* reduce: reduce values of iterable into one\n* slice: returns a section of an iterable\n* some: returns _true_ and exits when a predicate function matches\n* takeWhile: returns items for which predicate returns true\n* toArray: copies contents of iterable to an array\n* unique: only yields items not yet seen\n* zip: combines the items from several iterables at same position\n\nOnly in Sync module\n* chunksOverlapping: like `chunks`, but start of a chunk is the same element as last of the previous chunk\n* find: returns the first value that matches a predicate. While `some` returns a boolean.\n* first/last: returns first/last value from an iterable\n* flatten: unnests values which are arrays\n* uniqueByValue: only yields unique values\n* yieldNumber: returns the numeric value from a generator', "html": '<script type="module" hoist>\n  import \'/src/components/ReplPad\';\n<\/script>\n<div class="tip">\n<ul>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Generators.html">Generators module</a></li>\n</ul>\n</div>\n<p>Generators are a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">language feature of Javascript</a> that essentially allows a function to output multiple values, potentially asynchronously.</p>\n<p>ixfx includes:</p>\n<ul>\n<li><a href="#count">count</a>: yields a series of integers counting up (or down) from zero</li>\n<li><a href="#numeric-range">numericRange</a>: yields a series of numbers with a defined interval, start and end. Can reset back to start and loop</li>\n<li><a href="#ping-pong">ping pong</a>: same as numeric range, but it counts back down to start before looping</li>\n<li><a href="../../modulation/oscillator/">oscillators</a>: ixfx\'s oscillators are implemented as generators</li>\n</ul>\n<p>Uses:</p>\n<ul>\n<li><a href="../../flow/loops/#interval">interval</a>: an <em>asynchronous</em> generator, <code is:raw>interval</code> calls and returns a result at a specified interval.</li>\n</ul>\n<p>Importing tips:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Import as a module, meaning you have to prefix functions with Generators.</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">\'ixfx/lib/generators.js\'</span><span class="token punctuation">;</span>\n<span class="token comment">// Or, import as a module from the web directly</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token comment">// Or, import a single function, eg interval</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> interval <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'ixfx/lib/generators.js\'</span><span class="token punctuation">;</span></code></pre>\n<h2 id="background">Background</h2>\n<p>Generators are a form of <em>iterator</em>, an object that allows you to traverse - that is, to step through - some other data. Objects are <em>iterable</em> if they provide an iterator on request, that is, the give the possibility for stepping through their contents in some manner. The familiar <a href="../../data/collections/">collections</a> - arrays, maps and so on - are all iterables.</p>\n<p><code is:raw>for .. of</code> is the usual way of working with an iterator. In this case, we\'re iterating over an array (which is <em>iterable</em>):</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> someArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span></code></pre>\n<p>Iterators allow us to traverse over data in different order, or perhaps returning different views over the data. For example, <code is:raw>Object.keys()</code> and <code is:raw>Object.values()</code> both return an iterators over whatever object you provide as a parameter. One yields a series of <em>keys</em>, the other <em>values</em>.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> something <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">colour</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">red</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Iterate keys (ie fields) of an object</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// `colour`, `size` ...  </span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Different iterator yields a series of values,</span>\n<span class="token comment">// even though input is the same</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// `red`, 10 ...</span>\n<span class="token punctuation">}</span></code></pre>\n<p>Iterators can be used in <code is:raw>for .. of</code> loops as above, but it\'s not always the case that you want to access every item at the same time. For example, maybe you want to fetch a new item from an iterable every minute.</p>\n<p>In this case, you can work with the iterator manually. Iterators have a <code is:raw>next()</code> function which both moves the iterator to the next position, and returns <code is:raw>{done, value}</code>, where <code is:raw>done</code> is <em>true/false</em> and <code is:raw>value</code> is the current value of iterator.</p>\n<p>Here we move the iterator and use the value:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment">/* handle when iterator is complete? */</span> <span class="token punctuation">}</span>\n<span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Use value...</span>\n<span class="token punctuation">}</span></code></pre>\n<p>That kind of code could be called in a timer, fetching and using the value every <em>x</em> seconds, for example. Below gives an example of setting <code is:raw>state.value</code> with a new item from the iterator every 60 seconds. When/if the iterator finishes, it stops the interval and sets the value to <em>undefined</em>.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> iterInterval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// This code runs every 60secs...</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Update `state.value` to the next thing from the iterator</span>\n    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> value <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Set `state.value` to undefined and stop interval</span>\n    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">}</span>\n    <span class="token function">clearInterval</span><span class="token punctuation">(</span>iterInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 60 seconds </span></code></pre>\n<p>Tip: ixfx\'s <a href="../../flow/loops/#interval">interval</a> makes iterating with delay easy.</p>\n<p>Iterables can be converted into an array:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> asArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Or alternatively:</span>\n<span class="token keyword">const</span> asArray <span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span>iterable<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>What\'s interesting about iterables is that they aren\'t an actual collection or set of things, but rather <em>generate</em> values on-demand. This means it\'s possible to have an iterable that never ends.</p>\n<h2 id="count">Count</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.count.html"><code is:raw>count</code></a> yields a series of integers, counting by one: <code is:raw>0 1 2 3 ... </code></p>\n<p>As the examples show, <code is:raw>count</code> can be a useful way of running a chunk of code <em>x</em> number of times. It might be more readable and robust than a typical <code is:raw>do</code>/<code is:raw>while</code> or <code is:raw>for</code> loop because there\'s only one thing you need to express: the amount of times to loop.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// count(amount:number, offset:number = 0);</span>\n<span class="token comment">// Yields the array: [ 0, 1, 2, 3, 4 ]</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>Or the more common style for using generators is to loop over them:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> i <span class="token keyword">of</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Loop runs five times, with i being 0, 1, 2, 3 and then 4</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n<p>A negative <code is:raw>amount</code> counts backwards from zero:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span>forEach<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/flow.js"</span>\n\n<span class="token comment">// Prints Hi! 0, Hi! -1 ... Hi! -4</span>\n<span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>If an offset is supplied, it is added to the result:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Yields [ 1, 2, 3, 4, 5 ]</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>For more complicated counting, consider <a href="#numeric-range"><code is:raw>numericRange</code></a>, which allows you to set the counting interval, and whether counting resets.</p>\n<a name="numericRange">\n</a>\n<h2 id="numeric-range">Numeric range</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.numericRange.html"><code is:raw>numericRange</code></a> yields a series of numbers from <code is:raw>start</code> to <code is:raw>end</code>, with a specified <code is:raw>interval</code>. Unlike <a href="#count"><code is:raw>count</code></a>, it can increment by and return fractional values.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericRange<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// numericRange(interval, start, end, repeating)</span>\n\n<span class="token comment">// Counts from 0-100, by 0.1</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// Counts in twos from 0-100, and repeats from 0 again after 100</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// Caution: this generator never ends by itself, so you need</span>\n  <span class="token comment">// a `break` statement somewhere in the for loop</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Generators can be used manually as well...</span>\n<span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nrange<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre>\n<p>If you just want to simply count from 0 to some number, consider using <code is:raw>count</code> instead.</p>\n<p><a href="https://clinth.github.io/ixfx/functions/Numbers.linearSpace.html"><code is:raw>Numbers.linearSpace</code></a> generates a set number of steps between a start and end number.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> linearSpace <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/numbers.js"</span>\n<span class="token comment">// linearSpace(start, end, steps);</span>\n<span class="token comment">// Break up 1..5 in six steps</span>\n<span class="token keyword">const</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">linearSpace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]</span></code></pre>\n<h2 id="percentages">Percentages</h2>\n<p>To constrain the range to the percentage scale (0-1), use <code is:raw>numericPercent</code>:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericPercent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// numericPercent(interval, repeating, start, end)</span>\n\n<span class="token comment">// Counts from 0 to 1 by 10%</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 0, 0.1, 0.2 ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Counts from 0 to 1 by 10%, looping from 0</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 0, 0.1, 0.2 ... 1.0, 0.0, 0.1, 0.2 ...  </span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Constant rotation</span>\n<span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Setup once</span>\n<span class="token comment">// Per animation loop, calculate new rotation</span>\n<span class="token keyword">const</span> angle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span> </code></pre>\n<h2 id="ping-pong">Ping pong</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPong.html"><code is:raw>pingPong</code></a> is like a repeating <code is:raw>numericRange</code> but it counts up and back down again when looping, rather than resetting to the start.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPong <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// pingPong(interval, start, end, offset)</span>\n\n<span class="token comment">// Counts up and down to 100 in 10s</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPong</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 0, 10, 20 ... 100, 90, 80 ...0, 10, 20 ...</span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span></code></pre>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPongPercent.html"><code is:raw>pingPongPercent</code></a> is a variation of <code is:raw>pingPong</code>, but it locks everything to a scale of 0-1.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPongPercent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Up and down from 0->1 by 1%</span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Loops between 20-80% by 10%</span>\n<span class="token keyword">const</span> pp <span class="token operator">=</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> v <span class="token operator">=</span> pp<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre>\n<h2 id="generator-helper-functions">Generator helper functions</h2>\n<p>In the <a href="https://clinth.github.io/ixfx/modules/Generators.Sync.html">Sync</a> and <a href="https://clinth.github.io/ixfx/modules/Generators.Async.html">Async</a> sub-modules, there are a bunch of functions for working with generators or iterables.</p>\n<p>For example:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Async<span class="token punctuation">,</span> Sync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> Async<span class="token punctuation">.</span><span class="token function">chunk</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// v is array of length 5, contains chunks of `iterable`</span>\n<span class="token punctuation">}</span></code></pre>\n<p>Here is a brief overview of available functions in these modules:</p>\n<ul>\n<li>chunks: grab chunks of an iterable</li>\n<li>concat: return the combined results from one or more iterables</li>\n<li>dropWhile: ignore values that do not meet a predicate (opposite of <code is:raw>filter</code>)</li>\n<li>equals: returns <em>true</em> if values in two iterables are the same</li>\n<li>every: returns <em>true</em> if every value in iterable matches a predicate</li>\n<li>fill: returns a replacement value for every value of the iterable</li>\n<li>filter: returns items that match the predicate (opposite of `dropWhile``</li>\n<li>forEach: run a function for each value</li>\n<li>fromArray: creates an async generator from an array source</li>\n<li>fromIterable: creates an async generator from an iterable/generator</li>\n<li>map: returns value passed through a transform function</li>\n<li>max/min: returns largest/smallest value seen</li>\n<li>range: returns range of value seen</li>\n<li>reduce: reduce values of iterable into one</li>\n<li>slice: returns a section of an iterable</li>\n<li>some: returns <em>true</em> and exits when a predicate function matches</li>\n<li>takeWhile: returns items for which predicate returns true</li>\n<li>toArray: copies contents of iterable to an array</li>\n<li>unique: only yields items not yet seen</li>\n<li>zip: combines the items from several iterables at same position</li>\n</ul>\n<p>Only in Sync module</p>\n<ul>\n<li>chunksOverlapping: like <code is:raw>chunks</code>, but start of a chunk is the same element as last of the previous chunk</li>\n<li>find: returns the first value that matches a predicate. While <code is:raw>some</code> returns a boolean.</li>\n<li>first/last: returns first/last value from an iterable</li>\n<li>flatten: unnests values which are arrays</li>\n<li>uniqueByValue: only yields unique values</li>\n<li>yieldNumber: returns the numeric value from a generator</li>\n</ul>' } };
const $$metadata = createMetadata("/src/pages/gen/generator.md", { modules: [{ module: $$module1, specifier: "../../layouts/MainLayout.astro", assert: {} }], hydratedComponents: [], clientOnlyComponents: [], hydrationDirectives: /* @__PURE__ */ new Set([]), hoisted: [{ type: "inline", value: `
  import '/src/components/ReplPad';
` }] });
const $$Astro = createAstro("/src/pages/gen/generator.md", "https://clinth.github.io/ixfx-docs/", "file:///Users/af4766/repos/ixfx-docs/");
const $$Generator = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Generator;
  const $$content = { "title": "Generators", "astro": { "headers": [{ "depth": 2, "slug": "background", "text": "Background" }, { "depth": 2, "slug": "count", "text": "Count" }, { "depth": 2, "slug": "numeric-range", "text": "Numeric range" }, { "depth": 2, "slug": "percentages", "text": "Percentages" }, { "depth": 2, "slug": "ping-pong", "text": "Ping pong" }, { "depth": 2, "slug": "generator-helper-functions", "text": "Generator helper functions" }], "source": '\n<script type="module" hoist>\n  import \'/src/components/ReplPad\';\n<\/script>\n\n<div class="tip">\n<ul>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Generators.html">Generators module</a></li>\n</ul>\n</div>\n\nGenerators are a [language feature of Javascript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators) that essentially allows a function to output multiple values, potentially asynchronously.\n\nixfx includes:\n* [count](#count): yields a series of integers counting up (or down) from zero\n* [numericRange](#numeric-range): yields a series of numbers with a defined interval, start and end. Can reset back to start and loop\n* [ping pong](#ping-pong): same as numeric range, but it counts back down to start before looping\n* [oscillators](../../modulation/oscillator/): ixfx\'s oscillators are implemented as generators\n\nUses:\n\n* [interval](../../flow/loops/#interval): an _asynchronous_ generator, `interval` calls and returns a result at a specified interval.\n\n\nImporting tips:\n\n```js\n// Import as a module, meaning you have to prefix functions with Generators.\nimport * as Generators from \'ixfx/lib/generators.js\';\n// Or, import as a module from the web directly\nimport * as Generators from "https://unpkg.com/ixfx/dist/generators.js"\n// Or, import a single function, eg interval\nimport { interval } from \'ixfx/lib/generators.js\';\n```\n\n## Background\n\nGenerators are a form of _iterator_, an object that allows you to traverse - that is, to step through - some other data. Objects are _iterable_ if they provide an iterator on request, that is, the give the possibility for stepping through their contents in some manner. The familiar [collections](../../data/collections/) - arrays, maps and so on - are all iterables.\n\n`for .. of` is the usual way of working with an iterator. In this case, we\'re iterating over an array (which is _iterable_):\n\n```js\nfor (const v of someArray) {\n\n}\n```\n\nIterators allow us to traverse over data in different order, or perhaps returning different views over the data. For example, `Object.keys()` and `Object.values()` both return an iterators over whatever object you provide as a parameter. One yields a series of _keys_, the other _values_.\n\n```js\nconst something = {\n  colour: `red`,\n  size: 10\n}\n\n// Iterate keys (ie fields) of an object\nfor (const key of Object.keys(something)) {\n  // `colour`, `size` ...  \n}\n\n// Different iterator yields a series of values,\n// even though input is the same\nfor (const value of Object.values(something)) {\n  // `red`, 10 ...\n}\n```\n\nIterators can be used in `for .. of` loops as above, but it\'s not always the case that you want to access every item at the same time. For example, maybe you want to fetch a new item from an iterable every minute. \n\nIn this case, you can work with the iterator manually. Iterators have a `next()` function which both moves the iterator to the next position, and returns `{done, value}`, where `done` is _true/false_ and `value` is the current value of iterator.\n\nHere we move the iterator and use the value:\n\n```js\nconst {value, done} = iter.next();\nif (done)  { /* handle when iterator is complete? */ }\nelse {\n  // Use value...\n}\n```\n\nThat kind of code could be called in a timer, fetching and using the value every _x_ seconds, for example. Below gives an example of setting `state.value` with a new item from the iterator every 60 seconds. When/if the iterator finishes, it stops the interval and sets the value to _undefined_.\n\n```js\nconst iterInterval = setInterval(() => {\n  // This code runs every 60secs...\n  const {value, done} = iter.next();\n  if (!done) {\n    // Update `state.value` to the next thing from the iterator\n    state = { ...state, value }\n  } else {\n    // Set `state.value` to undefined and stop interval\n    state = { ...state, value: undefined }\n    clearInterval(iterInterval);\n  }\n}, 60*1000); // 60 seconds \n```\n\nTip: ixfx\'s [interval](../../flow/loops/#interval) makes iterating with delay easy.\n\nIterables can be converted into an array:\n\n```js\nconst asArray = Array.from(iterable);\n\n// Or alternatively:\nconst asArray =[...iterable];\n```\n\nWhat\'s interesting about iterables is that they aren\'t an actual collection or set of things, but rather _generate_ values on-demand. This means it\'s possible to have an iterable that never ends.\n\n## Count\n\n[`count`](https://clinth.github.io/ixfx/functions/Generators.count.html) yields a series of integers, counting by one: `0 1 2 3 ... `\n\nAs the examples show, `count` can be a useful way of running a chunk of code _x_ number of times. It might be more readable and robust than a typical `do`/`while` or `for` loop because there\'s only one thing you need to express: the amount of times to loop.\n\n\n```js\n// repl-pad\nimport { count } from "https://unpkg.com/ixfx/dist/generators.js"\n\n// count(amount:number, offset:number = 0);\n// Yields the array: [ 0, 1, 2, 3, 4 ]\nconst a = [...count(5)];\n```\n\nOr the more common style for using generators is to loop over them:\n```js\n// repl-pad\nimport { count } from "https://unpkg.com/ixfx/dist/generators.js"\nfor (const i of count(5)) {\n  // Loop runs five times, with i being 0, 1, 2, 3 and then 4\n  console.log(i);\n}\n```\n\nA negative `amount` counts backwards from zero:\n\n```js\nimport {count} from "https://unpkg.com/ixfx/dist/generators.js"\nimport {forEach} from "https://unpkg.com/ixfx/dist/flow.js"\n\n// Prints Hi! 0, Hi! -1 ... Hi! -4\n[...count(-5)].forEach(i => {\n  console.log(`Hi! ${i}`);\n});\n```\n\nIf an offset is supplied, it is added to the result:\n\n```js\n// Yields [ 1, 2, 3, 4, 5 ]\nconst a = [...count(5,1)];\n```\n\nFor more complicated counting, consider [`numericRange`](#numeric-range), which allows you to set the counting interval, and whether counting resets.\n\n<a name="numericRange"></a>\n\n## Numeric range\n\n[`numericRange`](https://clinth.github.io/ixfx/functions/Generators.numericRange.html) yields a series of numbers from `start` to `end`, with a specified `interval`. Unlike [`count`](#count), it can increment by and return fractional values.\n\n```js\nimport {numericRange} from "https://unpkg.com/ixfx/dist/generators.js"\n\n// numericRange(interval, start, end, repeating)\n\n// Counts from 0-100, by 0.1\nfor (const v of numericRange(0.1, 0, 100)) { }\n\n// Counts in twos from 0-100, and repeats from 0 again after 100\nfor (const v of numericRange(2, 0, 100, true)) { \n  // Caution: this generator never ends by itself, so you need\n  // a `break` statement somewhere in the for loop\n}\n\n// Generators can be used manually as well...\nconst range = numericRange(1, 0, 100);\nrange.next().value;\n```\n\nIf you just want to simply count from 0 to some number, consider using `count` instead.\n\n[`Numbers.linearSpace`](https://clinth.github.io/ixfx/functions/Numbers.linearSpace.html) generates a set number of steps between a start and end number.\n\n```js\n// repl-pad\nimport { linearSpace } from "https://unpkg.com/ixfx/dist/numbers.js"\n// linearSpace(start, end, steps);\n// Break up 1..5 in six steps\nconst values = [...linearSpace(1, 5, 6)];\n// Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n```\n## Percentages \nTo constrain the range to the percentage scale (0-1), use `numericPercent`:\n\n```js\nimport {numericPercent} from "https://unpkg.com/ixfx/dist/generators.js"\n\n// numericPercent(interval, repeating, start, end)\n\n// Counts from 0 to 1 by 10%\nfor (const v of numericPercent(0.1)) { \n  // 0, 0.1, 0.2 ...\n}\n\n// Counts from 0 to 1 by 10%, looping from 0\nfor (const v of numericPercent(0.1, true)) { \n  // 0, 0.1, 0.2 ... 1.0, 0.0, 0.1, 0.2 ...  \n  // Warning: infinite generator, make sure you `break` at some point\n}\n\n// Constant rotation\nconst r = numericPercent(0.1); // Setup once\n// Per animation loop, calculate new rotation\nconst angle = Math.PI*2*r.next().value; \n```\n\n\n## Ping pong\n\n[`pingPong`](https://clinth.github.io/ixfx/functions/Generators.pingPong.html) is like a repeating `numericRange` but it counts up and back down again when looping, rather than resetting to the start.\n\n```js\nimport { pingPong } from "https://unpkg.com/ixfx/dist/generators.js"\n\n// pingPong(interval, start, end, offset)\n\n// Counts up and down to 100 in 10s\nfor (const v of pingPong(10, 0, 100)) {\n  // 0, 10, 20 ... 100, 90, 80 ...0, 10, 20 ...\n  // Warning: infinite generator, make sure you `break` at some point\n}\n```\n\n[`pingPongPercent`](https://clinth.github.io/ixfx/functions/Generators.pingPongPercent.html) is a variation of `pingPong`, but it locks everything to a scale of 0-1.\n\n```js\nimport { pingPongPercent } from "https://unpkg.com/ixfx/dist/generators.js"\n\nfor (const v of pingPongPercent(0.01)) {\n  // Up and down from 0->1 by 1%\n  // Warning: infinite generator, make sure you `break` at some point\n}\n\n// Loops between 20-80% by 10%\nconst pp = pingPongPercent(0.1, 0.2, 0.8);\nconst v = pp.next().value;\n```\n\n## Generator helper functions\n\nIn the [Sync](https://clinth.github.io/ixfx/modules/Generators.Sync.html) and [Async](https://clinth.github.io/ixfx/modules/Generators.Async.html) sub-modules, there are a bunch of functions for working with generators or iterables.\n\nFor example:\n```js\nimport { Async, Sync } from "https://unpkg.com/ixfx/dist/generators.js"\n\nfor await (const v of Async.chunk(iterable, 5)) {\n  // v is array of length 5, contains chunks of `iterable`\n}\n```\n\nHere is a brief overview of available functions in these modules:\n\n* chunks: grab chunks of an iterable\n* concat: return the combined results from one or more iterables\n* dropWhile: ignore values that do not meet a predicate (opposite of `filter`)\n* equals: returns _true_ if values in two iterables are the same\n* every: returns _true_ if every value in iterable matches a predicate\n* fill: returns a replacement value for every value of the iterable\n* filter: returns items that match the predicate (opposite of `dropWhile``\n* forEach: run a function for each value\n* fromArray: creates an async generator from an array source\n* fromIterable: creates an async generator from an iterable/generator\n* map: returns value passed through a transform function\n* max/min: returns largest/smallest value seen\n* range: returns range of value seen\n* reduce: reduce values of iterable into one\n* slice: returns a section of an iterable\n* some: returns _true_ and exits when a predicate function matches\n* takeWhile: returns items for which predicate returns true\n* toArray: copies contents of iterable to an array\n* unique: only yields items not yet seen\n* zip: combines the items from several iterables at same position\n\nOnly in Sync module\n* chunksOverlapping: like `chunks`, but start of a chunk is the same element as last of the previous chunk\n* find: returns the first value that matches a predicate. While `some` returns a boolean.\n* first/last: returns first/last value from an iterable\n* flatten: unnests values which are arrays\n* uniqueByValue: only yields unique values\n* yieldNumber: returns the numeric value from a generator', "html": '<script type="module" hoist>\n  import \'/src/components/ReplPad\';\n<\/script>\n<div class="tip">\n<ul>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Generators.html">Generators module</a></li>\n</ul>\n</div>\n<p>Generators are a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">language feature of Javascript</a> that essentially allows a function to output multiple values, potentially asynchronously.</p>\n<p>ixfx includes:</p>\n<ul>\n<li><a href="#count">count</a>: yields a series of integers counting up (or down) from zero</li>\n<li><a href="#numeric-range">numericRange</a>: yields a series of numbers with a defined interval, start and end. Can reset back to start and loop</li>\n<li><a href="#ping-pong">ping pong</a>: same as numeric range, but it counts back down to start before looping</li>\n<li><a href="../../modulation/oscillator/">oscillators</a>: ixfx\'s oscillators are implemented as generators</li>\n</ul>\n<p>Uses:</p>\n<ul>\n<li><a href="../../flow/loops/#interval">interval</a>: an <em>asynchronous</em> generator, <code is:raw>interval</code> calls and returns a result at a specified interval.</li>\n</ul>\n<p>Importing tips:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Import as a module, meaning you have to prefix functions with Generators.</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">\'ixfx/lib/generators.js\'</span><span class="token punctuation">;</span>\n<span class="token comment">// Or, import as a module from the web directly</span>\n<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token comment">// Or, import a single function, eg interval</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> interval <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'ixfx/lib/generators.js\'</span><span class="token punctuation">;</span></code></pre>\n<h2 id="background">Background</h2>\n<p>Generators are a form of <em>iterator</em>, an object that allows you to traverse - that is, to step through - some other data. Objects are <em>iterable</em> if they provide an iterator on request, that is, the give the possibility for stepping through their contents in some manner. The familiar <a href="../../data/collections/">collections</a> - arrays, maps and so on - are all iterables.</p>\n<p><code is:raw>for .. of</code> is the usual way of working with an iterator. In this case, we\'re iterating over an array (which is <em>iterable</em>):</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> someArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span></code></pre>\n<p>Iterators allow us to traverse over data in different order, or perhaps returning different views over the data. For example, <code is:raw>Object.keys()</code> and <code is:raw>Object.values()</code> both return an iterators over whatever object you provide as a parameter. One yields a series of <em>keys</em>, the other <em>values</em>.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> something <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token literal-property property">colour</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">red</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n  <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token number">10</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Iterate keys (ie fields) of an object</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// `colour`, `size` ...  </span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Different iterator yields a series of values,</span>\n<span class="token comment">// even though input is the same</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// `red`, 10 ...</span>\n<span class="token punctuation">}</span></code></pre>\n<p>Iterators can be used in <code is:raw>for .. of</code> loops as above, but it\'s not always the case that you want to access every item at the same time. For example, maybe you want to fetch a new item from an iterable every minute.</p>\n<p>In this case, you can work with the iterator manually. Iterators have a <code is:raw>next()</code> function which both moves the iterator to the next position, and returns <code is:raw>{done, value}</code>, where <code is:raw>done</code> is <em>true/false</em> and <code is:raw>value</code> is the current value of iterator.</p>\n<p>Here we move the iterator and use the value:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment">/* handle when iterator is complete? */</span> <span class="token punctuation">}</span>\n<span class="token keyword">else</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Use value...</span>\n<span class="token punctuation">}</span></code></pre>\n<p>That kind of code could be called in a timer, fetching and using the value every <em>x</em> seconds, for example. Below gives an example of setting <code is:raw>state.value</code> with a new item from the iterator every 60 seconds. When/if the iterator finishes, it stops the interval and sets the value to <em>undefined</em>.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> iterInterval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// This code runs every 60secs...</span>\n  <span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Update `state.value` to the next thing from the iterator</span>\n    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> value <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Set `state.value` to undefined and stop interval</span>\n    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">}</span>\n    <span class="token function">clearInterval</span><span class="token punctuation">(</span>iterInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 60 seconds </span></code></pre>\n<p>Tip: ixfx\'s <a href="../../flow/loops/#interval">interval</a> makes iterating with delay easy.</p>\n<p>Iterables can be converted into an array:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> asArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Or alternatively:</span>\n<span class="token keyword">const</span> asArray <span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span>iterable<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>What\'s interesting about iterables is that they aren\'t an actual collection or set of things, but rather <em>generate</em> values on-demand. This means it\'s possible to have an iterable that never ends.</p>\n<h2 id="count">Count</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.count.html"><code is:raw>count</code></a> yields a series of integers, counting by one: <code is:raw>0 1 2 3 ... </code></p>\n<p>As the examples show, <code is:raw>count</code> can be a useful way of running a chunk of code <em>x</em> number of times. It might be more readable and robust than a typical <code is:raw>do</code>/<code is:raw>while</code> or <code is:raw>for</code> loop because there\'s only one thing you need to express: the amount of times to loop.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// count(amount:number, offset:number = 0);</span>\n<span class="token comment">// Yields the array: [ 0, 1, 2, 3, 4 ]</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>Or the more common style for using generators is to loop over them:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> i <span class="token keyword">of</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Loop runs five times, with i being 0, 1, 2, 3 and then 4</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n<p>A negative <code is:raw>amount</code> counts backwards from zero:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span>forEach<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/flow.js"</span>\n\n<span class="token comment">// Prints Hi! 0, Hi! -1 ... Hi! -4</span>\n<span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>If an offset is supplied, it is added to the result:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Yields [ 1, 2, 3, 4, 5 ]</span>\n<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n<p>For more complicated counting, consider <a href="#numeric-range"><code is:raw>numericRange</code></a>, which allows you to set the counting interval, and whether counting resets.</p>\n<a name="numericRange">\n</a>\n<h2 id="numeric-range">Numeric range</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.numericRange.html"><code is:raw>numericRange</code></a> yields a series of numbers from <code is:raw>start</code> to <code is:raw>end</code>, with a specified <code is:raw>interval</code>. Unlike <a href="#count"><code is:raw>count</code></a>, it can increment by and return fractional values.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericRange<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// numericRange(interval, start, end, repeating)</span>\n\n<span class="token comment">// Counts from 0-100, by 0.1</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>\n\n<span class="token comment">// Counts in twos from 0-100, and repeats from 0 again after 100</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// Caution: this generator never ends by itself, so you need</span>\n  <span class="token comment">// a `break` statement somewhere in the for loop</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Generators can be used manually as well...</span>\n<span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nrange<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre>\n<p>If you just want to simply count from 0 to some number, consider using <code is:raw>count</code> instead.</p>\n<p><a href="https://clinth.github.io/ixfx/functions/Numbers.linearSpace.html"><code is:raw>Numbers.linearSpace</code></a> generates a set number of steps between a start and end number.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad</span>\n<span class="token keyword">import</span> <span class="token punctuation">{</span> linearSpace <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/numbers.js"</span>\n<span class="token comment">// linearSpace(start, end, steps);</span>\n<span class="token comment">// Break up 1..5 in six steps</span>\n<span class="token keyword">const</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">linearSpace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]</span></code></pre>\n<h2 id="percentages">Percentages</h2>\n<p>To constrain the range to the percentage scale (0-1), use <code is:raw>numericPercent</code>:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericPercent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// numericPercent(interval, repeating, start, end)</span>\n\n<span class="token comment">// Counts from 0 to 1 by 10%</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 0, 0.1, 0.2 ...</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Counts from 0 to 1 by 10%, looping from 0</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n  <span class="token comment">// 0, 0.1, 0.2 ... 1.0, 0.0, 0.1, 0.2 ...  </span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Constant rotation</span>\n<span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Setup once</span>\n<span class="token comment">// Per animation loop, calculate new rotation</span>\n<span class="token keyword">const</span> angle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span> </code></pre>\n<h2 id="ping-pong">Ping pong</h2>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPong.html"><code is:raw>pingPong</code></a> is like a repeating <code is:raw>numericRange</code> but it counts up and back down again when looping, rather than resetting to the start.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPong <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token comment">// pingPong(interval, start, end, offset)</span>\n\n<span class="token comment">// Counts up and down to 100 in 10s</span>\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPong</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 0, 10, 20 ... 100, 90, 80 ...0, 10, 20 ...</span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span></code></pre>\n<p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPongPercent.html"><code is:raw>pingPongPercent</code></a> is a variation of <code is:raw>pingPong</code>, but it locks everything to a scale of 0-1.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPongPercent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// Up and down from 0->1 by 1%</span>\n  <span class="token comment">// Warning: infinite generator, make sure you `break` at some point</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Loops between 20-80% by 10%</span>\n<span class="token keyword">const</span> pp <span class="token operator">=</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> v <span class="token operator">=</span> pp<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre>\n<h2 id="generator-helper-functions">Generator helper functions</h2>\n<p>In the <a href="https://clinth.github.io/ixfx/modules/Generators.Sync.html">Sync</a> and <a href="https://clinth.github.io/ixfx/modules/Generators.Async.html">Async</a> sub-modules, there are a bunch of functions for working with generators or iterables.</p>\n<p>For example:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Async<span class="token punctuation">,</span> Sync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>\n\n<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> Async<span class="token punctuation">.</span><span class="token function">chunk</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// v is array of length 5, contains chunks of `iterable`</span>\n<span class="token punctuation">}</span></code></pre>\n<p>Here is a brief overview of available functions in these modules:</p>\n<ul>\n<li>chunks: grab chunks of an iterable</li>\n<li>concat: return the combined results from one or more iterables</li>\n<li>dropWhile: ignore values that do not meet a predicate (opposite of <code is:raw>filter</code>)</li>\n<li>equals: returns <em>true</em> if values in two iterables are the same</li>\n<li>every: returns <em>true</em> if every value in iterable matches a predicate</li>\n<li>fill: returns a replacement value for every value of the iterable</li>\n<li>filter: returns items that match the predicate (opposite of `dropWhile``</li>\n<li>forEach: run a function for each value</li>\n<li>fromArray: creates an async generator from an array source</li>\n<li>fromIterable: creates an async generator from an iterable/generator</li>\n<li>map: returns value passed through a transform function</li>\n<li>max/min: returns largest/smallest value seen</li>\n<li>range: returns range of value seen</li>\n<li>reduce: reduce values of iterable into one</li>\n<li>slice: returns a section of an iterable</li>\n<li>some: returns <em>true</em> and exits when a predicate function matches</li>\n<li>takeWhile: returns items for which predicate returns true</li>\n<li>toArray: copies contents of iterable to an array</li>\n<li>unique: only yields items not yet seen</li>\n<li>zip: combines the items from several iterables at same position</li>\n</ul>\n<p>Only in Sync module</p>\n<ul>\n<li>chunksOverlapping: like <code is:raw>chunks</code>, but start of a chunk is the same element as last of the previous chunk</li>\n<li>find: returns the first value that matches a predicate. While <code is:raw>some</code> returns a boolean.</li>\n<li>first/last: returns first/last value from an iterable</li>\n<li>flatten: unnests values which are arrays</li>\n<li>uniqueByValue: only yields unique values</li>\n<li>yieldNumber: returns the numeric value from a generator</li>\n</ul>' } };
  const SCRIPTS = [
    { props: { "type": "module", "hoist": true }, children: `import '/src/components/ReplPad';` }
  ];
  for (const SCRIPT of SCRIPTS)
    $$result.scripts.add(SCRIPT);
  return render`${renderComponent($$result, "Layout", $$MainLayout, { "content": $$content }, { "default": () => render`<div class="tip">
<ul>
<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Generators.html">Generators module</a></li>
</ul>
</div><p>Generators are a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">language feature of Javascript</a> that essentially allows a function to output multiple values, potentially asynchronously.</p><p>ixfx includes:</p><ul>
<li><a href="#count">count</a>: yields a series of integers counting up (or down) from zero</li>
<li><a href="#numeric-range">numericRange</a>: yields a series of numbers with a defined interval, start and end. Can reset back to start and loop</li>
<li><a href="#ping-pong">ping pong</a>: same as numeric range, but it counts back down to start before looping</li>
<li><a href="../../modulation/oscillator/">oscillators</a>: ixfx's oscillators are implemented as generators</li>
</ul><p>Uses:</p><ul>
<li><a href="../../flow/loops/#interval">interval</a>: an <em>asynchronous</em> generator, <code>interval</code> calls and returns a result at a specified interval.</li>
</ul><p>Importing tips:</p><pre class="language-js"><code class="language-js"><span class="token comment">// Import as a module, meaning you have to prefix functions with Generators.</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">'ixfx/lib/generators.js'</span><span class="token punctuation">;</span>
<span class="token comment">// Or, import as a module from the web directly</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> Generators <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>
<span class="token comment">// Or, import a single function, eg interval</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> interval <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'ixfx/lib/generators.js'</span><span class="token punctuation">;</span></code></pre><h2 id="background">Background</h2><p>Generators are a form of <em>iterator</em>, an object that allows you to traverse - that is, to step through - some other data. Objects are <em>iterable</em> if they provide an iterator on request, that is, the give the possibility for stepping through their contents in some manner. The familiar <a href="../../data/collections/">collections</a> - arrays, maps and so on - are all iterables.</p><p><code>for .. of</code> is the usual way of working with an iterator. In this case, we're iterating over an array (which is <em>iterable</em>):</p><pre class="language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> someArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span></code></pre><p>Iterators allow us to traverse over data in different order, or perhaps returning different views over the data. For example, <code>Object.keys()</code> and <code>Object.values()</code> both return an iterators over whatever object you provide as a parameter. One yields a series of <em>keys</em>, the other <em>values</em>.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> something <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">colour</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">red</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span>
  <span class="token literal-property property">size</span><span class="token operator">:</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token comment">// Iterate keys (ie fields) of an object</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// \`colour\`, \`size\` ...  </span>
<span class="token punctuation">}</span>

<span class="token comment">// Different iterator yields a series of values,</span>
<span class="token comment">// even though input is the same</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// \`red\`, 10 ...</span>
<span class="token punctuation">}</span></code></pre><p>Iterators can be used in <code>for .. of</code> loops as above, but it's not always the case that you want to access every item at the same time. For example, maybe you want to fetch a new item from an iterable every minute.</p><p>In this case, you can work with the iterator manually. Iterators have a <code>next()</code> function which both moves the iterator to the next position, and returns <code>{done, value}</code>, where <code>done</code> is <em>true/false</em> and <code>value</code> is the current value of iterator.</p><p>Here we move the iterator and use the value:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>done<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token comment">/* handle when iterator is complete? */</span> <span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// Use value...</span>
<span class="token punctuation">}</span></code></pre><p>That kind of code could be called in a timer, fetching and using the value every <em>x</em> seconds, for example. Below gives an example of setting <code>state.value</code> with a new item from the iterator every 60 seconds. When/if the iterator finishes, it stops the interval and sets the value to <em>undefined</em>.</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> iterInterval <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// This code runs every 60secs...</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span>value<span class="token punctuation">,</span> done<span class="token punctuation">}</span> <span class="token operator">=</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Update \`state.value\` to the next thing from the iterator</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> value <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Set \`state.value\` to undefined and stop interval</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>state<span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token keyword">undefined</span> <span class="token punctuation">}</span>
    <span class="token function">clearInterval</span><span class="token punctuation">(</span>iterInterval<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 60 seconds </span></code></pre><p>Tip: ixfx's <a href="../../flow/loops/#interval">interval</a> makes iterating with delay easy.</p><p>Iterables can be converted into an array:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> asArray <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Or alternatively:</span>
<span class="token keyword">const</span> asArray <span class="token operator">=</span><span class="token punctuation">[</span><span class="token operator">...</span>iterable<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>What's interesting about iterables is that they aren't an actual collection or set of things, but rather <em>generate</em> values on-demand. This means it's possible to have an iterable that never ends.</p><h2 id="count">Count</h2><p><a href="https://clinth.github.io/ixfx/functions/Generators.count.html"><code>count</code></a> yields a series of integers, counting by one: <code>0 1 2 3 ... </code></p><p>As the examples show, <code>count</code> can be a useful way of running a chunk of code <em>x</em> number of times. It might be more readable and robust than a typical <code>do</code>/<code>while</code> or <code>for</code> loop because there's only one thing you need to express: the amount of times to loop.</p><pre class="language-js"><code class="language-js"><span class="token comment">// repl-pad</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>

<span class="token comment">// count(amount:number, offset:number = 0);</span>
<span class="token comment">// Yields the array: [ 0, 1, 2, 3, 4 ]</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>Or the more common style for using generators is to loop over them:</p><pre class="language-js"><code class="language-js"><span class="token comment">// repl-pad</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> i <span class="token keyword">of</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Loop runs five times, with i being 0, 1, 2, 3 and then 4</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre><p>A negative <code>amount</code> counts backwards from zero:</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>count<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>forEach<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/flow.js"</span>

<span class="token comment">// Prints Hi! 0, Hi! -1 ... Hi! -4</span>
<span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">i</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Hi! </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>i<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>If an offset is supplied, it is added to the result:</p><pre class="language-js"><code class="language-js"><span class="token comment">// Yields [ 1, 2, 3, 4, 5 ]</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>For more complicated counting, consider <a href="#numeric-range"><code>numericRange</code></a>, which allows you to set the counting interval, and whether counting resets.</p><a name="numericRange">
</a><h2 id="numeric-range">Numeric range</h2><p><a href="https://clinth.github.io/ixfx/functions/Generators.numericRange.html"><code>numericRange</code></a> yields a series of numbers from <code>start</code> to <code>end</code>, with a specified <code>interval</code>. Unlike <a href="#count"><code>count</code></a>, it can increment by and return fractional values.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericRange<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>

<span class="token comment">// numericRange(interval, start, end, repeating)</span>

<span class="token comment">// Counts from 0-100, by 0.1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

<span class="token comment">// Counts in twos from 0-100, and repeats from 0 again after 100</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token comment">// Caution: this generator never ends by itself, so you need</span>
  <span class="token comment">// a \`break\` statement somewhere in the for loop</span>
<span class="token punctuation">}</span>

<span class="token comment">// Generators can be used manually as well...</span>
<span class="token keyword">const</span> range <span class="token operator">=</span> <span class="token function">numericRange</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
range<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre><p>If you just want to simply count from 0 to some number, consider using <code>count</code> instead.</p><p><a href="https://clinth.github.io/ixfx/functions/Numbers.linearSpace.html"><code>Numbers.linearSpace</code></a> generates a set number of steps between a start and end number.</p><pre class="language-js"><code class="language-js"><span class="token comment">// repl-pad</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> linearSpace <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/numbers.js"</span>
<span class="token comment">// linearSpace(start, end, steps);</span>
<span class="token comment">// Break up 1..5 in six steps</span>
<span class="token keyword">const</span> values <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">linearSpace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">// Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]</span></code></pre><h2 id="percentages">Percentages</h2><p>To constrain the range to the percentage scale (0-1), use <code>numericPercent</code>:</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>numericPercent<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>

<span class="token comment">// numericPercent(interval, repeating, start, end)</span>

<span class="token comment">// Counts from 0 to 1 by 10%</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token comment">// 0, 0.1, 0.2 ...</span>
<span class="token punctuation">}</span>

<span class="token comment">// Counts from 0 to 1 by 10%, looping from 0</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token comment">// 0, 0.1, 0.2 ... 1.0, 0.0, 0.1, 0.2 ...  </span>
  <span class="token comment">// Warning: infinite generator, make sure you \`break\` at some point</span>
<span class="token punctuation">}</span>

<span class="token comment">// Constant rotation</span>
<span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token function">numericPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Setup once</span>
<span class="token comment">// Per animation loop, calculate new rotation</span>
<span class="token keyword">const</span> angle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token constant">PI</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span> </code></pre><h2 id="ping-pong">Ping pong</h2><p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPong.html"><code>pingPong</code></a> is like a repeating <code>numericRange</code> but it counts up and back down again when looping, rather than resetting to the start.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPong <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>

<span class="token comment">// pingPong(interval, start, end, offset)</span>

<span class="token comment">// Counts up and down to 100 in 10s</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPong</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 0, 10, 20 ... 100, 90, 80 ...0, 10, 20 ...</span>
  <span class="token comment">// Warning: infinite generator, make sure you \`break\` at some point</span>
<span class="token punctuation">}</span></code></pre><p><a href="https://clinth.github.io/ixfx/functions/Generators.pingPongPercent.html"><code>pingPongPercent</code></a> is a variation of <code>pingPong</code>, but it locks everything to a scale of 0-1.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> pingPongPercent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Up and down from 0->1 by 1%</span>
  <span class="token comment">// Warning: infinite generator, make sure you \`break\` at some point</span>
<span class="token punctuation">}</span>

<span class="token comment">// Loops between 20-80% by 10%</span>
<span class="token keyword">const</span> pp <span class="token operator">=</span> <span class="token function">pingPongPercent</span><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.2</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> v <span class="token operator">=</span> pp<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span></code></pre><h2 id="generator-helper-functions">Generator helper functions</h2><p>In the <a href="https://clinth.github.io/ixfx/modules/Generators.Sync.html">Sync</a> and <a href="https://clinth.github.io/ixfx/modules/Generators.Async.html">Async</a> sub-modules, there are a bunch of functions for working with generators or iterables.</p><p>For example:</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Async<span class="token punctuation">,</span> Sync <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/generators.js"</span>

<span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">const</span> v <span class="token keyword">of</span> Async<span class="token punctuation">.</span><span class="token function">chunk</span><span class="token punctuation">(</span>iterable<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// v is array of length 5, contains chunks of \`iterable\`</span>
<span class="token punctuation">}</span></code></pre><p>Here is a brief overview of available functions in these modules:</p><ul>
<li>chunks: grab chunks of an iterable</li>
<li>concat: return the combined results from one or more iterables</li>
<li>dropWhile: ignore values that do not meet a predicate (opposite of <code>filter</code>)</li>
<li>equals: returns <em>true</em> if values in two iterables are the same</li>
<li>every: returns <em>true</em> if every value in iterable matches a predicate</li>
<li>fill: returns a replacement value for every value of the iterable</li>
<li>filter: returns items that match the predicate (opposite of \`dropWhile\`\`</li>
<li>forEach: run a function for each value</li>
<li>fromArray: creates an async generator from an array source</li>
<li>fromIterable: creates an async generator from an iterable/generator</li>
<li>map: returns value passed through a transform function</li>
<li>max/min: returns largest/smallest value seen</li>
<li>range: returns range of value seen</li>
<li>reduce: reduce values of iterable into one</li>
<li>slice: returns a section of an iterable</li>
<li>some: returns <em>true</em> and exits when a predicate function matches</li>
<li>takeWhile: returns items for which predicate returns true</li>
<li>toArray: copies contents of iterable to an array</li>
<li>unique: only yields items not yet seen</li>
<li>zip: combines the items from several iterables at same position</li>
</ul><p>Only in Sync module</p><ul>
<li>chunksOverlapping: like <code>chunks</code>, but start of a chunk is the same element as last of the previous chunk</li>
<li>find: returns the first value that matches a predicate. While <code>some</code> returns a boolean.</li>
<li>first/last: returns first/last value from an iterable</li>
<li>flatten: unnests values which are arrays</li>
<li>uniqueByValue: only yields unique values</li>
<li>yieldNumber: returns the numeric value from a generator</li>
</ul>` })}`;
});

export { $$metadata, $$Generator as default, frontmatter, metadata };
