import{_,b as Ue}from"./chunk-FQLUQVDZ.735c98e3.js";import{S as er,i as Y,n as Je,p as tr}from"./chunk-QLMTBJ7O.4bda2143.js";var rr={};_(rr,{addUniqueByHash:()=>ir,filter:()=>or,find:()=>ur,hasAnyValue:()=>sr,hasKeyValue:()=>nr,mapToArray:()=>lr,mapToObj:()=>cr,toArray:()=>ar,transformMap:()=>fr,zipKeyValue:()=>Se});var nr=(e,r,n,i)=>e.has(r)?Array.from(e.values()).some(o=>i(o,n)):!1,ir=(e,r,...n)=>{const i=e===void 0?new Map:new Map(e);return n.forEach(s=>{const o=r(s);i.has(o)||i.set(o,s)}),i},sr=(e,r,n)=>Array.from(e.entries()).some(s=>n(s[1],r)),or=(e,r)=>Array.from(e.values()).filter(r),ar=e=>Array.from(e.values()),ur=(e,r)=>Array.from(e.values()).find(n=>r(n)),fr=(e,r)=>new Map(Array.from(e,n=>[n[0],r(n[1],n[0])])),Se=(e,r)=>{if(e.length!==r.length)throw new Error("Keys and values arrays should be same length");return Object.fromEntries(e.map((n,i)=>[n,r[i]]))},cr=e=>Array.from(e).reduce((r,[n,i])=>(r[n]=i,r),{}),lr=(e,r)=>Array.from(e.entries()).map(n=>r(n[0],n[1])),hr={};_(hr,{setMutable:()=>He});var He=(e=void 0)=>new yr(e),yr=class extends er{constructor(e=void 0){super();Ue(this,"store",new Map),Ue(this,"keyString"),e===void 0&&(e=r=>typeof r=="string"?r:JSON.stringify(r)),this.keyString=e}add(...e){e.forEach(r=>{const n=this.has(r);this.store.set(this.keyString(r),r),super.fireEvent("add",{value:r,updated:n})})}values(){return this.store.values()}clear(){this.store.clear(),super.fireEvent("clear",!0)}delete(e){const r=this.store.delete(this.keyString(e));return r&&super.fireEvent("delete",e),r}has(e){return this.store.has(this.keyString(e))}toArray(){return Array.from(this.store.values())}},Xe=(e,r=0,n=1)=>{if(Number.isNaN(e))throw new Error("v parameter is NaN");if(Number.isNaN(r))throw new Error("min parameter is NaN");if(Number.isNaN(n))throw new Error("max parameter is NaN");return e<r?r:e>n?n:e},di=(e,r,n,i,s,o)=>{if(s===void 0&&(s=1),i===void 0&&(i=0),r===n)return s;let a=(e-r)/(n-r);return o!==void 0&&(a=o(a)),a*(s-i)+i},Ve=(e,r)=>{if(!Number.isInteger(e))throw new Error(`v parameter must be an integer (${e})`);const n=Array.isArray(r)?r.length:r;if(!Number.isInteger(n))throw new Error(`length parameter must be an integer (${n}, ${typeof n})`);return e=Math.round(e),e<0?0:e>=n?n-1:e},dr=(e,r,n)=>(1-e)*r+e*n,xr=(e,r)=>e===r,xi=e=>typeof e=="string"?e:JSON.stringify(e),vi=(e,r)=>{const n=vr(e,r);return(...i)=>n.start(void 0,i)},mi=(e,r)=>{let n=0;return async(...i)=>{const s=performance.now()-n;if(s>=r){const o=e(s,...i);typeof o=="object"&&await o,n=performance.now()}}},pi=async function*(e,r){let n=!1;try{for(;!n;){if(await Ye(r),n)return;if(typeof e=="function")yield await e();else if(typeof e=="object")if("next"in e&&"return"in e&&"throw"in e){const i=await e.next();if(i.done)return;yield i.value}else throw new Error("interval: produce param does not seem to be a generator?");else throw new Error("produce param does not seem to return a value/Promise and is not a generator?")}}finally{n=!0}},vr=(e,r)=>{if(e===void 0)throw new Error("callback parameter is undefined");Y(r,"aboveZero","timeoutMs");let n=0,i=0;const s=async(a=r,u)=>new Promise((l,c)=>{i=performance.now();try{Y(a,"aboveZero","altTimeoutMs")}catch(h){c(h);return}n!==0&&o(),n=window.setTimeout(async()=>{await e(performance.now()-i,...u),n=0,l(void 0)},a)}),o=()=>{n!==0&&(i=0,window.clearTimeout(n))};return{start:s,cancel:o,get isDone(){return n!==0}}},wi=(e,r,n)=>{r!==void 0&&Y(r,"positive","intervalMs");let i=!1,s=0,o=performance.now();const a=r===void 0||r===0?c=>window.requestAnimationFrame(c):c=>window.setTimeout(c,r),u=()=>{!i||(i=!1,s=0)},f=async()=>{if(!i)return;const c=e(s++,performance.now()-o);let h;if(typeof c=="object"?h=await c:h=c,h!==void 0&&!h){u();return}a(f)};return{start:()=>{if(i&&n!==void 0){const c=n(s,performance.now()-o);if(o=performance.now(),c!==void 0&&!c){u();return}}else if(i)return;i=!0,a(f)},get isDone(){return i},get ticks(){return s},get elapsedMs(){return performance.now()-o},cancel:u}},Ye=e=>new Promise(r=>setTimeout(r,e)),gi=async(e,r)=>(Y(r,"aboveZero","timeoutMs"),await Ye(r),Promise.resolve(await e())),mr=(e,r,n=!0)=>{let i=!1,s=1;return{mod(o){s=o},get isDone(){return i},reset:()=>{i=!1,r.reset()},get elapsed(){let o=r.elapsed/(e*s);return n&&(o=Xe(o)),o>=1&&(i=!0),o}}},bi=e=>()=>pr(e,$e()),pr=(e,r=$e())=>{const n=e/1e3;let i=1;return{mod:s=>{i=s},reset:()=>{r.reset()},get elapsed(){const s=r.elapsed*(n*i),o=s-Math.floor(s);if(o<0)throw new Error(`Unexpected cycle fraction less than 0. Elapsed: ${s} f: ${o}`);if(o>1)throw new Error(`Unexpected cycle fraction more than 1. Elapsed: ${s} f: ${o}`);return o}}},$e=()=>{let e=performance.now();return{reset:()=>{e=performance.now()},get elapsed(){return performance.now()-e}}},wr=()=>{let e=0;return{reset:()=>{e=0},get elapsed(){return e++}}},zi=(e,r,n="slow")=>{let i=0,s,o=r;return()=>new Promise(async(a,u)=>{const f=performance.now()-i;if(s===void 0||f>o)try{i=performance.now(),s=await e(f),o=r}catch(l){n==="fast"?(s=void 0,i=0):n==="backoff"&&(o=Math.floor(o*1.2)),u(l);return}a(s)})},gr={};_(gr,{arrayElement:()=>Pe,arrayIndex:()=>_e,defaultRandom:()=>W,gaussian:()=>qe,gaussianSkewed:()=>Fr,weighted:()=>Lr,weightedInteger:()=>Dr});var br={};_(br,{average:()=>zr,groupBy:()=>Pr,guardArray:()=>et,max:()=>Nr,min:()=>Er,minMaxAvg:()=>Mr,randomElement:()=>Pe,randomIndex:()=>_e,randomPluck:()=>Sr,shuffle:()=>$r,without:()=>_r});var zr=(...e)=>{if(e===void 0)throw new Error("data parameter is undefined");const r=e.filter(i=>typeof i=="number"&&!Number.isNaN(i));return r.reduce((i,s)=>i+s,0)/r.length},Er=(...e)=>{const r=e.filter(n=>typeof n=="number"&&!Number.isNaN(n));return Math.min(...r)},Nr=(...e)=>{const r=e.filter(n=>typeof n=="number"&&!Number.isNaN(n));return Math.max(...r)},Mr=e=>{const r=e.filter(i=>typeof i=="number"&&!Number.isNaN(i)),n=r.reduce((i,s)=>i+s,0);return{total:n,max:Math.max(...r),min:Math.min(...r),avg:n/r.length}},et=(e,r="?")=>{if(e===void 0)throw new Error(`Param '${r}' is undefined. Expected array.`);if(e===null)throw new Error(`Param '${r}' is null. Expected array.`);if(!Array.isArray(e))throw new Error(`Param '${r}' not an array as expected`)},_e=(e,r=W)=>Math.floor(r()*e.length),Pe=(e,r=W)=>(et(e,"array"),e[Math.floor(r()*e.length)]),Sr=(e,r=!1,n=W)=>{if(e===void 0)throw new Error("array is undefined");if(!Array.isArray(e))throw new Error("'array' param is not an array");if(e.length===0)return{value:void 0,array:[]};const i=_e(e,n);if(r)return{value:e[i],array:e.splice(i,1)};{const s=[...e];return s.splice(i,1),{value:e[i],array:s}}},$r=(e,r=W)=>{const n=[...e];for(let i=n.length-1;i>0;i--){const s=Math.floor(r()*(i+1));[n[i],n[s]]=[n[s],n[i]]}return n},_r=(e,r,n=xr)=>e.filter(i=>!n(i,r)),Pr=(e,r)=>e.reduce((n,i)=>{const s=r(i),o=n.get(s);return o===void 0?n.set(s,[i]):o.push(i),n},new Map),Ar={};_(Ar,{crossfade:()=>kr,fromCubicBezier:()=>Rr,functions:()=>Ae,gaussian:()=>nt,get:()=>pe,getEasings:()=>jr,mix:()=>rt,tick:()=>Cr,time:()=>qr});var ue=Math.sqrt,E=Math.pow,Ge=Math.cos,K=Math.PI,re=Math.sin,qr=function(e,r){return tt(e,r,$e)},Cr=function(e,r){return tt(e,r,wr)},tt=function(e,r,n){let i;if(typeof e=="function"?i=e:i=pe(e),i===void 0)throw new Error(`Easing function not found: ${e}`);const s=mr(r,n(),!0);return{get isDone(){return s.isDone},compute:()=>{const o=s.elapsed;return i(o)},reset:()=>{s.reset()}}},Rr=(e,r)=>n=>{const i=1-n,s=i*i,o=n*n,a=o*n;return 3*e*s*n+3*r*i*o+a},rt=(e,r,n,i)=>dr(r,n(e),i(e)),kr=(e,r,n)=>rt(e,e,r,n),pe=function(e){if(e===null)throw new Error("easingName is null");if(e===void 0)throw new Error("easingName is undefined");const r=e.toLocaleLowerCase(),n=Object.entries(Ae).find(([i,s])=>i.toLocaleLowerCase()===r);return n===void 0?n:n[1]},jr=function(){return Array.from(Object.keys(Ae))},nt=(e=.4)=>{const r=1/ue(2*K),n=.5;return i=>{const s=r/e;let o=-2.5,a=(i-n)/e;a*=a,o*=a;const u=s*E(Math.E,o);return u>1?1:u<0?0:u}},le=function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},Ir=e=>e*e*e*e*e,Or=e=>1-E(1-e,5),Tr=e=>e*(1-e)*4,Ae={arch:Tr,bell:nt(),sineIn:e=>1-Ge(e*K/2),sineOut:e=>re(e*K/2),quadIn:e=>e*e,quadOut:e=>1-(1-e)*(1-e),sineInOut:e=>-(Ge(K*e)-1)/2,quadInOut:e=>e<.5?2*e*e:1-E(-2*e+2,2)/2,cubicIn:e=>e*e*e,cubicOut:e=>1-E(1-e,3),quartIn:e=>e*e*e*e,quartOut:e=>1-E(1-e,4),quintIn:Ir,quintOut:Or,expoIn:e=>e===0?0:E(2,10*e-10),expoOut:e=>e===1?1:1-E(2,-10*e),quintInOut:e=>e<.5?16*e*e*e*e*e:1-E(-2*e+2,5)/2,expoInOut:e=>e===0?0:e===1?1:e<.5?E(2,20*e-10)/2:(2-E(2,-20*e+10))/2,circIn:e=>1-ue(1-E(e,2)),circOut:e=>ue(1-E(e-1,2)),backIn:e=>2.70158*e*e*e-1.70158*e*e,backOut:e=>1+2.70158*E(e-1,3)+1.70158*E(e-1,2),circInOut:e=>e<.5?(1-ue(1-E(2*e,2)))/2:(ue(1-E(-2*e+2,2))+1)/2,backInOut:e=>{const n=2.5949095;return e<.5?E(2*e,2)*((n+1)*2*e-n)/2:(E(2*e-2,2)*((n+1)*(e*2-2)+n)+2)/2},elasticIn:e=>{const r=2*K/3;return e===0?0:e===1?1:-E(2,10*e-10)*re((e*10-10.75)*r)},elasticOut:e=>{const r=2*K/3;return e===0?0:e===1?1:E(2,-10*e)*re((e*10-.75)*r)+1},bounceIn:e=>1-le(1-e),bounceOut:le,elasticInOut:e=>{const r=2*K/4.5;return e===0?0:e===1?1:e<.5?-(E(2,20*e-10)*re((20*e-11.125)*r))/2:E(2,-20*e+10)*re((20*e-11.125)*r)/2+1},bounceInOut:e=>e<.5?(1-le(1-2*e))/2:(1+le(2*e-1))/2},W=Math.random,Lr=(e="quadIn",r=W)=>{const n=r(),i=pe(e);if(i===void 0)throw new Error(`Easing function '${e}' not found.`);return i(n)},Dr=(e,r,n,i=W)=>{Je(e);let s,o,a;if(a="quadIn",s=0,r===void 0)o=e;else if(typeof r=="number")s=e,o=r,n!==void 0&&(a=n);else if(typeof r=="string")o=e,a=r;else throw new Error(`Unexpected value type for maxOrEasing: ${r}`);n!==void 0&&(a=n);const u=pe(a);if(u===void 0)throw new Error(`Easing '${a}' not found`);if(Je(s),o<=s)throw new Error("Max should be greater than min");const f=Xe(u(i()));return Math.floor(f*(o-s))+s},qe=(e=1)=>{let i=0,s=0;for(;i===0;)i=Math.random();for(;s===0;)s=Math.random();let o=Math.sqrt(-2*Math.log(i))*Math.cos(2*Math.PI*s);return o=o/10+.5,o>1||o<0?o=qe(e):(o=Math.pow(o,e),o*=1-0,o+=0),o},Fr=e=>()=>qe(e),Br={};_(Br,{Arcs:()=>it,Beziers:()=>be,Circles:()=>St,Compound:()=>Ot,Ellipses:()=>Xt,Grids:()=>Jt,Lines:()=>J,Paths:()=>ce,Points:()=>$,Polar:()=>me,Rects:()=>V,degreeToRadian:()=>X,radianToDegree:()=>ci,radiansFromAxisX:()=>li});var it={};_(it,{bbox:()=>wt,distanceCenter:()=>hn,fromDegrees:()=>cn,guard:()=>Re,interpolate:()=>ke,isArc:()=>vt,isEquals:()=>yn,isPositioned:()=>D,length:()=>pt,point:()=>ve,toLine:()=>mt,toPath:()=>ln,toSvg:()=>gt});var $={};_($,{Empty:()=>xe,angleBetween:()=>Xr,bbox:()=>Yr,distance:()=>Hr,equals:()=>rn,findMinimum:()=>fe,from:()=>on,fromNumbers:()=>an,guard:()=>N,interpolate:()=>sn,isPoint:()=>O,multiply:()=>fn,subtract:()=>xt,sum:()=>un,toArray:()=>en,toString:()=>tn,withinRange:()=>nn});var J={};_(J,{angleRadian:()=>Jr,bbox:()=>yt,distance:()=>ut,equals:()=>Ur,extendFromStart:()=>Kr,extendX:()=>Gr,fromArray:()=>Qr,fromNumbers:()=>ct,fromPoints:()=>ge,fromPointsToPath:()=>Zr,guard:()=>st,interpolate:()=>Ce,isLine:()=>we,joinPointsToLines:()=>Wr,length:()=>Q,nearest:()=>ot,slope:()=>at,toFlatArray:()=>lt,toPath:()=>dt,toString:()=>ft,toSvgString:()=>ht,withinRange:()=>Vr});var we=e=>e.a!==void 0&&e.b!==void 0,Ur=(e,r)=>e.a===r.a&&e.b===r.b,st=(e,r="line")=>{if(e===void 0)throw new Error(`${r} undefined`);if(e.a===void 0)throw new Error(`${r}.a undefined. Expected {a:Point, b:Point}`);if(e.b===void 0)throw new Error(`${r}.b undefined. Expected {a:Point, b:Point}`)},Jr=(e,r)=>{let n;if(we(e))n=e.a,r=e.b;else if(n=e,r===void 0)throw new Error("b point must be provided");return Math.atan2(r.y-n.y,r.x-n.x)},Vr=(e,r,n)=>ut(e,r)<=n,Q=(e,r)=>{let n;if(we(e))r=e.b,n=e.a;else if(n=e,r===void 0)throw new Error("Requires both a and b parameters");N(n,"a"),N(n,"b");const i=r.x-n.x,s=r.y-n.y;if(n.z!==void 0&&r.z!==void 0){const o=r.z-n.z;return Math.hypot(i,s,o)}else return Math.hypot(i,s)},ot=(e,r)=>{const{a:n,b:i}=e,s={x:i.x-n.x,y:i.y-n.y},o={x:r.x-n.x,y:r.y-n.y},a=s.x*s.x+s.y*s.y;let u=o.x*s.x+o.y*s.y;const f=Math.min(1,Math.max(0,u/a));return u=(i.x-n.x)*(r.y-n.y)-(i.y-n.y)*(r.x-n.x),{x:n.x+s.x*f,y:n.y+s.y*f}},at=(e,r)=>{let n;if(we(e))n=e.a,r=e.b;else if(n=e,r===void 0)throw new Error("b parameter required");if(r!==void 0)return(r.y-n.y)/(r.x-n.x);throw Error("Second point missing")},Gr=(e,r)=>{const n=e.a.y+(r-e.a.x)*at(e);return{x:r,y:n}},Kr=(e,r)=>{const n=Q(e);return Object.freeze({a:e.a,b:Object.freeze({x:e.b.x+(e.b.x-e.a.x)/n*r,y:e.b.y+(e.b.y-e.a.y)/n*r})})},ut=(e,r)=>{if(st(e,"l"),N(r,"p"),Q(e)===0)return Q(e.a,r);const i=ot(e,r);return Q(i,r)},Ce=(e,r,n)=>{N(r,"a"),N(n,"b"),tr(e,"t");const i=Q(r,n),s=i*(1-e),o=n.x-s*(n.x-r.x)/i,a=n.y-s*(n.y-r.y)/i;return{x:o,y:a}},ft=(e,r)=>$.toString(e)+"-"+$.toString(r),ct=(e,r,n,i)=>{if(Number.isNaN(e))throw new Error("x1 is NaN");if(Number.isNaN(n))throw new Error("x2 is NaN");if(Number.isNaN(r))throw new Error("y1 is NaN");if(Number.isNaN(i))throw new Error("y2 is NaN");return ge({x:e,y:r},{x:n,y:i})},lt=(e,r)=>[e.x,e.y,r.x,r.y],ht=(e,r)=>[`M${e.x} ${e.y} L ${r.x} ${r.y}`],Qr=e=>{if(!Array.isArray(e))throw new Error("arr parameter is not an array");if(e.length!==4)throw new Error("array is expected to have length four");return ct(e[0],e[1],e[2],e[3])},ge=(e,r)=>(N(e,"a"),N(r,"b"),e=Object.freeze(e),r=Object.freeze(r),Object.freeze({a:e,b:r})),Wr=(...e)=>{const r=[];let n=e[0];for(let i=1;i<e.length;i++)r.push(ge(n,e[i])),n=e[i];return r},Zr=(e,r)=>dt(ge(e,r)),yt=e=>$.bbox(e.a,e.b),dt=e=>{const{a:r,b:n}=e;return Object.freeze({...e,length:()=>Q(r,n),interpolate:i=>Ce(i,r,n),bbox:()=>yt(e),toString:()=>ft(r,n),toFlatArray:()=>lt(r,n),toSvgString:()=>ht(r,n),toPoints:()=>[r,n],kind:"line"})},xe=Object.freeze({x:0,y:0}),fe=(e,...r)=>{if(r.length===0)throw new Error("No points provided");let n=r[0];return r.forEach(i=>{n=e(n,i)}),n},Hr=(e,r)=>(N(e,"a"),N(r,"b"),Math.hypot(r.x-e.x,r.y-e.y)),N=(e,r="Point")=>{if(e===void 0)throw new Error(`'${r}' is undefined. Expected {x,y} got ${JSON.stringify(e)}`);if(e===null)throw new Error(`'${r}' is null. Expected {x,y} got ${JSON.stringify(e)}`);if(e.x===void 0)throw new Error(`'${r}.x' is undefined. Expected {x,y} got ${JSON.stringify(e)}`);if(e.y===void 0)throw new Error(`'${r}.y' is undefined. Expected {x,y} got ${JSON.stringify(e)}`);if(typeof e.x!="number")throw new Error(`'${r}.x' must be a number`);if(typeof e.y!="number")throw new Error(`'${r}.y' must be a number`);if(Number.isNaN(e.x))throw new Error(`'${r}.x' is NaN`);if(Number.isNaN(e.y))throw new Error(`'${r}.y' is NaN`)},Xr=(e,r)=>Math.atan2(r.y-e.y,r.x-e.x),Yr=(...e)=>{const r=fe((l,c)=>l.x<c.x?l:c,...e),n=fe((l,c)=>l.x>c.x?l:c,...e),i=fe((l,c)=>l.y<c.y?l:c,...e),s=fe((l,c)=>l.y>c.y?l:c,...e),o={x:r.x,y:i.y},a={x:n.x,y:i.y},u={x:n.x,y:s.y},f={x:r.x,y:s.y};return V.maxFromCorners(o,a,u,f)},O=e=>!(e===void 0||e.x===void 0||e.y===void 0),en=e=>[e.x,e.y],tn=e=>e.z!==void 0?`(${e.x},${e.y},${e.z})`:`(${e.x},${e.y})`,rn=(e,r)=>e.x===r.x&&e.y===r.y,nn=(e,r,n)=>{typeof n=="number"&&(n={x:n,y:n});const i=Math.abs(r.x-e.x),s=Math.abs(r.y-e.y);return i<=n.x&&s<=n.y},sn=(e,r,n)=>Ce(e,r,n),on=(e,r)=>{if(Array.isArray(e)){if(e.length!==2)throw new Error("Expected array of length two, got "+e.length);return Object.freeze({x:e[0],y:e[1]})}else{if(e===void 0)e=0;else if(Number.isNaN(e))throw new Error("x is NaN");if(r===void 0)r=0;else if(Number.isNaN(r))throw new Error("y is NaN");return Object.freeze({x:e,y:r})}},an=(...e)=>{const r=[];if(Array.isArray(e[0]))e.forEach(n=>{if(n.length%2!==0)throw new Error("coords array should be even-numbered");r.push(Object.freeze({x:n[0],y:n[1]}))});else{if(e.length!==2)throw new Error("Expected two elements: [x,y]");r.push(Object.freeze({x:e[0],y:e[1]}))}return r},xt=function(e,r){return N(e,"a"),N(r,"b"),{x:e.x-r.x,y:e.y-r.y}},un=function(e,r,n,i){let s,o;if(O(e))if(s=e,r===void 0&&(r=xe),O(r))o=r;else{if(r===void 0)throw new Error("Expects x coordinate");o={x:r,y:n===void 0?0:n}}else if(!O(r)){if(r===void 0)throw new Error("Expected number as second param");if(s={x:e,y:r},n===void 0)throw new Error("Expects x coordiante");o={x:n,y:i===void 0?0:i}}if(s===void 0)throw new Error("ptA missing");if(o===void 0)throw new Error("ptB missing");return N(s,"a"),N(o,"b"),{x:s.x+o.x,y:s.y+o.y}};function fn(e,r,n){if(N(e,"a"),typeof r=="number")return typeof n>"u"&&(n=1),{x:e.x*r,y:e.y*n};if(O(r))return N(r,"b"),{x:e.x*r.x,y:e.y*r.y};throw new Error("Invalid arguments")}var vt=e=>e.startRadian!==void 0&&e.endRadian!==void 0,D=e=>e.x!==void 0&&e.y!==void 0,Ke=Math.PI*2;function cn(e,r,n,i){const s={radius:e,startRadian:X(r),endRadian:X(n)};if(O(i)){N(i);const o={...s,x:i.x,y:i.y};return Object.freeze(o)}else return Object.freeze(s)}var mt=e=>J.fromPoints(ve(e,e.startRadian),ve(e,e.endRadian)),ve=(e,r,n)=>{if(r>e.endRadian)throw new Error("angleRadian beyond end angle of arc");if(r<e.startRadian)throw new Error("angleRadian beyond start angle of arc");return n===void 0&&(D(e)?n=e:n={x:0,y:0}),{x:Math.cos(r)*e.radius+n.x,y:Math.sin(r)*e.radius+n.y}},Re=e=>{if(e===void 0)throw new Error("Arc is undefined");if(D(e)&&N(e,"arc"),e.radius===void 0)throw new Error(`Arc radius is undefined (${JSON.stringify(e)})`);if(typeof e.radius!="number")throw new Error("Radius must be a number");if(Number.isNaN(e.radius))throw new Error("Radius is NaN");if(e.radius<=0)throw new Error("Radius must be greater than zero");if(e.startRadian===void 0)throw new Error("Arc is missing 'startRadian' field");if(e.endRadian===void 0)throw new Error("Arc is missing 'startRadian' field");if(Number.isNaN(e.endRadian))throw new Error("Arc endRadian is NaN");if(Number.isNaN(e.startRadian))throw new Error("Arc endRadian is NaN");if(e.startRadian>=e.endRadian)throw new Error("startRadian is expected to be les than endRadian")},ke=(e,r,n)=>(Re(r),ve(r,r.startRadian+(r.endRadian-r.startRadian)*e,n)),ln=e=>(Re(e),Object.freeze({...e,interpolate:r=>ke(r,e),bbox:()=>wt(e),length:()=>pt(e),toSvgString:()=>gt(e),kind:"arc"})),pt=e=>Ke*e.radius*((e.startRadian-e.endRadian)/Ke),wt=e=>{if(D(e)){const r=ke(.5,e),n=mt(e);return $.bbox(r,n.a,n.b)}else return{width:e.radius*2,height:e.radius*2}},gt=(e,r,n,i,s)=>{if(vt(e))return D(e)?he(e,e.radius,e.startRadian,e.endRadian,r):O(r)?he(r,e.radius,e.startRadian,e.endRadian,n):he({x:0,y:0},e.radius,e.startRadian,e.endRadian);if(n===void 0)throw new Error("startAngle undefined");if(i===void 0)throw new Error("endAngle undefined");if(O(e)){if(typeof r=="number"&&typeof n=="number"&&typeof i=="number")return he(e,r,n,i,s);throw new Error("Expected (point, number, number, number). Missing a number param.")}else throw new Error("Expected (point, number, number, number). Missing first point.")},he=(e,r,n,i,s)=>{(s===void 0||typeof s!="object")&&(s={});const o=i-n===360,a=me.toCartesian(r,i-.01,e),u=me.toCartesian(r,n,e),{largeArc:f=!1,sweep:l=!1}=s,c=[`
    M ${a.x} ${a.y}
    A ${r} ${r} 0 ${f?"1":"0"} ${l?"1":"0"} ${u.x} ${u.y},
  `];return o&&c.push("z"),c},hn=(e,r)=>$.distance(e,r),yn=(e,r)=>e.radius!==r.radius?!1:D(e)&&D(r)?!(e.x!==r.x||e.y!==r.y||e.z!==r.z):!(!(!D(e)&&!D(r))||e.endRadian!==r.endRadian||e.startRadian!==r.startRadian),be={};_(be,{computeQuadraticSimple:()=>zn,cubic:()=>Nn,isCubicBezier:()=>Et,isQuadraticBezier:()=>zt,quadratic:()=>Mt,quadraticBend:()=>bn,quadraticSimple:()=>je,quadraticToSvgString:()=>Nt,toPath:()=>En});var{abs:ne,cos:L,sin:H,acos:dn,atan2:ie,sqrt:B,pow:R}=Math;function se(e){return e<0?-R(-e,1/3):R(e,1/3)}var bt=Math.PI,ye=2*bt,U=bt/2,xn=1e-6,Ee=Number.MAX_SAFE_INTEGER||9007199254740991,Ne=Number.MIN_SAFE_INTEGER||-9007199254740991,vn={x:0,y:0,z:0},y={Tvalues:[-.06405689286260563,.06405689286260563,-.1911188674736163,.1911188674736163,-.3150426796961634,.3150426796961634,-.4337935076260451,.4337935076260451,-.5454214713888396,.5454214713888396,-.6480936519369755,.6480936519369755,-.7401241915785544,.7401241915785544,-.820001985973903,.820001985973903,-.8864155270044011,.8864155270044011,-.9382745520027328,.9382745520027328,-.9747285559713095,.9747285559713095,-.9951872199970213,.9951872199970213],Cvalues:[.12793819534675216,.12793819534675216,.1258374563468283,.1258374563468283,.12167047292780339,.12167047292780339,.1155056680537256,.1155056680537256,.10744427011596563,.10744427011596563,.09761865210411388,.09761865210411388,.08619016153195327,.08619016153195327,.0733464814110803,.0733464814110803,.05929858491543678,.05929858491543678,.04427743881741981,.04427743881741981,.028531388628933663,.028531388628933663,.0123412297999872,.0123412297999872],arcfn:function(e,r){const n=r(e);let i=n.x*n.x+n.y*n.y;return typeof n.z<"u"&&(i+=n.z*n.z),B(i)},compute:function(e,r,n){if(e===0)return r[0].t=0,r[0];const i=r.length-1;if(e===1)return r[i].t=1,r[i];const s=1-e;let o=r;if(i===0)return r[0].t=e,r[0];if(i===1){const u={x:s*o[0].x+e*o[1].x,y:s*o[0].y+e*o[1].y,t:e};return n&&(u.z=s*o[0].z+e*o[1].z),u}if(i<4){let u=s*s,f=e*e,l,c,h,d=0;i===2?(o=[o[0],o[1],o[2],vn],l=u,c=s*e*2,h=f):i===3&&(l=u*s,c=u*e*3,h=s*f*3,d=e*f);const v={x:l*o[0].x+c*o[1].x+h*o[2].x+d*o[3].x,y:l*o[0].y+c*o[1].y+h*o[2].y+d*o[3].y,t:e};return n&&(v.z=l*o[0].z+c*o[1].z+h*o[2].z+d*o[3].z),v}const a=JSON.parse(JSON.stringify(r));for(;a.length>1;){for(let u=0;u<a.length-1;u++)a[u]={x:a[u].x+(a[u+1].x-a[u].x)*e,y:a[u].y+(a[u+1].y-a[u].y)*e},typeof a[u].z<"u"&&(a[u]=a[u].z+(a[u+1].z-a[u].z)*e);a.splice(a.length-1,1)}return a[0].t=e,a[0]},computeWithRatios:function(e,r,n,i){const s=1-e,o=n,a=r;let u=o[0],f=o[1],l=o[2],c=o[3],h;if(u*=s,f*=e,a.length===2)return h=u+f,{x:(u*a[0].x+f*a[1].x)/h,y:(u*a[0].y+f*a[1].y)/h,z:i?(u*a[0].z+f*a[1].z)/h:!1,t:e};if(u*=s,f*=2*s,l*=e*e,a.length===3)return h=u+f+l,{x:(u*a[0].x+f*a[1].x+l*a[2].x)/h,y:(u*a[0].y+f*a[1].y+l*a[2].y)/h,z:i?(u*a[0].z+f*a[1].z+l*a[2].z)/h:!1,t:e};if(u*=s,f*=1.5*s,l*=3*s,c*=e*e*e,a.length===4)return h=u+f+l+c,{x:(u*a[0].x+f*a[1].x+l*a[2].x+c*a[3].x)/h,y:(u*a[0].y+f*a[1].y+l*a[2].y+c*a[3].y)/h,z:i?(u*a[0].z+f*a[1].z+l*a[2].z+c*a[3].z)/h:!1,t:e}},derive:function(e,r){const n=[];for(let i=e,s=i.length,o=s-1;s>1;s--,o--){const a=[];for(let u=0,f;u<o;u++)f={x:o*(i[u+1].x-i[u].x),y:o*(i[u+1].y-i[u].y)},r&&(f.z=o*(i[u+1].z-i[u].z)),a.push(f);n.push(a),i=a}return n},between:function(e,r,n){return r<=e&&e<=n||y.approximately(e,r)||y.approximately(e,n)},approximately:function(e,r,n){return ne(e-r)<=(n||xn)},length:function(e){const n=y.Tvalues.length;let i=0;for(let s=0,o;s<n;s++)o=.5*y.Tvalues[s]+.5,i+=y.Cvalues[s]*y.arcfn(o,e);return .5*i},map:function(e,r,n,i,s){const o=n-r,a=s-i,u=e-r,f=u/o;return i+a*f},lerp:function(e,r,n){const i={x:r.x+e*(n.x-r.x),y:r.y+e*(n.y-r.y)};return r.z!==void 0&&n.z!==void 0&&(i.z=r.z+e*(n.z-r.z)),i},pointToString:function(e){let r=e.x+"/"+e.y;return typeof e.z<"u"&&(r+="/"+e.z),r},pointsToString:function(e){return"["+e.map(y.pointToString).join(", ")+"]"},copy:function(e){return JSON.parse(JSON.stringify(e))},angle:function(e,r,n){const i=r.x-e.x,s=r.y-e.y,o=n.x-e.x,a=n.y-e.y,u=i*a-s*o,f=i*o+s*a;return ie(u,f)},round:function(e,r){const n=""+e,i=n.indexOf(".");return parseFloat(n.substring(0,i+1+r))},dist:function(e,r){const n=e.x-r.x,i=e.y-r.y;return B(n*n+i*i)},closest:function(e,r){let n=R(2,63),i,s;return e.forEach(function(o,a){s=y.dist(r,o),s<n&&(n=s,i=a)}),{mdist:n,mpos:i}},abcratio:function(e,r){if(r!==2&&r!==3)return!1;if(typeof e>"u")e=.5;else if(e===0||e===1)return e;const n=R(e,r)+R(1-e,r),i=n-1;return ne(i/n)},projectionratio:function(e,r){if(r!==2&&r!==3)return!1;if(typeof e>"u")e=.5;else if(e===0||e===1)return e;const n=R(1-e,r),i=R(e,r)+n;return n/i},lli8:function(e,r,n,i,s,o,a,u){const f=(e*i-r*n)*(s-a)-(e-n)*(s*u-o*a),l=(e*i-r*n)*(o-u)-(r-i)*(s*u-o*a),c=(e-n)*(o-u)-(r-i)*(s-a);return c==0?!1:{x:f/c,y:l/c}},lli4:function(e,r,n,i){const s=e.x,o=e.y,a=r.x,u=r.y,f=n.x,l=n.y,c=i.x,h=i.y;return y.lli8(s,o,a,u,f,l,c,h)},lli:function(e,r){return y.lli4(e,e.c,r,r.c)},makeline:function(e,r){return new w(e.x,e.y,(e.x+r.x)/2,(e.y+r.y)/2,r.x,r.y)},findbbox:function(e){let r=Ee,n=Ee,i=Ne,s=Ne;return e.forEach(function(o){const a=o.bbox();r>a.x.min&&(r=a.x.min),n>a.y.min&&(n=a.y.min),i<a.x.max&&(i=a.x.max),s<a.y.max&&(s=a.y.max)}),{x:{min:r,mid:(r+i)/2,max:i,size:i-r},y:{min:n,mid:(n+s)/2,max:s,size:s-n}}},shapeintersections:function(e,r,n,i,s){if(!y.bboxoverlap(r,i))return[];const o=[],a=[e.startcap,e.forward,e.back,e.endcap],u=[n.startcap,n.forward,n.back,n.endcap];return a.forEach(function(f){f.virtual||u.forEach(function(l){if(l.virtual)return;const c=f.intersects(l,s);c.length>0&&(c.c1=f,c.c2=l,c.s1=e,c.s2=n,o.push(c))})}),o},makeshape:function(e,r,n){const i=r.points.length,s=e.points.length,o=y.makeline(r.points[i-1],e.points[0]),a=y.makeline(e.points[s-1],r.points[0]),u={startcap:o,forward:e,back:r,endcap:a,bbox:y.findbbox([o,e,r,a])};return u.intersections=function(f){return y.shapeintersections(u,u.bbox,f,f.bbox,n)},u},getminmax:function(e,r,n){if(!n)return{min:0,max:0};let i=Ee,s=Ne,o,a;n.indexOf(0)===-1&&(n=[0].concat(n)),n.indexOf(1)===-1&&n.push(1);for(let u=0,f=n.length;u<f;u++)o=n[u],a=e.get(o),a[r]<i&&(i=a[r]),a[r]>s&&(s=a[r]);return{min:i,mid:(i+s)/2,max:s,size:s-i}},align:function(e,r){const n=r.p1.x,i=r.p1.y,s=-ie(r.p2.y-i,r.p2.x-n),o=function(a){return{x:(a.x-n)*L(s)-(a.y-i)*H(s),y:(a.x-n)*H(s)+(a.y-i)*L(s)}};return e.map(o)},roots:function(e,r){r=r||{p1:{x:0,y:0},p2:{x:1,y:0}};const n=e.length-1,i=y.align(e,r),s=function(x){return 0<=x&&x<=1};if(n===2){const x=i[0].y,b=i[1].y,M=i[2].y,A=x-2*b+M;if(A!==0){const I=-B(b*b-x*M),k=-x+b,te=-(I+k)/A,G=-(-I+k)/A;return[te,G].filter(s)}else if(b!==M&&A===0)return[(2*b-M)/(2*b-2*M)].filter(s);return[]}const o=i[0].y,a=i[1].y,u=i[2].y,f=i[3].y;let l=-o+3*a-3*u+f,c=3*o-6*a+3*u,h=-3*o+3*a,d=o;if(y.approximately(l,0)){if(y.approximately(c,0))return y.approximately(h,0)?[]:[-d/h].filter(s);const x=B(h*h-4*c*d),b=2*c;return[(x-h)/b,(-h-x)/b].filter(s)}c/=l,h/=l,d/=l;const v=(3*h-c*c)/3,g=v/3,q=(2*c*c*c-9*c*h+27*d)/27,z=q/2,j=z*z+g*g*g;let C,S,m,p,P;if(j<0){const x=-v/3,b=x*x*x,M=B(b),A=-q/(2*M),I=A<-1?-1:A>1?1:A,k=dn(I),te=se(M),G=2*te;return m=G*L(k/3)-c/3,p=G*L((k+ye)/3)-c/3,P=G*L((k+2*ye)/3)-c/3,[m,p,P].filter(s)}else{if(j===0)return C=z<0?se(-z):-se(z),m=2*C-c/3,p=-C-c/3,[m,p].filter(s);{const x=B(j);return C=se(-z+x),S=se(z+x),[C-S-c/3].filter(s)}}},droots:function(e){if(e.length===3){const r=e[0],n=e[1],i=e[2],s=r-2*n+i;if(s!==0){const o=-B(n*n-r*i),a=-r+n,u=-(o+a)/s,f=-(-o+a)/s;return[u,f]}else if(n!==i&&s===0)return[(2*n-i)/(2*(n-i))];return[]}if(e.length===2){const r=e[0],n=e[1];return r!==n?[r/(r-n)]:[]}return[]},curvature:function(e,r,n,i,s){let o,a,u,f,l=0,c=0;const h=y.compute(e,r),d=y.compute(e,n),v=h.x*h.x+h.y*h.y;if(i?(o=B(R(h.y*d.z-d.y*h.z,2)+R(h.z*d.x-d.z*h.x,2)+R(h.x*d.y-d.x*h.y,2)),a=R(v+h.z*h.z,3/2)):(o=h.x*d.y-h.y*d.x,a=R(v,3/2)),o===0||a===0)return{k:0,r:0};if(l=o/a,c=a/o,!s){const g=y.curvature(e-.001,r,n,i,!0).k,q=y.curvature(e+.001,r,n,i,!0).k;f=(q-l+(l-g))/2,u=(ne(q-l)+ne(l-g))/2}return{k:l,r:c,dk:f,adk:u}},inflections:function(e){if(e.length<4)return[];const r=y.align(e,{p1:e[0],p2:e.slice(-1)[0]}),n=r[2].x*r[1].y,i=r[3].x*r[1].y,s=r[1].x*r[2].y,o=r[3].x*r[2].y,a=18*(-3*n+2*i+3*s-o),u=18*(3*n-i-3*s),f=18*(s-n);if(y.approximately(a,0)){if(!y.approximately(u,0)){let d=-f/u;if(0<=d&&d<=1)return[d]}return[]}const l=u*u-4*a*f,c=Math.sqrt(l),h=2*a;return y.approximately(h,0)?[]:[(c-u)/h,-(u+c)/h].filter(function(d){return 0<=d&&d<=1})},bboxoverlap:function(e,r){const n=["x","y"],i=n.length;for(let s=0,o,a,u,f;s<i;s++)if(o=n[s],a=e[o].mid,u=r[o].mid,f=(e[o].size+r[o].size)/2,ne(a-u)>=f)return!1;return!0},expandbox:function(e,r){r.x.min<e.x.min&&(e.x.min=r.x.min),r.y.min<e.y.min&&(e.y.min=r.y.min),r.z&&r.z.min<e.z.min&&(e.z.min=r.z.min),r.x.max>e.x.max&&(e.x.max=r.x.max),r.y.max>e.y.max&&(e.y.max=r.y.max),r.z&&r.z.max>e.z.max&&(e.z.max=r.z.max),e.x.mid=(e.x.min+e.x.max)/2,e.y.mid=(e.y.min+e.y.max)/2,e.z&&(e.z.mid=(e.z.min+e.z.max)/2),e.x.size=e.x.max-e.x.min,e.y.size=e.y.max-e.y.min,e.z&&(e.z.size=e.z.max-e.z.min)},pairiteration:function(e,r,n){const i=e.bbox(),s=r.bbox(),o=1e5,a=n||.5;if(i.x.size+i.y.size<a&&s.x.size+s.y.size<a)return[(o*(e._t1+e._t2)/2|0)/o+"/"+(o*(r._t1+r._t2)/2|0)/o];let u=e.split(.5),f=r.split(.5),l=[{left:u.left,right:f.left},{left:u.left,right:f.right},{left:u.right,right:f.right},{left:u.right,right:f.left}];l=l.filter(function(h){return y.bboxoverlap(h.left.bbox(),h.right.bbox())});let c=[];return l.length===0||(l.forEach(function(h){c=c.concat(y.pairiteration(h.left,h.right,a))}),c=c.filter(function(h,d){return c.indexOf(h)===d})),c},getccenter:function(e,r,n){const i=r.x-e.x,s=r.y-e.y,o=n.x-r.x,a=n.y-r.y,u=i*L(U)-s*H(U),f=i*H(U)+s*L(U),l=o*L(U)-a*H(U),c=o*H(U)+a*L(U),h=(e.x+r.x)/2,d=(e.y+r.y)/2,v=(r.x+n.x)/2,g=(r.y+n.y)/2,q=h+u,z=d+f,j=v+l,C=g+c,S=y.lli8(h,d,q,z,v,g,j,C),m=y.dist(S,e);let p=ie(e.y-S.y,e.x-S.x),P=ie(r.y-S.y,r.x-S.x),x=ie(n.y-S.y,n.x-S.x),b;return p<x?((p>P||P>x)&&(p+=ye),p>x&&(b=x,x=p,p=b)):x<P&&P<p?(b=x,x=p,p=b):x+=ye,S.s=p,S.e=x,S.r=m,S},numberSort:function(e,r){return e-r}},de=class{constructor(e){this.curves=[],this._3d=!1,e&&(this.curves=e,this._3d=this.curves[0]._3d)}valueOf(){return this.toString()}toString(){return"["+this.curves.map(function(e){return y.pointsToString(e.points)}).join(", ")+"]"}addCurve(e){this.curves.push(e),this._3d=this._3d||e._3d}length(){return this.curves.map(function(e){return e.length()}).reduce(function(e,r){return e+r})}curve(e){return this.curves[e]}bbox(){const e=this.curves;for(var r=e[0].bbox(),n=1;n<e.length;n++)y.expandbox(r,e[n].bbox());return r}offset(e){const r=[];return this.curves.forEach(function(n){r.push(...n.offset(e))}),new de(r)}},{abs:oe,min:Qe,max:We,cos:mn,sin:pn,acos:wn,sqrt:ae}=Math,gn=Math.PI,w=class{constructor(e){let r=e&&e.forEach?e:Array.from(arguments).slice(),n=!1;if(typeof r[0]=="object"){n=r.length;const d=[];r.forEach(function(v){["x","y","z"].forEach(function(g){typeof v[g]<"u"&&d.push(v[g])})}),r=d}let i=!1;const s=r.length;if(n){if(n>4){if(arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");i=!0}}else if(s!==6&&s!==8&&s!==9&&s!==12&&arguments.length!==1)throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");const o=this._3d=!i&&(s===9||s===12)||e&&e[0]&&typeof e[0].z<"u",a=this.points=[];for(let d=0,v=o?3:2;d<s;d+=v){var u={x:r[d],y:r[d+1]};o&&(u.z=r[d+2]),a.push(u)}const f=this.order=a.length-1,l=this.dims=["x","y"];o&&l.push("z"),this.dimlen=l.length;const c=y.align(a,{p1:a[0],p2:a[f]}),h=y.dist(a[0],a[f]);this._linear=c.reduce((d,v)=>d+oe(v.y),0)<h/50,this._lut=[],this._t1=0,this._t2=1,this.update()}static quadraticFromPoints(e,r,n,i){if(typeof i>"u"&&(i=.5),i===0)return new w(r,r,n);if(i===1)return new w(e,r,r);const s=w.getABC(2,e,r,n,i);return new w(e,s.A,n)}static cubicFromPoints(e,r,n,i,s){typeof i>"u"&&(i=.5);const o=w.getABC(3,e,r,n,i);typeof s>"u"&&(s=y.dist(r,o.C));const a=s*(1-i)/i,u=y.dist(e,n),f=(n.x-e.x)/u,l=(n.y-e.y)/u,c=s*f,h=s*l,d=a*f,v=a*l,g={x:r.x-c,y:r.y-h},q={x:r.x+d,y:r.y+v},z=o.A,j={x:z.x+(g.x-z.x)/(1-i),y:z.y+(g.y-z.y)/(1-i)},C={x:z.x+(q.x-z.x)/i,y:z.y+(q.y-z.y)/i},S={x:e.x+(j.x-e.x)/i,y:e.y+(j.y-e.y)/i},m={x:n.x+(C.x-n.x)/(1-i),y:n.y+(C.y-n.y)/(1-i)};return new w(e,S,m,n)}static getUtils(){return y}getUtils(){return w.getUtils()}static get PolyBezier(){return de}valueOf(){return this.toString()}toString(){return y.pointsToString(this.points)}toSVG(){if(this._3d)return!1;const e=this.points,r=e[0].x,n=e[0].y,i=["M",r,n,this.order===2?"Q":"C"];for(let s=1,o=e.length;s<o;s++)i.push(e[s].x),i.push(e[s].y);return i.join(" ")}setRatios(e){if(e.length!==this.points.length)throw new Error("incorrect number of ratio values");this.ratios=e,this._lut=[]}verify(){const e=this.coordDigest();e!==this._print&&(this._print=e,this.update())}coordDigest(){return this.points.map(function(e,r){return""+r+e.x+e.y+(e.z?e.z:0)}).join("")}update(){this._lut=[],this.dpoints=y.derive(this.points,this._3d),this.computedirection()}computedirection(){const e=this.points,r=y.angle(e[0],e[this.order],e[1]);this.clockwise=r>0}length(){return y.length(this.derivative.bind(this))}static getABC(e=2,r,n,i,s=.5){const o=y.projectionratio(s,e),a=1-o,u={x:o*r.x+a*i.x,y:o*r.y+a*i.y},f=y.abcratio(s,e);return{A:{x:n.x+(n.x-u.x)/f,y:n.y+(n.y-u.y)/f},B:n,C:u,S:r,E:i}}getABC(e,r){r=r||this.get(e);let n=this.points[0],i=this.points[this.order];return w.getABC(this.order,n,r,i,e)}getLUT(e){if(this.verify(),e=e||100,this._lut.length===e)return this._lut;this._lut=[],e++,this._lut=[];for(let r=0,n,i;r<e;r++)i=r/(e-1),n=this.compute(i),n.t=i,this._lut.push(n);return this._lut}on(e,r){r=r||5;const n=this.getLUT(),i=[];for(let s=0,o,a=0;s<n.length;s++)o=n[s],y.dist(o,e)<r&&(i.push(o),a+=s/n.length);return i.length?t/=i.length:!1}project(e){const r=this.getLUT(),n=r.length-1,i=y.closest(r,e),s=i.mpos,o=(s-1)/n,a=(s+1)/n,u=.1/n;let f=i.mdist,l=o,c=l,h;f+=1;for(let d;l<a+u;l+=u)h=this.compute(l),d=y.dist(e,h),d<f&&(f=d,c=l);return c=c<0?0:c>1?1:c,h=this.compute(c),h.t=c,h.d=f,h}get(e){return this.compute(e)}point(e){return this.points[e]}compute(e){return this.ratios?y.computeWithRatios(e,this.points,this.ratios,this._3d):y.compute(e,this.points,this._3d,this.ratios)}raise(){const e=this.points,r=[e[0]],n=e.length;for(let i=1,s,o;i<n;i++)s=e[i],o=e[i-1],r[i]={x:(n-i)/n*s.x+i/n*o.x,y:(n-i)/n*s.y+i/n*o.y};return r[n]=e[n-1],new w(r)}derivative(e){return y.compute(e,this.dpoints[0],this._3d)}dderivative(e){return y.compute(e,this.dpoints[1],this._3d)}align(){let e=this.points;return new w(y.align(e,{p1:e[0],p2:e[e.length-1]}))}curvature(e){return y.curvature(e,this.dpoints[0],this.dpoints[1],this._3d)}inflections(){return y.inflections(this.points)}normal(e){return this._3d?this.__normal3(e):this.__normal2(e)}__normal2(e){const r=this.derivative(e),n=ae(r.x*r.x+r.y*r.y);return{x:-r.y/n,y:r.x/n}}__normal3(e){const r=this.derivative(e),n=this.derivative(e+.01),i=ae(r.x*r.x+r.y*r.y+r.z*r.z),s=ae(n.x*n.x+n.y*n.y+n.z*n.z);r.x/=i,r.y/=i,r.z/=i,n.x/=s,n.y/=s,n.z/=s;const o={x:n.y*r.z-n.z*r.y,y:n.z*r.x-n.x*r.z,z:n.x*r.y-n.y*r.x},a=ae(o.x*o.x+o.y*o.y+o.z*o.z);o.x/=a,o.y/=a,o.z/=a;const u=[o.x*o.x,o.x*o.y-o.z,o.x*o.z+o.y,o.x*o.y+o.z,o.y*o.y,o.y*o.z-o.x,o.x*o.z-o.y,o.y*o.z+o.x,o.z*o.z];return{x:u[0]*r.x+u[1]*r.y+u[2]*r.z,y:u[3]*r.x+u[4]*r.y+u[5]*r.z,z:u[6]*r.x+u[7]*r.y+u[8]*r.z}}hull(e){let r=this.points,n=[],i=[],s=0;for(i[s++]=r[0],i[s++]=r[1],i[s++]=r[2],this.order===3&&(i[s++]=r[3]);r.length>1;){n=[];for(let o=0,a,u=r.length-1;o<u;o++)a=y.lerp(e,r[o],r[o+1]),i[s++]=a,n.push(a);r=n}return i}split(e,r){if(e===0&&!!r)return this.split(r).left;if(r===1)return this.split(e).right;const n=this.hull(e),i={left:this.order===2?new w([n[0],n[3],n[5]]):new w([n[0],n[4],n[7],n[9]]),right:this.order===2?new w([n[5],n[4],n[2]]):new w([n[9],n[8],n[6],n[3]]),span:n};return i.left._t1=y.map(0,0,1,this._t1,this._t2),i.left._t2=y.map(e,0,1,this._t1,this._t2),i.right._t1=y.map(e,0,1,this._t1,this._t2),i.right._t2=y.map(1,0,1,this._t1,this._t2),r?(r=y.map(r,e,1,0,1),i.right.split(r).left):i}extrema(){const e={};let r=[];return this.dims.forEach(function(n){let i=function(o){return o[n]},s=this.dpoints[0].map(i);e[n]=y.droots(s),this.order===3&&(s=this.dpoints[1].map(i),e[n]=e[n].concat(y.droots(s))),e[n]=e[n].filter(function(o){return o>=0&&o<=1}),r=r.concat(e[n].sort(y.numberSort))}.bind(this)),e.values=r.sort(y.numberSort).filter(function(n,i){return r.indexOf(n)===i}),e}bbox(){const e=this.extrema(),r={};return this.dims.forEach(function(n){r[n]=y.getminmax(this,n,e[n])}.bind(this)),r}overlaps(e){const r=this.bbox(),n=e.bbox();return y.bboxoverlap(r,n)}offset(e,r){if(typeof r<"u"){const n=this.get(e),i=this.normal(e),s={c:n,n:i,x:n.x+i.x*r,y:n.y+i.y*r};return this._3d&&(s.z=n.z+i.z*r),s}if(this._linear){const n=this.normal(0),i=this.points.map(function(s){const o={x:s.x+e*n.x,y:s.y+e*n.y};return s.z&&n.z&&(o.z=s.z+e*n.z),o});return[new w(i)]}return this.reduce().map(function(n){return n._linear?n.offset(e)[0]:n.scale(e)})}simple(){if(this.order===3){const i=y.angle(this.points[0],this.points[3],this.points[1]),s=y.angle(this.points[0],this.points[3],this.points[2]);if(i>0&&s<0||i<0&&s>0)return!1}const e=this.normal(0),r=this.normal(1);let n=e.x*r.x+e.y*r.y;return this._3d&&(n+=e.z*r.z),oe(wn(n))<gn/3}reduce(){let e,r=0,n=0,i=.01,s,o=[],a=[],u=this.extrema().values;for(u.indexOf(0)===-1&&(u=[0].concat(u)),u.indexOf(1)===-1&&u.push(1),r=u[0],e=1;e<u.length;e++)n=u[e],s=this.split(r,n),s._t1=r,s._t2=n,o.push(s),r=n;return o.forEach(function(f){for(r=0,n=0;n<=1;)for(n=r+i;n<=1+i;n+=i)if(s=f.split(r,n),!s.simple()){if(n-=i,oe(r-n)<i)return[];s=f.split(r,n),s._t1=y.map(r,0,1,f._t1,f._t2),s._t2=y.map(n,0,1,f._t1,f._t2),a.push(s),r=n;break}r<1&&(s=f.split(r,1),s._t1=y.map(r,0,1,f._t1,f._t2),s._t2=f._t2,a.push(s))}),a}translate(e,r,n){n=typeof n=="number"?n:r;const i=this.order;let s=this.points.map((o,a)=>(1-a/i)*r+a/i*n);return new w(this.points.map((o,a)=>({x:o.x+e.x*s[a],y:o.y+e.y*s[a]})))}scale(e){const r=this.order;let n=!1;if(typeof e=="function"&&(n=e),n&&r===2)return this.raise().scale(n);const i=this.clockwise,s=this.points;if(this._linear)return this.translate(this.normal(0),n?n(0):e,n?n(1):e);const o=n?n(0):e,a=n?n(1):e,u=[this.offset(0,10),this.offset(1,10)],f=[],l=y.lli4(u[0],u[0].c,u[1],u[1].c);if(!l)throw new Error("cannot scale this curve. Try reducing it first.");return[0,1].forEach(function(c){const h=f[c*r]=y.copy(s[c*r]);h.x+=(c?a:o)*u[c].n.x,h.y+=(c?a:o)*u[c].n.y}),n?([0,1].forEach(function(c){if(!(r===2&&!!c)){var h=s[c+1],d={x:h.x-l.x,y:h.y-l.y},v=n?n((c+1)/r):e;n&&!i&&(v=-v);var g=ae(d.x*d.x+d.y*d.y);d.x/=g,d.y/=g,f[c+1]={x:h.x+v*d.x,y:h.y+v*d.y}}}),new w(f)):([0,1].forEach(c=>{if(r===2&&!!c)return;const h=f[c*r],d=this.derivative(c),v={x:h.x+d.x,y:h.y+d.y};f[c+1]=y.lli4(h,v,l,s[c+1])}),new w(f))}outline(e,r,n,i){if(r=r===void 0?e:r,this._linear){const m=this.normal(0),p=this.points[0],P=this.points[this.points.length-1];let x,b,M;n===void 0&&(n=e,i=r),x={x:p.x+m.x*e,y:p.y+m.y*e},M={x:P.x+m.x*n,y:P.y+m.y*n},b={x:(x.x+M.x)/2,y:(x.y+M.y)/2};const A=[x,b,M];x={x:p.x-m.x*r,y:p.y-m.y*r},M={x:P.x-m.x*i,y:P.y-m.y*i},b={x:(x.x+M.x)/2,y:(x.y+M.y)/2};const I=[M,b,x],k=y.makeline(I[2],A[0]),te=y.makeline(A[2],I[0]),G=[k,new w(A),te,new w(I)];return new de(G)}const s=this.reduce(),o=s.length,a=[];let u=[],f,l=0,c=this.length();const h=typeof n<"u"&&typeof i<"u";function d(m,p,P,x,b){return function(M){const A=x/P,I=(x+b)/P,k=p-m;return y.map(M,0,1,m+A*k,m+I*k)}}s.forEach(function(m){const p=m.length();h?(a.push(m.scale(d(e,n,c,l,p))),u.push(m.scale(d(-r,-i,c,l,p)))):(a.push(m.scale(e)),u.push(m.scale(-r))),l+=p}),u=u.map(function(m){return f=m.points,f[3]?m.points=[f[3],f[2],f[1],f[0]]:m.points=[f[2],f[1],f[0]],m}).reverse();const v=a[0].points[0],g=a[o-1].points[a[o-1].points.length-1],q=u[o-1].points[u[o-1].points.length-1],z=u[0].points[0],j=y.makeline(q,v),C=y.makeline(g,z),S=[j].concat(a).concat([C]).concat(u);return new de(S)}outlineshapes(e,r,n){r=r||e;const i=this.outline(e,r).curves,s=[];for(let o=1,a=i.length;o<a/2;o++){const u=y.makeshape(i[o],i[a-o],n);u.startcap.virtual=o>1,u.endcap.virtual=o<a/2-1,s.push(u)}return s}intersects(e,r){return e?e.p1&&e.p2?this.lineIntersects(e):(e instanceof w&&(e=e.reduce()),this.curveintersects(this.reduce(),e,r)):this.selfintersects(r)}lineIntersects(e){const r=Qe(e.p1.x,e.p2.x),n=Qe(e.p1.y,e.p2.y),i=We(e.p1.x,e.p2.x),s=We(e.p1.y,e.p2.y);return y.roots(this.points,e).filter(o=>{var a=this.get(o);return y.between(a.x,r,i)&&y.between(a.y,n,s)})}selfintersects(e){const r=this.reduce(),n=r.length-2,i=[];for(let s=0,o,a,u;s<n;s++)a=r.slice(s,s+1),u=r.slice(s+2),o=this.curveintersects(a,u,e),i.push(...o);return i}curveintersects(e,r,n){const i=[];e.forEach(function(o){r.forEach(function(a){o.overlaps(a)&&i.push({left:o,right:a})})});let s=[];return i.forEach(function(o){const a=y.pairiteration(o.left,o.right,n);a.length>0&&(s=s.concat(a))}),s}arcs(e){return e=e||.5,this._iterate(e,[])}_error(e,r,n,i){const s=(i-n)/4,o=this.get(n+s),a=this.get(i-s),u=y.dist(e,r),f=y.dist(e,o),l=y.dist(e,a);return oe(f-u)+oe(l-u)}_iterate(e,r){let n=0,i=1,s;do{s=0,i=1;let o=this.get(n),a,u,f,l,c=!1,h=!1,d,v=i,g=1;do if(h=c,l=f,v=(n+i)/2,a=this.get(v),u=this.get(i),f=y.getccenter(o,a,u),f.interval={start:n,end:i},c=this._error(f,o,n,i)<=e,d=h&&!c,d||(g=i),c){if(i>=1){if(f.interval.end=g=1,l=f,i>1){let z={x:f.x+f.r*mn(f.e),y:f.y+f.r*pn(f.e)};f.e+=y.angle({x:f.x,y:f.y},z,this.get(1))}break}i=i+(i-n)/2}else i=v;while(!d&&s++<100);if(s>=100)break;l=l||f,r.push(l),n=g}while(i<1);return r}},zt=e=>e.quadratic!==void 0,Et=e=>e.cubic1!==void 0&&e.cubic2!==void 0,bn=(e,r,n=0)=>je(e,r,n),je=(e,r,n=0)=>{if(isNaN(n))throw Error("bend is NaN");if(n<-1||n>1)throw Error("Expects bend range of -1 to 1");const i=J.interpolate(.5,e,r);let s=i;r.y<e.y?s=n>0?{x:Math.min(e.x,r.x),y:Math.min(e.y,r.y)}:{x:Math.max(e.x,r.x),y:Math.max(e.y,r.y)}:s=n>0?{x:Math.max(e.x,r.x),y:Math.min(e.y,r.y)}:{x:Math.min(e.x,r.x),y:Math.max(e.y,r.y)};const o=J.interpolate(Math.abs(n),i,s);return Mt(e,r,o)},zn=(e,r,n,i)=>{const s=je(e,r,n);return new w(s.a,s.quadratic,s.b).compute(i)},Nt=(e,r,n)=>[`M ${e.x} ${e.y} Q ${n.x} ${n.y} ${r.x} ${r.y}`],En=e=>{if(Et(e))return Mn(e);if(zt(e))return Sn(e);throw new Error("Unknown bezier type")},Nn=(e,r,n,i)=>({a:Object.freeze(e),b:Object.freeze(r),cubic1:Object.freeze(n),cubic2:Object.freeze(i)}),Mn=e=>{const{a:r,cubic1:n,cubic2:i,b:s}=e,o=new w(r,n,i,s);return Object.freeze({...e,length:()=>o.length(),interpolate:a=>o.compute(a),bbox:()=>{const{x:a,y:u}=o.bbox(),f=a.size,l=u.size;if(f===void 0)throw new Error("x.size not present on calculated bbox");if(l===void 0)throw new Error("x.size not present on calculated bbox");return V.fromTopLeft({x:a.min,y:u.min},f,l)},toString:()=>o.toString(),toSvgString:()=>["brrup"],kind:"bezier/cubic"})},Mt=(e,r,n)=>({a:Object.freeze(e),b:Object.freeze(r),quadratic:Object.freeze(n)}),Sn=e=>{const{a:r,b:n,quadratic:i}=e,s=new w(r,i,n);return Object.freeze({...e,length:()=>s.length(),interpolate:o=>s.compute(o),bbox:()=>{const{x:o,y:a}=s.bbox(),u=o.size,f=a.size;if(u===void 0)throw new Error("x.size not present on calculated bbox");if(f===void 0)throw new Error("x.size not present on calculated bbox");return V.fromTopLeft({x:o.min,y:a.min},u,f)},toString:()=>s.toString(),toSvgString:()=>Nt(r,n,i),kind:"bezier/quadratic"})},St={};_(St,{bbox:()=>Ct,distanceCenter:()=>jt,interpolate:()=>At,intersectionLine:()=>An,intersections:()=>kt,isCircle:()=>_t,isContainedBy:()=>Rt,isEquals:()=>Ie,isIntersecting:()=>_n,isPositioned:()=>F,length:()=>qt,point:()=>Pt,toPath:()=>Pn,toSvg:()=>It});var $t=Math.PI*2,F=e=>e.x!==void 0&&e.y!==void 0,_t=e=>e.radius!==void 0,Pt=(e,r,n)=>(n===void 0&&(F(e)?n=e:n={x:0,y:0}),{x:Math.cos(-r)*e.radius+n.x,y:Math.sin(-r)*e.radius+n.y}),$n=e=>{if(F(e)&&N(e,"circle"),Number.isNaN(e.radius))throw new Error("Radius is NaN");if(e.radius<=0)throw new Error("Radius must be greater than zero")},At=(e,r)=>Pt(e,r*$t),qt=e=>$t*e.radius,Ct=e=>F(e)?V.fromCenter(e,e.radius*2,e.radius*2):{width:e.radius*2,height:e.radius*2},Rt=(e,r)=>jt(e,r)<Math.abs(e.radius-r.radius),_n=(e,r)=>Ie(e,r)||Rt(e,r)?!0:kt(e,r).length===2,kt=(e,r)=>{const n=$.subtract(r,e),i=Math.sqrt(n.y*n.y+n.x*n.x);if(i>e.radius+r.radius)return[];if(i<Math.abs(e.radius-r.radius))return[];if(Ie(e,r))return[];const s=(e.radius*e.radius-r.radius*r.radius+i*i)/(2*i),o={x:e.x+n.x*s/i,y:e.y+n.y*s/i},a=Math.sqrt(e.radius*e.radius-s*s),u={x:-n.y*(a/i),y:n.x*(a/i)};return[$.sum(o,u),$.subtract(o,u)]},Ie=(e,r)=>e.radius!==r.radius?!1:F(e)&&F(r)?!(e.x!==r.x||e.y!==r.y||e.z!==r.z):(!F(e)&&!F(r),!1),jt=(e,r)=>$.distance(e,r),It=(e,r,n)=>{if(_t(e)){if(n!==void 0)return Me(e.radius,n,r);if(F(e))return Me(e.radius,e,r);throw new Error("origin parameter needed for non-positioned circle")}else{if(n!==void 0)return Me(e,n,r);throw new Error("origin parameter needed")}},Me=(e,r,n)=>{const{x:i,y:s}=r,o=n?"1":"0";return`
    M ${i}, ${s}
    m -${e}, 0
    a ${e},${e} 0 1,${o} ${e*2},0
    a ${e},${e} 0 1,${o} -${e*2},0
  `.split(`
`)},Pn=e=>($n(e),Object.freeze({...e,interpolate:r=>At(e,r),bbox:()=>Ct(e),length:()=>qt(e),toSvgString:(r=!0)=>It(e,r),kind:"circular"})),An=(e,r)=>{const n={x:r.b.x-r.a.x,y:r.b.y-r.a.y},i={x:r.a.x-e.x,y:r.a.y-e.y},s=(n.x*i.x+n.y*i.y)*-2,o=2*(n.x*n.x+n.y*n.y),a=Math.sqrt(s*s-2*o*(i.x*i.x+i.y*i.y-e.radius*e.radius));if(isNaN(a))return[];const u=(s-a)/o,f=(s+a)/o,l=[];return u<=1&&u>=0&&l.push({x:r.a.x+n.x*u,y:r.a.y+n.y*u}),f<=1&&f>=0&&l.push({x:r.a.x+n.x*f,y:r.a.y+n.y*f}),l},Ot={};_(Ot,{bbox:()=>Lt,computeDimensions:()=>Oe,fromPaths:()=>Ut,guardContinuous:()=>Ft,interpolate:()=>Tt,setSegment:()=>qn,toString:()=>Dt,toSvgString:()=>Bt});var qn=(e,r,n)=>{const i=[...e.segments];return i[r]=n,Ut(...i)},Tt=(e,r,n,i)=>{i===void 0&&(i=Oe(e));const s=r*(n?i.totalWidth:i.totalLength);let o=0;const a=n?i.widths:i.lengths;for(let u=0;u<a.length;u++)if(o+a[u]>=s){let l=(s-o)/a[u];return l>1&&(l=1),e[u].interpolate(l)}else o+=a[u];return{x:0,y:0}},Oe=e=>{const r=e.map(o=>o.bbox().width),n=e.map(o=>o.length());let i=0,s=0;for(let o=0;o<n.length;o++)i+=n[o];for(let o=0;o<r.length;o++)s+=r[o];return{totalLength:i,totalWidth:s,widths:r,lengths:n}},Lt=e=>{const n=e.map(i=>i.bbox()).map(i=>V.getCorners(i)).flat();return $.bbox(...n)},Dt=e=>e.map(r=>r.toString()).join(", "),Ft=e=>{let r=ce.getEnd(e[0]);for(let n=1;n<e.length;n++){const i=ce.getStart(e[n]);if(!$.equals(i,r))throw new Error("Path index "+n+" does not start at prior path end. Start: "+i.x+","+i.y+" expected: "+r.x+","+r.y);r=ce.getEnd(e[n])}},Bt=e=>e.flatMap(r=>r.toSvgString()),Ut=(...e)=>{Ft(e);const r=Oe(e);return Object.freeze({segments:e,length:()=>r.totalLength,interpolate:(n,i=!1)=>Tt(e,n,i,r),bbox:()=>Lt(e),toString:()=>Dt(e),toSvgString:()=>Bt(e),kind:"compound"})},Jt={};_(Jt,{allDirections:()=>Te,cellAtPoint:()=>In,cellEquals:()=>Gt,cellKeyString:()=>Vt,cellMiddle:()=>On,cells:()=>Fe,crossDirections:()=>Qt,getLine:()=>Tn,getVectorFromCardinal:()=>Le,guardCell:()=>T,inside:()=>Kt,isEqual:()=>kn,neighbours:()=>Wt,offset:()=>De,offsetCardinals:()=>Ln,rectangleForCell:()=>jn,rows:()=>Wn,simpleLine:()=>Dn,visitFor:()=>Kn,visitor:()=>Z,visitorBreadth:()=>Un,visitorColumn:()=>Qn,visitorDepth:()=>Bn,visitorRandom:()=>Vn,visitorRandomContiguous:()=>Jn,visitorRow:()=>Gn});var Cn=e=>e===void 0?!1:"x"in e&&"y"in e,Rn=e=>!(e===void 0||e[1]===void 0),kn=(e,r)=>{if("rows"in e&&"cols"in e)if("rows"in r&&"cols"in r){if(e.rows!==r.rows||e.cols!==r.cols)return!1}else return!1;if("size"in e)if("size"in r){if(e.size!==r.size)return!1}else return!1;return!0},Vt=e=>`Cell{${e.x},${e.y}}`,Gt=(e,r)=>r===void 0||e===void 0?!1:e.x===r.x&&e.y===r.y,T=(e,r="Param",n)=>{if(e===void 0)throw new Error(r+" is undefined. Expecting {x,y}");if(e.x===void 0)throw new Error(r+".x is undefined");if(e.y===void 0)throw new Error(r+".y is undefined");if(!Number.isInteger(e.x))throw new Error(r+".x is non-integer");if(!Number.isInteger(e.y))throw new Error(r+".y is non-integer");if(n!==void 0&&!Kt(n,e))throw new Error(`${r} is outside of grid. Cell: ${e.x},${e.y} Grid: ${n.cols}, ${n.rows}`)},ze=(e,r="Param")=>{if(e===void 0)throw new Error(`${r} is undefined. Expecting grid.`);if(!("rows"in e))throw new Error(`${r}.rows is undefined`);if(!("cols"in e))throw new Error(`${r}.cols is undefined`);if(!Number.isInteger(e.rows))throw new Error(`${r}.rows is not an integer`);if(!Number.isInteger(e.cols))throw new Error(`${r}.cols is not an integer`)},Kt=(e,r)=>!(r.x<0||r.y<0||r.x>=e.cols||r.y>=e.rows),jn=(e,r)=>{T(e);const n=r.size,i=e.x*n,s=e.y*n;return V.fromTopLeft({x:i,y:s},n,n)},In=(e,r)=>{const n=r.size;if(e.x<0||e.y<0)return;const i=Math.floor(e.x/n),s=Math.floor(e.y/n);if(!(i>=r.cols)&&!(s>=r.rows))return{x:i,y:s}},Te=Object.freeze(["n","ne","nw","e","s","se","sw","w"]),Qt=Object.freeze(["n","e","s","w"]),Wt=(e,r,n="undefined",i)=>{const s=i??Te,o=s.map(a=>De(e,r,Le(a),n));return Se(s,o)},On=(e,r)=>{T(e);const n=r.size,i=e.x*n,s=e.y*n;return Object.freeze({x:i+n/2,y:s+n/2})},Tn=(e,r)=>{T(e),T(r);let n=e.x,i=e.y;const s=Math.abs(r.x-n),o=Math.abs(r.y-i),a=n<r.x?1:-1,u=i<r.y?1:-1;let f=s-o;const l=[];for(;l.push(Object.freeze({x:n,y:i})),!(n===r.x&&i===r.y);){const c=2*f;c>-o&&(f-=o,n+=a),c<s&&(f+=s,i+=u)}return l},Ln=(e,r,n,i="stop")=>{ze(e,"grid"),T(r,"start"),Y(n,"aboveZero","steps");const s=Te,o=s.map(u=>Le(u,n)),a=s.map((u,f)=>De(e,r,o[f],i));return Se(s,a)},Le=(e,r=1)=>{let n;switch(e){case"n":n={x:0,y:-1*r};break;case"ne":n={x:1*r,y:-1*r};break;case"e":n={x:1*r,y:0};break;case"se":n={x:1*r,y:1*r};break;case"s":n={x:0,y:1*r};break;case"sw":n={x:-1*r,y:1*r};break;case"w":n={x:-1*r,y:0};break;case"nw":n={x:-1*r,y:-1*r};break;default:n={x:0,y:0}}return Object.freeze(n)},Dn=function(e,r,n=!1){const i=[];if(e.x===r.x){const s=n?r.y+1:r.y;for(let o=e.y;o<s;o++)i.push({x:e.x,y:o})}else if(e.y===r.y){const s=n?r.x+1:r.x;for(let o=e.x;o<s;o++)i.push({x:o,y:e.y})}else throw new Error(`Only does vertical and horizontal: ${e.x},${e.y} - ${r.x},${r.y}`);return i},De=function(e,r,n,i="undefined"){T(r,"start",e),T(n),ze(e,"grid");let s=r.x,o=r.y;switch(i){case"wrap":s+=n.x%e.cols,o+=n.y%e.rows,s<0?s=e.cols+s:s>=e.cols&&(s-=e.cols),o<0?o=e.rows+o:o>=e.rows&&(o-=e.rows);break;case"stop":s+=n.x,o+=n.y,s=Ve(s,e.cols),o=Ve(o,e.rows);break;case"undefined":if(s+=n.x,o+=n.y,s<0||o<0||s>=e.cols||o>=e.rows)return;break;case"unbounded":s+=n.x,o+=n.y;break;default:throw new Error(`Unknown BoundsLogic case ${i}`)}return Object.freeze({x:s,y:o})},Fn=(e,r,n,i)=>{const s=Wt(e,r,i,n);return Object.entries(s).filter(Rn)},Z=function*(e,r,n,i={}){ze(r,"grid"),T(n,"start",r);const s=i.visited??He(l=>Vt(l)),o=e.options?e.options:(l,c)=>Fn(l,c,Qt,"undefined");if(!Cn(n))throw new Error("'start' parameter is undefined or not a cell");let a=[n],u=[],f=null;for(;a.length>0;){if(f===null){const l=a.pop();if(l===void 0)break;f=l}if(!s.has(f)){s.add(f),yield f;const l=o(r,f).filter(c=>!s.has(c[1]));l.length===0?f!==null&&(a=a.filter(c=>Gt(c,f))):u.push(...l)}if(u=u.filter(l=>!s.has(l[1])),u.length===0)f=null;else{const l=e.select(u);l!==void 0&&(a.push(l[1]),f=l[1])}}},Bn=(e,r,n={})=>Z({select:i=>i[i.length-1]},e,r,n),Un=(e,r,n={})=>Z({select:i=>i[0]},e,r,n),Zt=e=>Pe(e),Jn=(e,r,n={})=>Z({select:Zt},e,r,n),Vn=(e,r,n={})=>Z({options:(i,s)=>{const o=[];for(const a of Fe(i,s))o.push(["n",a]);return o},select:Zt},e,r,n),Gn=(e,r,n={})=>{const{reversed:i=!1}=n;return Z({select:u=>u.find(f=>f[0]===(i?"w":"e")),options:(u,f)=>(i?f.x>0?f={x:f.x-1,y:f.y}:f.y>0?f={x:u.cols-1,y:f.y-1}:f={x:u.cols-1,y:u.rows-1}:f.x<u.rows-1?f={x:f.x+1,y:f.y}:f.y<u.rows-1?f={x:0,y:f.y+1}:f={x:0,y:0},[[i?"w":"e",f]])},e,r,n)},Kn=(e,r,n,i)=>{Y(n,"","steps");const s={reversed:n<0};n=Math.abs(n);let o=r,a=i(e,r,s);a.next();let u=0;for(;u<n;){u++;const{value:f}=a.next();if(f)o=f,s.debug&&console.log(`stepsMade: ${u} cell: ${o.x}, ${o.y} reverse: ${s.reversed}`);else if(n>=e.cols*e.rows)n-=e.cols*e.rows,u=0,a=i(e,r,s),a.next(),o=r,s.debug&&console.log(`resetting visitor to ${n}`);else throw new Error("Value not received by visitor")}return o},Qn=(e,r,n={})=>{const{reversed:i=!1}=n;return Z({select:o=>o.find(a=>a[0]===(i?"n":"s")),options:(o,a)=>(i?a.y>0?a={x:a.x,y:a.y-1}:a.x===0?a={x:o.cols-1,y:o.rows-1}:a={x:a.x-1,y:o.rows-1}:a.y<o.rows-1?a={x:a.x,y:a.y+1}:a.x<o.cols-1?a={x:a.x+1,y:0}:a={x:0,y:0},[[i?"n":"s",a]])},e,r,n)},Wn=function*(e,r={x:0,y:0}){let n=r.y,i=[];for(const s of Fe(e,r))s.y!==n?(yield i,i=[s],n=s.y):i.push(s);i.length>0&&(yield i)},Fe=function*(e,r={x:0,y:0}){ze(e,"grid"),T(r,"start",e);let{x:n,y:i}=r,s=!0;do yield{x:n,y:i},n++,n===e.cols&&(i++,n=0),i===e.rows&&(i=0,n=0),n===r.x&&i===r.y&&(s=!1);while(s)},ce={};_(ce,{getEnd:()=>Hn,getStart:()=>Zn});var Zn=function(e){if(be.isQuadraticBezier(e))return e.a;if(J.isLine(e))return e.a;throw new Error(`Unknown path type ${JSON.stringify(e)}`)},Hn=function(e){if(be.isQuadraticBezier(e))return e.b;if(J.isLine(e))return e.b;throw new Error(`Unknown path type ${JSON.stringify(e)}`)},V={};_(V,{fromCenter:()=>ei,fromElement:()=>Xn,fromTopLeft:()=>ri,getCenter:()=>ni,getCorners:()=>Ht,getLines:()=>ii,guard:()=>Be,isEqual:()=>Yn,maxFromCorners:()=>ti});var Xn=e=>({width:e.clientWidth,height:e.clientHeight}),Yn=(e,r)=>e.width===r.width&&e.height===r.height,ei=(e,r,n)=>{$.guard(e,"origin"),ee(r,"width"),ee(n,"height");const i=r/2,s=n/2;return{x:e.x-i,y:e.y-s,width:r,height:n}},ti=(e,r,n,i)=>{if(e.y>n.y)throw new Error("topLeft.y greater than bottomRight.y");if(e.y>i.y)throw new Error("topLeft.y greater than bottomLeft.y");const s=r.x-e.x,o=n.x-i.x,a=Math.abs(i.y-e.y),u=Math.abs(n.y-r.y);return{x:Math.min(e.x,i.x),y:Math.min(r.y,e.y),width:Math.max(s,o),height:Math.max(a,u)}},ee=(e,r="Dimension")=>{if(e===void 0)throw Error(`${r} is undefined`);if(isNaN(e))throw Error(`${r} is NaN`);if(e<0)throw Error(`${r} cannot be negative`)},Be=(e,r="rect")=>{if(e===void 0)throw Error("{$name} undefined");ee(e.width,r+".width"),ee(e.height,r+".height")},ri=(e,r,n)=>(ee(r,"width"),ee(n,"height"),$.guard(e,"origin"),{x:e.x,y:e.y,width:r,height:n}),Ht=(e,r)=>{if(Be(e),r===void 0&&$.isPoint(e))r=e;else if(r===void 0)throw new Error("Unpositioned rect needs origin param");return[{x:r.x,y:r.y},{x:r.x+e.width,y:r.y},{x:r.x+e.width,y:r.y+e.height},{x:r.x,y:r.y+e.height}]},ni=(e,r)=>{if(Be(e),r===void 0&&$.isPoint(e))r=e;else if(r===void 0)throw new Error("Unpositioned rect needs origin param");return{x:r.x+e.width/2,y:r.y+e.height/2}},ii=(e,r)=>J.joinPointsToLines(...Ht(e,r)),Xt={};_(Xt,{fromDegrees:()=>si});var si=(e,r,n=0,i=0,s=360)=>({radiusX:e,radiusY:r,rotation:X(n),startAngle:X(i),endAngle:X(s)}),me={};_(me,{fromCartesian:()=>oi,isCoord:()=>Yt,spiral:()=>ui,spiralRaw:()=>fi,toCartesian:()=>ai});var Yt=e=>!(e.distance===void 0||e.angleRadian===void 0),oi=(e,r)=>{e=xt(e,r);let n=Math.atan2(e.y,e.x);return n<0?n=Math.abs(n):n=Math.PI+(Math.PI-n),{angleRadian:n,distance:Math.sqrt(e.x*e.x+e.y*e.y)}},ai=(e,r,n)=>{if(Yt(e)){if(r===void 0&&(r=xe),!O(r))throw new Error("Expecting (Coord, Point). Point param wrong type.");return Ze(e.distance,e.angleRadian,r)}else if(typeof e=="number"&&typeof r=="number"){if(n===void 0&&(n=xe),!O(n))throw new Error("Expecting (number, number, Point). Point param wrong type");return Ze(e,r,n)}else throw new Error("Expecting (number, number)")};function*ui(e,r){let n=0;for(;;){const i=e*n++;yield{distance:r*i,angleRadian:i,step:n}}}var fi=(e,r,n)=>{const i=r*e;return{distance:n*i,angleRadian:i}},Ze=(e,r,n)=>(N(n),{x:n.x+e*Math.cos(r),y:n.y+e*Math.sin(r)}),X=e=>e*(Math.PI/180),ci=e=>e*180/Math.PI,li=e=>Math.atan2(e.x,e.y);export{br as A,be as B,gi as C,bi as D,Ar as E,pi as F,mr as G,Ye as H,mi as I,wr as J,vr as K,zi as L,rr as M,Xt as N,Dr as O,Lr as P,qe as Q,gr as R,hr as S,Jt as T,$ as U,J as V,me as W,ci as X,it as Y,St as Z,X as _,Et as a,we as b,Ht as c,xr as d,ir as e,ct as f,N as g,ur as h,zt as i,or as j,ar as k,sr as l,Mr as m,En as n,di as o,pr as p,je as q,Pe as r,He as s,xi as t,W as u,Xe as v,_r as w,$e as x,vi as y,wi as z};
