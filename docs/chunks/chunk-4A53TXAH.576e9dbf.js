import{S as _}from"./chunk-XFTV7E35.542cf193.js";import{E as x,n as L,q as g,o as w,p,u as B,v as E,x as A}from"./chunk-ZTHSWHI3.b2cf17c9.js";import{n as m,S as P}from"./chunk-U4IZE4J2.68fe18db.js";import{_ as b,b as r,a as u,c as h,d as s}from"./chunk-FQLUQVDZ.735c98e3.js";var S={};b(S,{Easings:()=>x,Oscillators:()=>D,adsr:()=>W,defaultAdsrOpts:()=>M,jitter:()=>C});var M=()=>({attackBend:-1,decayBend:-.3,releaseBend:-.3,peakLevel:1,initialLevel:0,sustainLevel:.6,releaseLevel:0,attackDuration:600,decayDuration:200,releaseDuration:800,shouldLoop:!1}),n,f,l,d,o,T=class extends P{constructor(e){super();u(this,n,void 0),u(this,f,void 0),u(this,l,void 0),u(this,d,void 0),u(this,o,void 0),r(this,"attackDuration"),r(this,"decayDuration"),r(this,"releaseDuration"),r(this,"decayDurationTotal"),r(this,"shouldLoop"),this.attackDuration=e.attackDuration??300,this.decayDuration=e.decayDuration??500,this.releaseDuration=e.releaseDuration??1e3,this.shouldLoop=e.shouldLoop??!1;const t={attack:["decay","release"],decay:["sustain","release"],sustain:["release"],release:["complete"],complete:null};h(this,n,new _("attack",t)),s(this,n).addEventListener("change",a=>{a.newState==="release"&&s(this,o)&&s(this,l)?.reset(),super.fireEvent("change",a)}),s(this,n).addEventListener("stop",a=>{super.fireEvent("complete",a)}),h(this,f,A),h(this,d,h(this,o,!1)),this.decayDurationTotal=this.attackDuration+this.decayDuration}switchState(){if(s(this,l)===void 0)return!1;let e=s(this,l).elapsed;const t=s(this,o)&&!s(this,d);let a=!1;do switch(a=!1,s(this,n).state){case"attack":(e>this.attackDuration||t)&&(s(this,n).next(),a=!0);break;case"decay":(e>this.decayDurationTotal||t)&&(s(this,n).next(),a=!0);break;case"sustain":(!s(this,d)||t)&&(e=0,s(this,n).next(),s(this,l)?.reset(),a=!0);break;case"release":e>this.releaseDuration&&(s(this,n).next(),a=!0);break;case"complete":this.shouldLoop&&this.trigger(s(this,o))}while(a);return a}computeRaw(e=!0){if(s(this,l)===void 0)return[void 0,0,s(this,n).state];e&&this.switchState();const t=s(this,n).state,a=s(this,l).elapsed;let i=0;const c=s(this,n).state;switch(c){case"attack":i=a/this.attackDuration;break;case"decay":i=(a-this.attackDuration)/this.decayDuration;break;case"sustain":i=1;break;case"release":i=Math.min(a/this.releaseDuration,1);break;case"complete":return[void 0,1,t];default:throw new Error(`State machine in unknown state: ${c}`)}return[c,i,t]}get isDone(){return s(this,n).isDone}onTrigger(){}trigger(e=!1){this.onTrigger(),s(this,n).reset(),h(this,l,s(this,f).call(this)),h(this,d,e),h(this,o,e)}compute(){}release(){this.isDone||!s(this,o)||(h(this,d,!1),this.compute())}};n=new WeakMap;f=new WeakMap;l=new WeakMap;d=new WeakMap;o=new WeakMap;var N=class extends T{constructor(e){super(e);r(this,"attackPath"),r(this,"decayPath"),r(this,"releasePath"),r(this,"initialLevel"),r(this,"peakLevel"),r(this,"releaseLevel"),r(this,"sustainLevel"),r(this,"attackBend"),r(this,"decayBend"),r(this,"releaseBend"),r(this,"initialLevelOverride"),r(this,"retrigger"),r(this,"releasedAt"),this.initialLevel=e.initialLevel??0,this.peakLevel=e.peakLevel??1,this.releaseLevel=e.releaseLevel??0,this.sustainLevel=e.sustainLevel??.75,this.retrigger=e.retrigger??!0,this.attackBend=e.attackBend??0,this.releaseBend=e.releaseBend??0,this.decayBend=e.decayBend??0;const t=1;this.attackPath=L(g({x:0,y:this.initialLevel},{x:t,y:this.peakLevel},-this.attackBend)),this.decayPath=L(g({x:0,y:this.peakLevel},{x:t,y:this.sustainLevel},-this.decayBend)),this.releasePath=L(g({x:0,y:this.sustainLevel},{x:t,y:this.releaseLevel},-this.releaseBend))}onTrigger(){if(this.initialLevelOverride=void 0,!this.retrigger){const[e,t,a]=this.compute();!Number.isNaN(t)&&t>0&&(console.log(`Retrigger. Last value was: ${t}`),this.initialLevelOverride=t)}}get value(){return this.compute(!0)[1]}compute(e=!0){const[t,a]=super.computeRaw(e);if(t===void 0)return[void 0,NaN,NaN];let i;switch(t){case"attack":i=this.attackPath.interpolate(a).y,this.initialLevelOverride!==void 0&&(i=w(i,0,this.initialLevel,this.initialLevelOverride,this.initialLevel)),this.releasedAt=i;break;case"decay":i=this.decayPath.interpolate(a).y,this.releasedAt=i;break;case"sustain":i=this.sustainLevel,this.releasedAt=i;break;case"release":i=this.releasePath.interpolate(a).y,this.releasedAt!==void 0&&(i=w(i,0,this.sustainLevel,0,this.releasedAt));break;case"complete":i=this.releaseLevel,this.releasedAt=void 0;break;default:throw new Error(`Unknown state: ${t}`)}return[t,i,a]}},W=e=>new N(e),D={};b(D,{saw:()=>U,sine:()=>I,sineBipolar:()=>R,square:()=>j,triangle:()=>$});function*I(e){for(typeof e=="number"&&(e=p(e));;)yield(Math.sin(e.elapsed*Math.PI*2)+1)/2}function*R(e){for(typeof e=="number"&&(e=p(e));;)yield Math.sin(e.elapsed*Math.PI*2)}function*$(e){for(typeof e=="number"&&(e=p(e));;){let t=e.elapsed;t<.5?t*=2:t=2-t*2,yield t}}function*U(e){for(typeof e=="number"&&(e=p(e));;)yield e.elapsed}function*j(e){for(typeof e=="number"&&(e=p(e));;)yield e.elapsed<.5?0:1}var C=(e,t,a={},i=B)=>{const c=a.type??"abs",k=a.clamped??!0;m(e,k?"percentage":"bipolar","value"),m(t,k?"percentage":"bipolar","jitter");let v;if(c==="rel"){t=e*t;const y=t*2*i();v=e-t+y}else if(c==="abs"){const y=t*2*i();v=e-t+y}else throw new Error(`Unknown jitter type: ${c}.`);return k?E(v):v};export{D as O,W as a,M as d,C as j};
