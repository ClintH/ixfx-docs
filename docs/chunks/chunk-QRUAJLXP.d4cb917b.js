var f=r=>{if(r[0])return!1;throw new Error(r[1])},J=r=>Math.log2(r)%1===0,q=(r,e)=>{if(Number.isNaN(r))return e;if(typeof r!="number")throw new TypeError(`v is not a number. Got: ${typeof r}`);return r},B=(r,e="",t=Number.NaN)=>{if(r===void 0||r===null)return t;try{const n=Number.parseInt(r);return b(n,e,"parsed")[0]?n:t}catch{return t}return Number.parseInt(r)},c=(r,e="",t="?")=>{if(r===null)return[!1,`Parameter '${t}' is null`];if(typeof r>"u")return[!1,`Parameter '${t}' is undefined`];if(Number.isNaN(r))return[!1,`Parameter '${t}' is NaN`];if(typeof r!="number")return[!1,`Parameter '${t}' is not a number (${JSON.stringify(r)})`];switch(e){case"positive":{if(r<0)return[!1,`Parameter '${t}' must be at least zero (${r})`];break}case"negative":{if(r>0)return[!1,`Parameter '${t}' must be zero or lower (${r})`];break}case"aboveZero":{if(r<=0)return[!1,`Parameter '${t}' must be above zero (${r})`];break}case"belowZero":{if(r>=0)return[!1,`Parameter '${t}' must be below zero (${r})`];break}case"percentage":{if(r>1||r<0)return[!1,`Parameter '${t}' must be in percentage range (0 to 1). (${r})`];break}case"nonZero":{if(r===0)return[!1,`Parameter '${t}' must non-zero. (${r})`];break}case"bipolar":{if(r>1||r<-1)return[!1,`Parameter '${t}' must be in bipolar percentage range (-1 to 1). (${r})`];break}}return[!0]},D=(r,e="",t="?")=>{f(c(r,e,t))},p=(r,e="?")=>c(r,"percentage",e),G=(r,e="?")=>{f(p(r,e))},b=(r,e="",t="?")=>{const n=c(r,e,t);return n[0]?Number.isInteger(r)?[!0]:[!1,`Parameter ${t} is not an integer`]:n},H=(r,e="",t="?")=>{f(b(r,e,t))},w=Math.random,v=Object.create,l=Object.defineProperty,h=Object.getOwnPropertyDescriptor,g=Object.getOwnPropertyNames,P=Object.getPrototypeOf,_=Object.prototype.hasOwnProperty,m=(r,e,t)=>e in r?l(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,K=(r,e)=>function(){return e||(0,r[g(r)[0]])((e={exports:{}}).exports,e),e.exports},x=(r,e)=>{for(var t in e)l(r,t,{get:e[t],enumerable:!0})},$=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of g(e))!_.call(r,a)&&a!==t&&l(r,a,{get:()=>e[a],enumerable:!(n=h(e,a))||n.enumerable});return r},Q=(r,e,t)=>(t=r!=null?v(P(r)):{},$(e||!r||!r.__esModule?l(t,"default",{value:r,enumerable:!0}):t,r)),U=(r,e,t,n)=>{for(var a=n>1?void 0:n?h(e,t):e,i=r.length-1,s;i>=0;i--)(s=r[i])&&(a=(n?s(e,t,a):s(a))||a);return n&&a&&l(e,t,a),a},X=(r,e,t)=>m(r,typeof e!="symbol"?e+"":e,t),O=(r=5)=>((typeof r=="number"?{length:r}:r).source??w)().toString(36).slice(2,length+2),y={};x(y,{abbreviate:()=>d,afterMatch:()=>T,beforeAfterMatch:()=>u,beforeMatch:()=>S,between:()=>M,betweenChomp:()=>N,countCharsFromStart:()=>z,htmlEntities:()=>Z,indexOfCharCode:()=>k,lineSpan:()=>j,omitChars:()=>A,random:()=>O,splitByLength:()=>C,splitRanges:()=>I,startsEnds:()=>F,toStringAbbreviate:()=>E,unwrap:()=>R,wildcard:()=>W});var d=(r,e=15)=>{if(f(b(e,"aboveZero","maxLength")),typeof r!="string")throw new Error("Parameter 'source' is not a string");if(r.length>e&&r.length>3){if(e>15){const t=Math.round((e-2)/2);return r.slice(0,t)+"..."+r.slice(-t)}return r.slice(0,e)+"..."}return r},E=(r,e=20)=>r===void 0?"(undefined)":r===null?"(null)":d(JSON.stringify(r),e),M=(r,e,t,n=!0)=>{const a=r.indexOf(e);if(a<0)return;t===void 0&&(t=e);const i=n?r.lastIndexOf(t):r.indexOf(t,a+1);if(!(i<0))return r.slice(a+1,i)},N=(r,e,t,n=!0)=>{if(typeof r!="string")throw new Error("Parameter 'source' is not a string");if(typeof e!="string")throw new Error("Parameter 'start' is not a string");if(t!==void 0&&typeof t!="string")throw new Error("Parameter 'end' is not a string");const a=r.indexOf(e);if(a<0)return[r,void 0];t===void 0&&(t=e);const i=n?r.lastIndexOf(t):r.indexOf(t,a+1);if(i<0)return[r,void 0];const s=r.slice(a+1,i);return[r.slice(0,a)+r.slice(i+1),s]},k=(r,e,t=0,n=r.length-1)=>{for(let a=t;a<=n;a++)if(r.codePointAt(a)===e)return a;return-1},A=(r,e,t)=>r.slice(0,e)+r.slice(e+t),C=(r,e)=>{if(f(b(e,"aboveZero","length")),r===null)throw new Error("source parameter null");if(typeof r!="string")throw new TypeError("source parameter not a string");const t=Math.ceil(r.length/e),n=[];let a=0;for(let i=0;i<t;i++)n.push(r.slice(a,a+e)),a+=e;return n},S=(r,e,t={})=>u(r,e,t)[0],T=(r,e,t={})=>u(r,e,t)[1],u=(r,e,t={})=>{if(r===void 0)throw new Error("Param 'source' is undefined");let n=t.fallback;const a=t.ifNoMatch??(n?"fallback":"original");if(a==="original"&&(n=r),a==="fallback"&&n===void 0)throw new Error("Fallback must be provided");const i=t.startPos??void 0,o=t.fromEnd??!1?r.lastIndexOf(e,i):r.indexOf(e,i);if(o<0&&a==="throw")throw new Error(`Match '${e}' not found in source.`);return o<0&&a==="original"?[r,r]:o<0&&a==="fallback"?[n,n]:[r.slice(0,o),r.slice(Math.max(0,o+e.length))]},R=(r,...e)=>{let t=!1;do{t=!1;for(const n of e)r.startsWith(n)&&r.endsWith(n)&&(r=r.slice(n.length,r.length-n.length*2+1),t=!0)}while(t);return r},j=(r,e,t)=>{let n=-1,a=-1;for(const[i,s]of r.entries())if(n=i,s.text.length!==0&&e<s.end)break;for(let i=n;i<r.length;i++){const s=r[i];if(a=i,t===s.end){a=i+1;break}if(t<s.end)break}return{length:a-n,start:n,end:a}},I=(r,e)=>{let t=0,n="";const a=[];let i=0;for(let s=0;s<r.length;s++)if(r.indexOf(e,s)===s){const o=s;a.push({text:n,start:t,end:o,index:i}),t=o+1,n="",i++}else n+=r.charAt(s);return t<r.length&&a.push({text:n,start:t,index:i,end:r.length}),a},z=(r,...e)=>{let t=0;for(let n=0;n<r.length&&e.includes(r.charAt(n));n++)t++;return t},F=(r,e,t=e)=>r.startsWith(e)&&r.endsWith(t),Z=r=>r.replaceAll(/[&<>\u00A0-\u9999]/g,e=>`&#${e.codePointAt(0)};`),W=r=>{const e=n=>n.replaceAll(/([!$()*+./:=?[\\\]^{|}])/g,"\\$1");r=r.split("*").map(n=>e(n)).join(".*"),r="^"+r+"$";const t=new RegExp(r);return n=>t.test(n)};export{x as _,f as a,H as b,C as c,w as d,J as e,k as f,Q as g,K as h,b as i,q as j,T as k,S as l,B as m,c as n,A as o,p,G as q,E as r,O as s,D as t,X as u,U as v};
