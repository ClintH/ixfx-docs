import{B as Ae,f as Pe,m as $e}from"./chunk-LJEMCDK3.04845b20.js";import{P as De,T as Re,p as Be,a as Fe,t as qe,b as Ie}from"./chunk-J62BM3EA.66d2cd2d.js";import{T as O,i as Le}from"./chunk-GRFVFAQ5.c7dd4170.js";import{ax as G,ay as Ue,ao as We,ap as Ne,y as j,az as Ve,L as ze,aA as Oe,aB as Ge,aC as je,aD as b,u as $,aE as Je,aF as He,aG as Xe,z as Ze,aH as Ye,aI as Ke,aJ as Qe,aK as et,D as tt,aL as T,aM as st,aN as rt,a1 as E,a4 as it,aO as J,aP as ot,aQ as nt,c as at,m as D,aR as ct,aS as H,ag as X,T as A,aT as x,aU as Z,aV as Y,aW as lt,aX as dt,aY as ut,aZ as ht,a_ as ft}from"./chunk-UZEP5NPQ.5116c20e.js";import{_ as v,a as y,m as pt,b as N,s as gt,o as _,p as C}from"./chunk-7KTY42OF.629611b4.js";var vt={};v(vt,{Bipolar:()=>Ae,Correlate:()=>le,FrequencyMutable:()=>Q,Graphs:()=>se,IntervalTracker:()=>te,Normalise:()=>K,NumberTracker:()=>G,PointTracker:()=>De,Pool:()=>ue,PrimitiveTracker:()=>Ue,Table:()=>O,TrackedPointMap:()=>Re,TrackedValueMap:()=>We,TrackerBase:()=>Ne,clamp:()=>j,clampIndex:()=>Ve,flip:()=>Pe,frequencyMutable:()=>yt,interpolate:()=>ze,interpolateAngle:()=>Oe,interpolatorInterval:()=>Ge,interpolatorStepped:()=>je,intervalTracker:()=>Ct,movingAverage:()=>bt,movingAverageLight:()=>ee,movingAverageTimed:()=>xt,noiseFilter:()=>_t,numberTracker:()=>b,piPi:()=>Ft,pointTracker:()=>Be,pointsTracker:()=>Fe,scale:()=>$,scaleClamped:()=>Je,scalePercent:()=>He,scalePercentages:()=>Xe,scaler:()=>Ze,scalerPercent:()=>Ye,trackUnique:()=>qe,trackUniqueInstances:()=>Ie,wrap:()=>Ke,wrapInteger:()=>Qe,wrapRange:()=>et});var K={};v(K,{array:()=>mt,stream:()=>wt});var wt=(e,t)=>{let s=e??Number.MAX_SAFE_INTEGER,r=t??Number.MIN_SAFE_INTEGER;return y(e),y(t),i=>(y(i),s=Math.min(s,i),r=Math.max(r,i),$(i,s,r))},mt=(e,t,s)=>{if(!Array.isArray(e))throw new Error("values param should be an array");const r=tt(e),i=t??r.min,o=s??r.max;return e.map(n=>j($(n,i,o)))},Q=class extends T{#e;#t;constructor(e){super();this.#e=new Map,e===void 0&&(e=t=>{if(t===void 0)throw new Error("Cannot create key for undefined");return typeof t=="string"?t:JSON.stringify(t)}),this.#t=e}clear(){this.#e.clear(),this.fireEvent("change",{context:this})}keys(){return this.#e.keys()}values(){return this.#e.values()}toArray(){return[...this.#e.entries()]}debugString(){let e="";for(const[t,s]of this.#e.entries())e+=`${t}: ${s}, `;return e.endsWith(", ")?e.slice(0,Math.max(0,e.length-2)):e}frequencyOf(e){if(typeof e=="string")return this.#e.get(e);const t=this.#t(e);return this.#e.get(t)}relativeFrequencyOf(e){let t;if(typeof e=="string")t=this.#e.get(e);else{const r=this.#t(e);t=this.#e.get(r)}if(t===void 0)return;const s=this.minMaxAvg();return t/s.total}entries(){return[...this.#e.entries()]}minMaxAvg(){return st.minMaxAvg(this.entries())}entriesSorted(e="value"){return rt(e)(this.entries())}add(...e){if(e===void 0)throw new Error("value parameter is undefined");const t=e.map(s=>this.#t(s));for(const s of t){const r=this.#e.get(s)??0;this.#e.set(s,r+1)}this.fireEvent("change",{context:this})}},yt=e=>new Q(e),ee=(e=3)=>{y(e,"aboveZero","scaling");let t=0,s=0,r=!1;return{dispose(){r=!0},get isDisposed(){return r},add(o){if(r)throw new Error("MovingAverage disposed, cannot add");return s++,t=t+(o-t)/Math.min(s,e),t},clear(){if(r)throw new Error("MovingAverage disposed, cannot clear");t=0,s=0},compute(){return t}}},xt=(e=200,t=0,s=3)=>{y(s,"aboveZero","scaling"),y(e,"aboveZero","decayRateMs");const r=ee(s);let i=0;const o=()=>{i!==0&&clearTimeout(i),i=setTimeout(n,e)},n=()=>{r.add(t),r.isDisposed||setTimeout(n,e)};return{add(d){return o(),r.add(d)},dispose(){r.dispose()},clear:function(){r.clear()},compute:function(){return r.compute()},isDisposed:!1}},bt=(e=100,t)=>{let s=!1,r=new E({capacity:e,discardPolicy:"older"});const i=()=>{r=new E({capacity:e,discardPolicy:"older"})},o=()=>t===void 0?ot(r.data):nt(r.data,t);return{add:d=>(r.enqueue(d),o()),compute:o,clear:i,dispose:()=>{s=!0},isDisposed:s}},Et=Math.PI*2,V=(e,t)=>{const s=Et*t*e;return s/(s+1)},z=(e,t,s)=>e*t+(1-e)*s,_t=(e=1,t=0,s=1)=>{let r=0,i=0,o=0;return(a,d)=>{d===void 0&&(d=performance.now());const c=d-o,u=V(c,s),f=(a-r)/c,l=z(u,f,i),p=e+t*Math.abs(l),m=V(c,p),g=z(m,a,r);return r=g,i=l,o=d,g}},te=class extends G{lastMark=0;mark(){this.lastMark>0&&this.seen(performance.now()-this.lastMark),this.lastMark=performance.now()}},Ct=e=>new te(e),se={};v(se,{Directed:()=>Le,Undirected:()=>re});var re={};v(re,{adjacentVertices:()=>Pt,connect:()=>ce,connectTo:()=>ae,createVertex:()=>ie,dumpGraph:()=>kt,edgesForVertex:()=>$t,getConnection:()=>R,getOrCreate:()=>P,graph:()=>St,hasConnection:()=>ne,toAdjacencyMatrix:()=>Tt,updateGraphVertex:()=>oe});var ie=e=>({id:e}),oe=(e,t)=>({...e,vertices:e.vertices.set(t.id,t)}),P=(e,t)=>{const s=e.vertices.get(t);if(s!==void 0)return{graph:e,vertex:s};const r=ie(t);return{graph:oe(e,r),vertex:r}};function S(e,t){const s=typeof t=="string"?e.vertices.get(t):t;if(s===void 0)throw new Error(`Id not found ${t}`);return s}var ne=(e,t,s)=>R(e,t,s)!==void 0,R=(e,t,s)=>{const r=S(e,t),i=S(e,s);for(const o of e.edges)if(o.a==r.id&&o.b===i.id||o.a==i.id&&o.b===r.id)return o};function ae(e,t,s,r){e=P(e,t).graph,e=P(e,s).graph;let n=R(e,t,s);return n!==void 0?{graph:e,edge:n}:(n={a:t,b:s,weight:r},{graph:{...e,edges:[...e.edges,n]},edge:n})}function ce(e,t){const{a:s,weight:r,b:i}=t,o=Array.isArray(i)?i:[i];for(const n of o)e=ae(e,s,n,r).graph;return e}var St=(...e)=>{let t={vertices:it(),edges:[]};for(const s of e)t=ce(t,s);return t};function Tt(e){const t=[...e.vertices.values()],s=new O;s.labelColumns(...t.map(r=>r.id)),s.labelRows(...t.map(r=>r.id));for(let r=0;r<t.length;r++){s.setRow(r,t.length,!1);const i=t[r];for(const[o,n]of t.entries())ne(e,i,n)&&s.set(r,o,!0)}return s}var kt=e=>Mt(e).join(`
`),Mt=e=>{const t=[];t.push(`Vertices: ${[...e.vertices.values()].map(s=>s.id).join(", ")}`),t.push("Edges:");for(const s of e.edges)t.push(At(s));return t},At=e=>{const t=e.weight?` (${e.weight})`:"";return`${e.a} <-> ${e.b}${t}`};function*Pt(e,t){if(t===void 0)return;if((typeof t=="string"?e.vertices.get(t):t)===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const r of e.edges)r.a===t?yield S(e,r.b):r.b===t&&(yield S(e,r.a))}function*$t(e,t){if(t===void 0)return;if((typeof t=="string"?e.vertices.get(t):t)===void 0)throw new Error(`Vertex not found ${JSON.stringify(t)}`);for(const r of e.edges)r.a===t?yield r:r.b===t&&(yield r)}var le={};v(le,{align:()=>de,alignById:()=>Rt});var Dt=(e,t)=>e.score>t.score?-1:e.score<t.score?1:0,de=(e,t,s,r={})=>{const i=r.matchThreshold??0,o=r.debug??!1,n=new Map,a=[],d=new Map;t?.forEach((c,u)=>{if(c===void 0)throw new Error(`'lastData' contains undefined (index: ${u})`);d.set(c.id,c)});for(let c=0;c<s.length;c++){const u=s[c];if(!t||t.length===0){o&&console.debug(`Correlate.align() new id: ${u.id}`),a.push(u);continue}const f=Array.from(d.values()).map(p=>({id:p.id,score:p===null?-1:e(p,u),last:p}));if(f.length===0){o&&console.debug(`Correlate.align() no valid last values id: ${u.id}`),a.push(u);continue}f.sort(Dt);const l=f[0];if(l.score<i){o&&console.debug(`Correlate.align() new item does not reach threshold. Top score: ${l.score} id: ${u.id}`),a.push(u);continue}o&&l.id!==u.id&&console.log(`Correlate.align() Remapped ${u.id} -> ${l.id} (score: ${l.score})`),n.set(l.id,{...u,id:l.id}),d.delete(l.id)}return a.forEach(c=>n.set(c.id,c)),Array.from(n.values())},Rt=(e,t={})=>{let s=[];return i=>(s=de(e,s,i,t),[...s])},ue={};v(ue,{Pool:()=>pe,PoolUser:()=>he,Resource:()=>fe,create:()=>Bt});var he=class extends T{constructor(e,t){super();this.key=e,this.resource=t,this._lastUpdate=performance.now(),this._pool=t.pool,this._userExpireAfterMs=this._pool.userExpireAfterMs,this._state="idle",this._pool.log.log(`PoolUser ctor key: ${this.key}`)}_lastUpdate;_pool;_state;_userExpireAfterMs;toString(){return this.isDisposed?"PoolUser. State: disposed":`PoolUser. State: ${this._state} Elapsed: ${performance.now()-this._lastUpdate} Data: ${JSON.stringify(this.resource.data)}`}keepAlive(){if(this._state==="disposed")throw new Error("PoolItem disposed");this._lastUpdate=performance.now()}_dispose(e,t){if(this._state==="disposed")return;const s=this.resource;this._state="disposed",s._release(this),this._pool.log.log(`PoolUser dispose key: ${this.key} reason: ${e}`),this.fireEvent("disposed",{data:t,reason:e}),super.clearEventListeners()}release(e){if(this.isDisposed)throw new Error("User disposed");const s=this.resource.data;this._pool.log.log(`PoolUser release key: ${this.key} reason: ${e}`),this.fireEvent("released",{data:s,reason:e}),this._dispose(`release-${e}`,s)}get data(){if(this.isDisposed)throw new Error("User disposed");return this.resource.data}get isExpired(){return this._userExpireAfterMs>0?performance.now()>this._lastUpdate+this._userExpireAfterMs:!1}get elapsed(){return performance.now()-this._lastUpdate}get isDisposed(){return this._state==="disposed"}get isValid(){return!(this.isDisposed||this.isExpired||this.resource.isDisposed)}},fe=class{constructor(e,t){if(this.pool=e,t===void 0)throw new Error("Parameter 'data' is undefined");if(e===void 0)throw new Error("Parameter 'pool' is undefined");this.#t=t,this.#r=0,this.#i=e.resourcesWithoutUserExpireAfterMs,this.#o=e.capacityPerResource,this.#s=[],this.#e="idle"}#e;#t;#s;#o;#i;#r;get data(){if(this.#e==="disposed")throw new Error("Resource disposed");return this.#t}updateData(e){if(this.#e==="disposed")throw new Error("Resource disposed");if(e===void 0)throw new Error("Parameter 'data' is undefined");this.#t=e}toString(){return`Resource (expired: ${this.isExpiredFromUsers} users: ${this.#s.length}, state: ${this.#e}) data: ${JSON.stringify(this.data)}`}_assign(e){if(this.#s.find(s=>s===e||s.key===e.key))throw new Error("User instance already assigned to resource");this.#s.push(e),this.#r=performance.now()}_release(e){this.#s=this.#s.filter(t=>t!==e),this.pool._release(e),this.#r=performance.now()}get hasUserCapacity(){return this.usersCount<this.#o}get usersCount(){return this.#s.length}get isExpiredFromUsers(){return this.#i<=0||this.#s.length>0?!1:performance.now()>this.#i+this.#r}get isDisposed(){return this.#e==="disposed"}dispose(e){if(this.#e==="disposed")return;const t=this.#t;this.#e="disposed",this.pool.log.log(`Resource disposed (${e})`);for(const s of this.#s)s._dispose(`resource-${e}`,t);this.#s=[],this.#r=performance.now(),this.pool._releaseResource(this,e),this.pool.freeResource&&this.pool.freeResource(t)}},pe=class{_resources;_users;capacity;userExpireAfterMs;resourcesWithoutUserExpireAfterMs;capacityPerResource;fullPolicy;generateResource;freeResource;log;constructor(e={}){this.capacity=e.capacity??-1,this.fullPolicy=e.fullPolicy??"error",this.capacityPerResource=e.capacityPerResource??1,this.userExpireAfterMs=e.userExpireAfterMs??-1,this.resourcesWithoutUserExpireAfterMs=e.resourcesWithoutUserExpireAfterMs??-1,this.generateResource=e.generate,this.freeResource=e.free,this._users=new Map,this._resources=[],this.log=J("Pool",e.debug??!1);const t=Math.max(this.userExpireAfterMs,this.resourcesWithoutUserExpireAfterMs);t>0&&setInterval(()=>{this.maintain()},t*1.1)}dumpToString(){let e=`Pool
    capacity: ${this.capacity} userExpireAfterMs: ${this.userExpireAfterMs} capacityPerResource: ${this.capacityPerResource}
    resources count: ${this._resources.length}`;const t=this._resources.map(s=>s.toString()).join(`\r
	`);e+=`\r
Resources:\r
	`+t,e+=`\r
Users: \r
`;for(const[s,r]of this._users.entries())e+=`	k: ${s} v: ${r.toString()}\r
`;return e}getUsersByLongestElapsed(){return[...this._users.values()].sort((e,t)=>{const s=e.elapsed,r=t.elapsed;return s===r?0:s<r?1:-1})}getResourcesSortedByUse(){return[...this._resources].sort((e,t)=>e.usersCount===t.usersCount?0:e.usersCount<t.usersCount?-1:1)}addResource(e){if(e===void 0)throw new Error("Cannot add undefined resource");if(e===null)throw new Error("Cannot add null resource");if(this.capacity>0&&this._resources.length===this.capacity)throw new Error(`Capacity limit (${this.capacity}) reached. Cannot add more.`);this.log.log(`Adding resource: ${JSON.stringify(e)}`);const t=new fe(this,e);return this._resources.push(t),t}maintain(){let e=!1;const t=[];for(const r of this._resources)r.isDisposed?(this.log.log(`Maintain, disposed resource: ${JSON.stringify(r.data)}`),t.push(r)):r.isExpiredFromUsers&&(this.log.log(`Maintain, expired resource: ${JSON.stringify(r.data)}`),t.push(r));if(t.length>0){for(const r of t)r.dispose("diposed/expired");e=!0}const s=[];for(const[r,i]of this._users.entries())i.isValid||(this.log.log(`Maintain. Invalid user: ${i.key} (Disposed: ${i.isDisposed} Expired: ${i.isExpired} Resource disposed: ${i.resource.isDisposed})`),s.push(r),i._dispose("invalid",i.data));for(const r of s)this._users.delete(r),e=!0;e&&this.log.log(`End: resource len: ${this._resources.length} users: ${this.usersLength}`)}*resources(){const e=[...this._resources];for(const t of e)yield t}*values(){const e=[...this._resources];for(const t of e)yield t.data}release(e,t){const s=this._users.get(e);!s||s.release(t??"Pool.release")}_release(e){this._users.delete(e.key)}_releaseResource(e,t){this._resources=this._resources.filter(s=>s!==e)}hasResource(e){return this._resources.find(s=>s.data===e)!==void 0}hasUser(e){return this._users.has(e)}_assign(e,t){const s=new he(e,t);return this._users.set(e,s),t._assign(s),s}_findUser(e){const t=this.getResourcesSortedByUse();if(t.length>0&&t[0].hasUserCapacity)return this._assign(e,t[0]);if(this.generateResource&&(this.capacity<0||this._resources.length<this.capacity)){this.log.log(`capacity: ${this.capacity} resources: ${this._resources.length}`);const s=this.addResource(this.generateResource());return this._assign(e,s)}}get usersLength(){return[...this._users.values()].length}useValue(e){return this.use(e).resource.data}use(e){const t=this._users.get(e);if(t)return t.keepAlive(),t;this.maintain();const s=this._findUser(e);if(s)return s;if(this.fullPolicy==="error")throw new Error(`Pool is fully used (fullPolicy: ${this.fullPolicy}, capacity: ${this.capacity})`);if(this.fullPolicy==="evictOldestUser"){const r=this.getUsersByLongestElapsed();if(r.length>0){this.release(r[0].key,"evictedOldestUser");const i=this._findUser(e);if(i)return i}}throw new Error(`Pool is fully used (${this.fullPolicy})`)}},Bt=(e={})=>new pe(e),Ft=Math.PI*2,qt={};v(qt,{AudioAnalysers:()=>we,AudioVisualisers:()=>me,Bluetooth:()=>ge,Camera:()=>Se,Codec:()=>B,Espruino:()=>xe,FrameProcessor:()=>Xt,Serial:()=>be,StringReceiveBuffer:()=>F,StringWriteBuffer:()=>q,VideoFile:()=>ke,genericStateTransitionsInstance:()=>U,reconnectingWebsocket:()=>Zt});var ge={};v(ge,{NordicBleDevice:()=>ve,defaultOpts:()=>k});var B=class{enc=new TextEncoder;dec=new TextDecoder("utf-8");toBuffer(e){return this.enc.encode(e)}fromBuffer(e){return this.dec.decode(e)}},F=class{constructor(e,t=`
`){this.onData=e,this.separator=t}buffer="";stream;async close(){const e=this.stream;!e||(await e.abort(),await e.close())}clear(){this.buffer=""}writable(){return this.stream===void 0&&(this.stream=this.createWritable()),this.stream}createWritable(){const e=this;return new WritableStream({write(t){e.add(t)},close(){e.clear()}})}addImpl(e){const t=e.indexOf(this.separator);if(t<0)return this.buffer+=e,"";const s=e.substring(0,t);try{this.onData(this.buffer+s),e=e.substring(s.length+this.separator.length)}catch(r){console.warn(r)}return this.buffer="",e}add(e){for(;e.length>0;)e=this.addImpl(e)}},q=class{constructor(e,t={}){this.dataHandler=e,this.chunkSize=t.chunkSize??-1,this.writer=at(async()=>{await this.onWrite()},t.interval??10)}paused=!1;queue=new E;writer;stream;closed=!1;chunkSize;async close(){if(this.closed)return;const e=this.stream?.getWriter();e?.releaseLock(),await e?.close(),this.closed=!0}clear(){if(this.closed)throw new Error("Buffer closed");this.queue=new E}writable(){if(this.closed)throw new Error("Buffer closed");return this.stream===void 0&&(this.stream=this.createWritable()),this.stream}createWritable(){const e=this;return new WritableStream({write(t){e.add(t)},close(){e.clear()}})}async onWrite(){if(this.queue.isEmpty)return!1;if(this.paused)return console.warn("WriteBuffer.onWrite: paused..."),!0;const e=this.queue.dequeue();return e===void 0?!1:(await this.dataHandler(e),!0)}get isClosed(){return this.closed}add(e){if(this.closed)throw new Error("Buffer closed");this.chunkSize>0?this.queue.enqueue(...pt(e,this.chunkSize)):this.queue.enqueue(e),this.writer.start()}},It=class extends T{constructor(e,t){super();this.device=e,this.config=t,this.verboseLogging=t.debug,this.txBuffer=new q(async s=>{await this.writeInternal(s)},t),this.rxBuffer=new F(s=>{this.fireEvent("data",{data:s})}),this.codec=new B,this.states=new Z(U,{initial:"ready"}),this.states.addEventListener("change",s=>{this.fireEvent("change",s),this.verbose(`${s.priorState} -> ${s.newState}`),s.priorState==="connected"&&(this.rxBuffer.clear(),this.txBuffer.clear())}),e.addEventListener("gattserverdisconnected",()=>{this.isClosed||(this.verbose("GATT server disconnected"),this.states.state="closed")}),this.verbose(`ctor ${e.name} ${e.id}`)}states;codec;rx;tx;gatt;verboseLogging=!1;rxBuffer;txBuffer;get isConnected(){return this.states.state==="connected"}get isClosed(){return this.states.state==="closed"}write(e){if(this.states.state!=="connected")throw new Error(`Cannot write while state is ${this.states.state}`);this.txBuffer.add(e)}async writeInternal(e){this.verbose(`writeInternal ${e}`);const t=this.tx;if(t===void 0)throw new Error("Unexpectedly without tx characteristic");try{await t.writeValue(this.codec.toBuffer(e))}catch(s){this.warn(s)}}disconnect(){this.states.state==="connected"&&this.gatt?.disconnect()}async connect(){const e=this.config.connectAttempts??3;this.states.state="connecting",this.verbose("connect");const t=this.device.gatt;if(t===void 0)throw new Error("Gatt not available on device");await Y(async()=>{this.verbose("connect.retry");const s=await t.connect();this.verbose("Getting primary service");const r=await s.getPrimaryService(this.config.service);this.verbose("Getting characteristics");const i=await r.getCharacteristic(this.config.rxGattCharacteristic),o=await r.getCharacteristic(this.config.txGattCharacteristic);return i.addEventListener("characteristicvaluechanged",n=>{this.onRx(n)}),this.rx=i,this.tx=o,this.gatt=t,this.states.state="connected",await i.startNotifications(),!0},{limitAttempts:e,startAt:200})}onRx(e){if(this.rx===void 0)return;const s=e.target.value;if(s===void 0)return;let r=this.codec.fromBuffer(s.buffer);const i=_(r,19),o=_(r,17);o&&i<o&&(this.verbose("Tx plz start"),r=C(r,o,1),this.txBuffer.paused=!1),i&&i>o&&(this.verbose("Tx plz stop"),r=C(r,i,1),this.txBuffer.paused=!0),this.rxBuffer.add(r)}verbose(e){this.verboseLogging&&console.info(`${this.config.name}`,e)}log(e){console.log(`${this.config.name}`,e)}warn(e){console.warn(`${this.config.name}`,e)}},k={chunkSize:20,service:"6e400001-b5a3-f393-e0a9-e50e24dcca9e",txGattCharacteristic:"6e400002-b5a3-f393-e0a9-e50e24dcca9e",rxGattCharacteristic:"6e400003-b5a3-f393-e0a9-e50e24dcca9e",name:"NordicDevice",connectAttempts:5,debug:!1},ve=class extends It{constructor(e,t={}){super(e,{...k,...t})}},we={};v(we,{AudioAnalyser:()=>M,basic:()=>Lt,freq:()=>Ut,peakLevel:()=>Wt});var me={};v(me,{default:()=>ye});var ye=class{freqMaxRange=200;audio;parent;lastPointer={x:0,y:0};pointerDown=!1;pointerClicking=!1;pointerClickDelayMs=100;pointerDelaying=!1;waveTracker;freqTracker;el;constructor(e,t){this.audio=t,this.parent=e,this.waveTracker=b(),this.freqTracker=b(),e.innerHTML=`
    <section>
      <button id="rendererComponentToggle">\u{1F53C}</button>
      <div>
        <h1>Visualiser</h1>
        <div style="display:flex; flex-wrap: wrap">
          <div class="visPanel">
            <h2>Frequency distribution</h2>
            <br />
            <canvas id="rendererComponentFreqData" height="200" width="400"></canvas>
          </div>
          <div class="visPanel">
            <h2>Waveform</h2>
            <button id="rendererComponentWaveReset">Reset</button>
            <div>
              Press and hold on wave to measure
            </div>
            <br />
            <canvas id="rendererComponentWaveData" height="200" width="400"></canvas>
          </div>
        </div>
      </div>
    </section>
    `,this.el=e.children[0],document.getElementById("rendererComponentToggle")?.addEventListener("click",()=>{this.setExpanded(!this.isExpanded())}),this.el.addEventListener("pointermove",s=>this.onPointer(s)),this.el.addEventListener("pointerup",()=>{this.pointerDelaying=!1,this.pointerDown=!1}),this.el.addEventListener("pointerdown",()=>{this.pointerDelaying=!0,setTimeout(()=>{this.pointerDelaying&&(this.pointerDelaying=!1,this.pointerDown=!0)},this.pointerClickDelayMs)}),this.el.addEventListener("pointerleave",()=>{this.pointerDelaying=!1,this.pointerDown=!1}),document.getElementById("rendererComponentWaveReset")?.addEventListener("click",()=>{this.clear()})}renderFreq(e){if(!this.isExpanded()||!e)return;const t=document.getElementById("rendererComponentFreqData");if(t===null)throw new Error("Cannot find canvas element");const s=t.getContext("2d");if(s===null)throw new Error("Cannot create drawing context");const r=e.length,i=t.clientWidth,o=t.clientHeight;s.clearRect(0,0,i,o);const n=this.getPointerRelativeTo(t),a=i/r,d=D.minMaxAvg(e);for(let c=0;c<r;c++){if(!Number.isFinite(e[c]))continue;const f=(e[c]-d.min)/this.freqMaxRange,l=Math.abs(o*f),p=o-l,m=c/r*360,g=c*a;if(s.fillStyle="hsl("+m+", 100%, 50%)",n.y>0&&n.y<=o&&n.x>=g&&n.x<=g+a){this.freqTracker.id!==c.toString()&&(this.freqTracker=b({id:c.toString()})),this.freqTracker.seen(e[c]);const h=this.freqTracker.getMinMaxAvg();s.fillStyle="black",this.audio&&s.fillText(`Frequency (${c}) at pointer: ${this.audio.getFrequencyAtIndex(c).toLocaleString("en")} - ${this.audio.getFrequencyAtIndex(c+1).toLocaleString("en")}`,2,10),s.fillText(`Raw value: ${e[c].toFixed(2)}`,2,20),s.fillText(`Min: ${h.min.toFixed(2)}`,2,40),s.fillText(`Max: ${h.max.toFixed(2)}`,60,40),s.fillText(`Avg: ${h.avg.toFixed(2)}`,120,40)}s.fillRect(g,p,a,l)}}isExpanded(){const e=this.el.querySelector("div");if(e===null)throw new Error("contents div not found");return e.style.display===""}setExpanded(e){const t=this.el.querySelector("div"),s=this.el.querySelector("button");if(s===null)throw new Error("Button element not found");if(t===null)throw new Error("Contents element not found");e?(t.style.display="",s.innerText="\u{1F53C}"):(t.style.display="none",s.innerText="\u{1F53D}")}clear(){this.clearCanvas(document.getElementById("rendererComponentFreqData")),this.clearCanvas(document.getElementById("rendererComponentWaveData"))}clearCanvas(e){if(e===null)throw new Error("Canvas is null");const t=e.getContext("2d");if(t===null)throw new Error("Cannot create drawing context");t.fillStyle="white",t.fillRect(0,0,e.clientWidth,e.clientHeight)}renderWave(e,t=!0){if(!this.isExpanded()||!e)return;const s=document.getElementById("rendererComponentWaveData");if(s===null)throw new Error("Cannot find wave canvas");const r=s.getContext("2d");if(r===null)throw new Error("Cannot create drawing context for wave");const i=s.clientWidth,o=s.clientHeight,n=this.getPointerRelativeTo(s),a=20,d=60,c=e.length;r.fillStyle="white",r.fillRect(0,0,d,a);const u=i/c;r.fillStyle="rgba(255, 255, 255, 0.03)",r.fillRect(0,20,i,o),r.fillStyle="red",t?r.fillRect(0,o/2,i,1):r.fillRect(0,o-1,i,1),r.lineWidth=1,r.strokeStyle="black",r.beginPath();let f=0;for(let l=0;l<c;l++){const p=e[l]*o,m=t?o/2-p:o-p;l===0?r.moveTo(f,m):r.lineTo(f,m),f+=u,this.pointerDown&&this.waveTracker.seen(e[l])}if(r.lineTo(i,t?o/2:o),r.stroke(),this.pointerDown){const l=this.waveTracker.getMinMaxAvg();r.fillStyle="rgba(255,255,0,1)",r.fillRect(d,0,150,20),r.fillStyle="black",r.fillText("Min: "+l.min.toFixed(2),60,10),r.fillText("Max: "+l.max.toFixed(2),110,10),r.fillText("Avg: "+l.avg.toFixed(2),160,10)}else this.waveTracker.reset();n.y>0&&n.y<=o&&n.x>=0&&n.x<=i&&(r.fillStyle="black",r.fillText("Level: "+(1-n.y/o).toFixed(2),2,10))}getPointerRelativeTo(e){const t=e.getBoundingClientRect();return{x:this.lastPointer.x-t.left-window.scrollX,y:this.lastPointer.y-t.top-window.scrollY}}onPointer(e){this.lastPointer={x:e.pageX,y:e.pageY},e.preventDefault()}},Lt=(e,t={})=>new M((s,r)=>{const i=new Float32Array(s.frequencyBinCount),o=new Float32Array(s.fftSize);s.getFloatFrequencyData(i),s.getFloatTimeDomainData(o),e(i,o,r)},t),Ut=(e,t={})=>new M((s,r)=>{const i=new Float32Array(s.frequencyBinCount);s.getFloatFrequencyData(i),e(i,r)},t),Wt=(e,t={})=>new M((s,r)=>{const i=new Float32Array(s.fftSize);s.getFloatTimeDomainData(i),e(D.maxFast(i),r)},t),M=class{showVis;fftSize;smoothingTimeConstant;#e=!1;debug;#t=!1;visualiser;audioCtx;analyserNode;analyse;constructor(e,t={}){if(this.showVis=t.showVis??!1,this.fftSize=t.fftSize??1024,this.debug=t.debug??!1,this.smoothingTimeConstant=t.smoothingTimeConstant??.8,N(this.fftSize,"positive","opts.fftSize"),y(this.smoothingTimeConstant,"percentage","opts.smoothingTimeConstant"),!ct(this.fftSize))throw new Error(`fftSize must be a power of two from 32 to 32768 (${this.fftSize})`);if(this.fftSize<32)throw new Error("fftSize must be at least 32");if(this.fftSize>32768)throw new Error("fftSize must be no greater than 32768");this.analyse=e,this.paused=!1,this.init();const s=document.getElementById("audio-visualiser");if(s){const r=new ye(s,this);r.setExpanded(this.showVis),this.visualiser=r}}init(){if(this.#t){this.debug&&console.debug("Init already in progress");return}this.#t=!0,navigator.mediaDevices.getUserMedia({audio:!0}).then(e=>{this.onMicSuccess(e)}).catch(e=>{this.#t=!1,console.error(e)})}get paused(){return this.#e}set paused(e){e!==this.#e&&(this.#e=e,e?this.debug&&console.log("Paused"):(this.debug&&console.log("Unpaused"),window.requestAnimationFrame(this.analyseLoop.bind(this))))}setup(e,t){const s=e.createAnalyser();return s.fftSize=this.fftSize,s.smoothingTimeConstant=this.smoothingTimeConstant,e.createMediaStreamSource(t).connect(s),s}onMicSuccess(e){try{const t=new AudioContext;t.addEventListener("statechange",()=>{this.debug&&console.log(`Audio context state: ${t.state}`)}),this.audioCtx=t,this.analyserNode=this.setup(t,e),window.requestAnimationFrame(this.analyseLoop.bind(this))}catch(t){this.#t=!1,console.error(t)}}analyseLoop(){if(this.paused){this.debug&&console.log("Paused");return}const e=this.analyserNode;if(e===void 0){console.warn("Analyser undefined");return}try{this.analyse(e,this)}catch(t){console.error(t)}window.requestAnimationFrame(this.analyseLoop.bind(this))}getFrequencyRangeMax(e,t,s){const r=this.sliceByFrequency(e,t,s);return D.max(r)}sliceByFrequency(e,t,s){const r=this.getIndexForFrequency(e),i=this.getIndexForFrequency(t);return s.slice(r,i)}getFrequencyAtIndex(e){const t=this.analyserNode,s=this.audioCtx;if(t===void 0)throw new Error("Analyser not available");if(s===void 0)throw new Error("Audio context not available");if(N(e,"positive","index"),e>t.frequencyBinCount)throw new Error(`Index ${e} exceeds frequency bin count ${t.frequencyBinCount}`);return e*s.sampleRate/(t.frequencyBinCount*2)}getIndexForFrequency(e){const t=this.analyserNode;if(t===void 0)throw new Error("Analyser not available");const s=t.context.sampleRate/2,r=Math.round(e/s*t.frequencyBinCount);return r<0?0:r>=t.frequencyBinCount?t.frequencyBinCount-1:r}},xe={};v(xe,{EspruinoBleDevice:()=>I,EspruinoSerialDevice:()=>_e,connectBle:()=>Ot,deviceEval:()=>L,puck:()=>Vt,serial:()=>zt});var I=class extends ve{evalTimeoutMs;evalReplyBluetooth=!0;constructor(e,t={}){super(e,t);this.evalTimeoutMs=t.evalTimeoutMs??5*1e3}async writeScript(e){this.write(`reset();
`),this.write(`${e}
`)}async eval(e,t={},s){const r=t.debug??!1;return L(e,t,this,"Bluetooth.println",r,s??(o=>{this.warn(o)}))}},be={};v(be,{Device:()=>Ee});var Nt=class extends T{states;codec;verboseLogging=!1;name;connectAttempts;chunkSize;rxBuffer;txBuffer;constructor(e={}){super();this.verboseLogging=e.debug??!1,this.chunkSize=e.chunkSize??1024,this.connectAttempts=e.connectAttempts??3,this.name=e.name??"JsonDevice",this.txBuffer=new q(async t=>{await this.writeInternal(t)},e),this.rxBuffer=new F(t=>{this.fireEvent("data",{data:t})}),this.codec=new B,this.states=new Z(U,{initial:"ready"}),this.states.addEventListener("change",t=>{this.fireEvent("change",t),this.verbose(`${t.priorState} -> ${t.newState}`),t.priorState==="connected"&&(this.rxBuffer.clear(),this.txBuffer.clear())})}get isConnected(){return this.states.state==="connected"}get isClosed(){return this.states.state==="closed"}write(e){if(this.states.state!=="connected")throw new Error(`Cannot write while state is ${this.states.state}`);this.txBuffer.add(e)}async close(){this.states.state==="connected"&&this.onClosed()}async connect(){const e=this.connectAttempts;this.states.state="connecting",await this.onPreConnect(),await Y(async()=>(await this.onConnectAttempt(),this.states.state="connected",!0),{limitAttempts:e,startAt:200})}onRx(e){const t=e.target.value;if(t===void 0)return;let s=this.codec.fromBuffer(t.buffer);const r=_(s,19),i=_(s,17);i&&r<i&&(this.verbose("Tx plz start"),s=C(s,i,1),this.txBuffer.paused=!1),r&&r>i&&(this.verbose("Tx plz stop"),s=C(s,r,1),this.txBuffer.paused=!0),this.rxBuffer.add(s)}verbose(e){this.verboseLogging&&console.info(`${this.name}`,e)}log(e){console.log(`${this.name}`,e)}warn(e){console.warn(`${this.name}`,e)}},Ee=class extends Nt{constructor(e={}){super(e);this.config=e,this.abort=new AbortController;const t=e.eol??`\r
`;this.baudRate=e.baudRate??9600,e.name===void 0&&(this.name="Serial.Device"),this.rxBuffer.separator=t}port;tx;abort;baudRate;async writeInternal(e){if(this.tx===void 0)throw new Error("tx not ready");try{this.tx.write(e)}catch(t){this.warn(t)}}onClosed(){this.tx?.releaseLock(),this.abort.abort("closing port"),this.states.state="closed"}onPreConnect(){return Promise.resolve()}async onConnectAttempt(){let e={};const t={baudRate:this.baudRate};this.config.filters&&(e={filters:[...this.config.filters]}),this.port=await navigator.serial.requestPort(e),this.port.addEventListener("disconnect",n=>{this.close()}),await this.port.open(t);const s=this.port.writable,r=new TextEncoderStream;s!==null&&(r.readable.pipeTo(s,{signal:this.abort.signal}).catch(n=>{console.log("Serial.onConnectAttempt txText pipe:"),console.log(n)}),this.tx=r.writable.getWriter());const i=this.port.readable,o=new TextDecoderStream;i!==null&&(i.pipeTo(o.writable,{signal:this.abort.signal}).catch(n=>{console.log("Serial.onConnectAttempt rxR pipe:"),console.log(n)}),o.readable.pipeTo(this.rxBuffer.writable(),{signal:this.abort.signal}).catch(n=>{console.log("Serial.onConnectAttempt rxText pipe:"),console.log(n);try{this.port?.close()}catch(a){console.log(a)}}))}},_e=class extends Ee{evalTimeoutMs;evalReplyBluetooth=!1;constructor(e){super(e);e===void 0&&(e={}),this.evalTimeoutMs=e.evalTimeoutMs??5*1e3}async disconnect(){return super.close()}async writeScript(e){this.write(`reset();
`),this.write(`${e}
`)}async eval(e,t={},s){const r=t.debug??!1;return L(e,t,this,"USB.println",r,s??(o=>this.warn(o)))}},Vt=async(e={})=>{const t=e.name??"Puck",s=e.debug??!1,r=await navigator.bluetooth.requestDevice({filters:Ce(e),optionalServices:[k.service]});console.log(r.name);const i=new I(r,{name:t,debug:s});return await i.connect(),i},zt=async(e={})=>{const t=new _e(e);return await t.connect(),t},Ce=e=>{const t=[];return e.filters?t.push(...e.filters):e.name?(t.push({name:e.name}),console.info(`Filtering Bluetooth devices by name '${e.name}'`)):t.push({namePrefix:"Puck.js"}),t},Ot=async(e={})=>{const t=await navigator.bluetooth.requestDevice({filters:Ce(e),optionalServices:[k.service]}),s=new I(t,{name:"Espruino",...e});return await s.connect(),s},L=async(e,t={},s,r,i,o)=>{const n=t.timeoutMs??s.evalTimeoutMs,a=t.assumeExclusive??!0;if(typeof e!="string")throw new TypeError("code parameter should be a string");return new Promise((d,c)=>{const u=gt(5),f=g=>{try{let h=g.data;h.startsWith(">{")&&h.endsWith("}")&&(h=h.slice(1));const w=JSON.parse(h);"reply"in w?w.reply===u?(p(),"result"in w&&d(w.result)):o(`Expected reply ${u}, got ${w.reply}`):o(`Expected packet, missing 'reply' field. Got: ${g.data}`)}catch(h){a?p(g.data):o(h)}},l=g=>{g.newState!=="connected"&&p(`State changed to '${g.newState}', aborting`)};s.addEventListener("data",f),s.addEventListener("change",l);const p=H(n,g=>{c(g)},()=>{s.removeEventListener("data",f),s.removeEventListener("change",l)}),m=`${r}(JSON.stringify({reply:"${u}", result:JSON.stringify(${e})}))
`;i&&o(m),s.write(m)})},Se={};v(Se,{dumpDevices:()=>jt,start:()=>Te});var Gt=1e4,jt=async(e="videoinput")=>{const t=await navigator.mediaDevices.enumerateDevices();for(const s of t)s.kind===e&&(console.log(s.label),console.log(` Kind: ${s.kind}`),console.log(` Device id: ${s.deviceId}`))},Te=async(e={})=>{const t=document.createElement("VIDEO");t.style.display="none",t.playsInline=!0,t.muted=!0,t.classList.add("ixfx-camera"),document.body.append(t);let s=()=>{};const r=()=>{try{s()}catch{}t.remove()};try{return s=(await Jt(t,e)).dispose,{videoEl:t,dispose:r}}catch(i){throw console.error(i),r(),i}},Jt=async(e,t={})=>{if(e===void 0)throw new Error("videoEl undefined");if(e===null)throw new Error("videoEl null");const s=t.max,r=t.min,i=t.ideal,o={audio:!1,video:{width:{},height:{}}};t.facingMode==="front"&&(t={...t,facingMode:"user"}),t.facingMode==="back"&&(t={...t,facingMode:"environment"}),t.facingMode&&(o.video.facingMode=t.facingMode),t.deviceId&&(o.video.deviceId=t.deviceId),i&&(o.video.width={...o.video.width,ideal:i.width},o.video.height={...o.video.height,ideal:i.height}),s&&(o.video.width={...o.video.width,max:s.width},o.video.height={...o.video.height,max:s.height}),r&&(o.video.width={...o.video.width,min:r.width},o.video.height={...o.video.height,min:r.height});const n=H(t.startTimeoutMs??Gt,a=>{throw new Error(`Camera getUserMedia failed: ${a}`)});try{const a=await navigator.mediaDevices.getUserMedia(o),d=()=>{e.pause();const f=a.getTracks();for(const l of f)l.stop()};e.srcObject=a,n();const c={videoEl:e,dispose:d};return new Promise((f,l)=>{e.addEventListener("loadedmetadata",()=>{e.play().then(()=>{f(c)}).catch(p=>{l(p)})})})}catch(a){throw n(X(a)),a}},ke={};v(ke,{start:()=>Me});var Me=async e=>{const t=document.createElement("VIDEO");t.style.display="none",t.playsInline=!0,t.muted=!0,t.classList.add("ixfx-video"),document.body.appendChild(t);let s=()=>{};const r=()=>{try{s()}catch{}t.remove()};try{return s=(await Ht(t,e)).dispose,{videoEl:t,dispose:r}}catch(i){throw console.error(i),r(),i}},Ht=async(e,t)=>{if(e===void 0)throw new Error("videoEl undefined");if(e===null)throw new Error("videoEl null");const s=URL.createObjectURL(t);e.src=s,e.loop=!0;const i={videoEl:e,dispose:()=>{e.pause()}};return new Promise((n,a)=>{e.addEventListener("loadedmetadata",()=>{e.play().then(()=>{n(i)}).catch(d=>{a(d)})})})},Xt=class{_source;_state;_teardownNeeded=!1;_cameraConstraints;_cameraStartResult;_videoSourceCapture;_videoFile;_videoStartResult;_showCanvas;_showPreview;_postCaptureDraw;_timer;_captureCanvasEl;constructor(e={}){this._state="ready",this._source="",this._timer=performance.now(),this._showCanvas=e.showCanvas??!1,this._showPreview=e.showPreview??!1,this._cameraConstraints=e.cameraConstraints??void 0,this._captureCanvasEl=e.captureCanvasEl??void 0,this._postCaptureDraw=e.postCaptureDraw}showPreview(e){if(this._state==="disposed")throw new Error("Disposed");let t;switch(this._source){case"camera":{t=this._cameraStartResult?.videoEl,t!==void 0&&(t.style.display=e?"block":"none");break}}this._showPreview=e}showCanvas(e){if(this._state==="disposed")throw new Error("Disposed");let t;if(this._source==="camera"||this._source==="video")t=this._videoSourceCapture?.canvasEl,t!==void 0&&(t.style.display=e?"block":"none");else throw new Error(`Source not implemented: ${this._source}`);this._showCanvas=e}getCapturer(){if(this._state==="disposed")throw new Error("Disposed");if(this._source==="camera"||this._source==="video")return this._videoSourceCapture;throw new Error(`Source kind not supported ${this._source}`)}async useCamera(e){if(this._state==="disposed")throw new Error("Disposed");this._source="camera",this._teardownNeeded&&this.teardown(),e&&this._cameraConstraints,await this.init()}async useVideo(e){if(this._state==="disposed")throw new Error("Disposed");this._source="video",this._teardownNeeded&&this.teardown(),this._videoFile=e,await this.init()}async initCamera(){const e=await Te(this._cameraConstraints);if(e===void 0)throw new Error("Could not start camera");this._cameraStartResult=e,this.postInit(e)}async initVideo(){if(!this._videoFile)throw new Error("Video file not defined");const e=await Me(this._videoFile);this._videoStartResult=e,this.postInit(e)}async postInit(e){this._showPreview&&(e.videoEl.style.display="block"),this._videoSourceCapture=$e(e.videoEl,{postCaptureDraw:this._postCaptureDraw,showCanvas:this._showCanvas,canvasEl:this._captureCanvasEl}),this._teardownNeeded=!0,this._cameraStartResult=e}dispose(){this._state!=="disposed"&&(this.teardown(),this._state="disposed")}async init(){switch(this._timer=performance.now(),this._source){case"camera":{await this.initCamera();break}case"video":{await this.initVideo();break}}this._state="initialised"}teardown(){if(!!this._teardownNeeded){switch((this._source==="camera"||this._source==="video")&&this._videoSourceCapture?.dispose(),this._source){case"camera":{this._cameraStartResult?.dispose();break}case"video":{this._videoStartResult?.dispose();break}}this._teardownNeeded=!1}}getFrame(){if(this._state==="disposed")throw new Error("Disposed");switch(this._source){case"camera":return this.getFrameCamera();case"video":return this.getFrameCamera();default:throw new Error(`source type unhandled ${this._source}`)}}getTimestamp(){return performance.now()-this._timer}getFrameCamera(){return this._videoSourceCapture?.capture()}},Zt=(e,t={})=>{const s=A(t.startDelay,2e3),r=A(t.maxDelay,s*10),i=A(t.checkStateMs,5e3);if(s>r)throw new Error("startDelay should be less than maxDelay");if(i<0)throw new Error("Param 'checkState' should be above zero");let o=!0,n=x.init({closed:"connecting",open:"closed",connecting:["closed","open"]}),a;const d=h=>{const w=h;console.log("rw on error",h),console.error(` error: ${w.error}`),console.error(` type: ${w.type}`),console.error(` error msg: ${w.message}`)},c=h=>{t.onMessage&&t.onMessage(h.data)},u=async()=>{if(n.value==="connecting")throw new Error("Cannot connect twice");n=x.to(n,"connecting"),a!==void 0&&(a.removeEventListener("error",d),t.onMessage&&a.removeEventListener("message",c),a=void 0);const h=await lt({async probe(Kt){const W=new WebSocket(e);return(await dt(W,["open","error"],{timeout:1e3})).type==="open"?{success:!0,value:W}:{success:!1,value:void 0}}},{predelayMs:s,limitAttempts:t.limitAttempts});a=h.value;let w=!1;return h.success&&a?(a.addEventListener("error",d),t.onMessage&&a.addEventListener("message",c),w=!0,n=x.to(n,"open")):n=x.to(n,"closed"),w},f=h=>{if(a)a.readyState===a.OPEN?a.send(h):l();else throw new Error("Not connected")},l=()=>{n.value!=="closed"&&(n.value==="open"&&(n=x.to(n,"closed")),o&&n.value!=="connecting"&&(console.log("Scheduling connect"),setTimeout(()=>{u()},100)))},p=()=>a?a.readyState===a.OPEN:!1,m=()=>{o=!1,n=x.to(n,"closed"),a?.close()},g=()=>(o=!0,n.value==="open"?Promise.resolve(!0):n.value==="connecting"?Promise.resolve(!1):u());return u(),setInterval(()=>{if(!!a)switch(a.readyState){case a.CLOSED:{n.value==="open"&&l();break}}},i),{send:f,isConnected:p,close:m,open:g}},U=Object.freeze({ready:"connecting",connecting:["connected","closed"],connected:["closed"],closed:"connecting"}),Yt={};v(Yt,{getErrorMessage:()=>X,logColours:()=>ut,logSet:()=>J,logger:()=>ht,resolveLogOption:()=>ft});export{K as N,yt as f};
