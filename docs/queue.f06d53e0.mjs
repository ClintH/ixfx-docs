import { c as createMetadata, a as createAstro, b as createComponent, r as render, d as renderComponent } from './chunks/index.7bfc2e7e.mjs';
import { $ as $$module1, a as $$MainLayout } from './chunks/MainLayout.fae6d6b7.mjs';
import 'shorthash';
import 'serialize-javascript';
import 'preact/hooks';
import 'preact/jsx-runtime';
import 'lit';

const metadata = { "headers": [{ "depth": 2, "slug": "basics", "text": "Basics" }, { "depth": 2, "slug": "iterating", "text": "Iterating" }, { "depth": 2, "slug": "additional-properties", "text": "Additional properties" }, { "depth": 2, "slug": "capacity-limiting", "text": "Capacity limiting" }], "source": '\n[API Docs: Queues](https://clinth.github.io/ixfx/modules/Collections.Queues.html)\n\nA queue stores items like a queue at a bakery. Items added are put at the _back_ of the queue, and if you want to grab an item, you can only see, and grab from the _front_ of the queue. This is useful if you want to process items in the same order as they are added to the queue\n\nIn other words, it is FIFO (first in, first out). If you want last-in first out, see [Stack](../stack/).\n\nThe default implementation in ixfx is immutable, meaning that every operation that changes the queue returns a _new_ queue. A queue instance itself never changes.\n\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueue">Enqueue</button>\n  <button id="btnDequeue">Dequeue</button>\n</div>\n<div class="centered toolbar">\n  <div id="peek"></div>\n</div>\n<div id="vis"></div>\n\n\n## Basics\n\n`enqueue` and `dequeue` are the main means of interacting with a dequeue.\n\n```js\nimport {Queues} from "https://unpkg.com/ixfx/dist/collections.js"\n\n// Initialise\nlet q = Queues.immutable();\n\n// Items are pushed in order from start, so `c`\n// is at the "back", while `a` is at the "front".\nq = q.enqueue(`a`, `b`, `c`);\n\n// Yields `a`\nq.peek;\n\n// Return a new queue with front-most item removed\nq = q.dequeue();\n```\n\n## Iterating\n\nFor the most part, you\'re meant to just access the front-most item of a queue. If you find yourself needing to dig through a queue, it may not be the right data structure.\n\nThat said, there are ways of iterating:\n\n```js\n// Iterate from back-to-front of queue\nq.forEach(item => {\n  // do something with item\n})\n\n// Iterate from front-to-back of queue\nq.forEachFromFront(item => {\n  // do something with item\n});\n```\n\n## Additional properties\n\n```js\n// True if queue is empty\nq.isEmpty;\n\n// How many items in queue\nq.length;\n\n// Returns the underlying array\n// used by the stack. Be careful not to\n// modify or it may break the stack semantics\nq.data;\n```\n\n## Capacity limiting\n\nWhen creating the queue, it\'s possible to set a capacity limit. This can be useful to avoid a _backlog_ of data. For example, if you\'re processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don\'t really care about older things any longer.\n\n```js\nlet q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n```\n\nThe `capacity` naturally sets the total number of items the queue will store. The `discardPolicy` determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is _enqueued_.\n\nValues for `discardPolicy` are:\n* `older`: Removes existing items from the front of the queue to make room for additions. Ie. the oldest items are thrown away\n* `newer`: Removes existing items from the back of the queue to make room for additions. Ie. the newest items are thrown away\n* `additions`: Does not change the existing items, but rather throws away items that are being _enqueued_. \n\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueDiscardVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueueDiscard">Enqueue</button>\n  <button id="btnDequeueDiscard">Dequeue</button>\n  <label for="selDiscard" style="align-self: center">Capacity 3.<br /> Discard policy</label>\n  <select id="selDiscard">\n    <option value="older">older</option>\n    <option value="newer">newer</option>\n    <option value="additions">additions</option>\n  </select>\n</div>\n<div class="centered toolbar">\n  <div id="peekDiscard"></div>\n</div>\n<div id="visDiscard"></div>', "html": '<p><a href="https://clinth.github.io/ixfx/modules/Collections.Queues.html">API Docs: Queues</a></p>\n<p>A queue stores items like a queue at a bakery. Items added are put at the <em>back</em> of the queue, and if you want to grab an item, you can only see, and grab from the <em>front</em> of the queue. This is useful if you want to process items in the same order as they are added to the queue</p>\n<p>In other words, it is FIFO (first in, first out). If you want last-in first out, see <a href="../stack/">Stack</a>.</p>\n<p>The default implementation in ixfx is immutable, meaning that every operation that changes the queue returns a <em>new</em> queue. A queue instance itself never changes.</p>\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueue">Enqueue</button>\n  <button id="btnDequeue">Dequeue</button>\n</div>\n<div class="centered toolbar">\n  <div id="peek"></div>\n</div>\n<div id="vis"></div>\n<h2 id="basics">Basics</h2>\n<p><code is:raw>enqueue</code> and <code is:raw>dequeue</code> are the main means of interacting with a dequeue.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>Queues<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/collections.js"</span>\n\n<span class="token comment">// Initialise</span>\n<span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Items are pushed in order from start, so `c`</span>\n<span class="token comment">// is at the "back", while `a` is at the "front".</span>\nq <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">a</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">b</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">c</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Yields `a`</span>\nq<span class="token punctuation">.</span>peek<span class="token punctuation">;</span>\n\n<span class="token comment">// Return a new queue with front-most item removed</span>\nq <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="iterating">Iterating</h2>\n<p>For the most part, you\'re meant to just access the front-most item of a queue. If you find yourself needing to dig through a queue, it may not be the right data structure.</p>\n<p>That said, there are ways of iterating:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Iterate from back-to-front of queue</span>\nq<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// do something with item</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// Iterate from front-to-back of queue</span>\nq<span class="token punctuation">.</span><span class="token function">forEachFromFront</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// do something with item</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="additional-properties">Additional properties</h2>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// True if queue is empty</span>\nq<span class="token punctuation">.</span>isEmpty<span class="token punctuation">;</span>\n\n<span class="token comment">// How many items in queue</span>\nq<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n\n<span class="token comment">// Returns the underlying array</span>\n<span class="token comment">// used by the stack. Be careful not to</span>\n<span class="token comment">// modify or it may break the stack semantics</span>\nq<span class="token punctuation">.</span>data<span class="token punctuation">;</span></code></pre>\n<h2 id="capacity-limiting">Capacity limiting</h2>\n<p>When creating the queue, it\'s possible to set a capacity limit. This can be useful to avoid a <em>backlog</em> of data. For example, if you\'re processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don\'t really care about older things any longer.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">capacity</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token literal-property property">discardPolicy</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">newer</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>The <code is:raw>capacity</code> naturally sets the total number of items the queue will store. The <code is:raw>discardPolicy</code> determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is <em>enqueued</em>.</p>\n<p>Values for <code is:raw>discardPolicy</code> are:</p>\n<ul>\n<li><code is:raw>older</code>: Removes existing items from the front of the queue to make room for additions. Ie. the oldest items are thrown away</li>\n<li><code is:raw>newer</code>: Removes existing items from the back of the queue to make room for additions. Ie. the newest items are thrown away</li>\n<li><code is:raw>additions</code>: Does not change the existing items, but rather throws away items that are being <em>enqueued</em>.</li>\n</ul>\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueDiscardVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueueDiscard">Enqueue</button>\n  <button id="btnDequeueDiscard">Dequeue</button>\n  <label for="selDiscard" style="align-self: center">Capacity 3.<br /> Discard policy</label>\n  <select id="selDiscard">\n    <option value="older">older</option>\n    <option value="newer">newer</option>\n    <option value="additions">additions</option>\n  </select>\n</div>\n<div class="centered toolbar">\n  <div id="peekDiscard"></div>\n</div>\n<div id="visDiscard"></div>' };
const frontmatter = { "title": "Queue", "astro": { "headers": [{ "depth": 2, "slug": "basics", "text": "Basics" }, { "depth": 2, "slug": "iterating", "text": "Iterating" }, { "depth": 2, "slug": "additional-properties", "text": "Additional properties" }, { "depth": 2, "slug": "capacity-limiting", "text": "Capacity limiting" }], "source": '\n[API Docs: Queues](https://clinth.github.io/ixfx/modules/Collections.Queues.html)\n\nA queue stores items like a queue at a bakery. Items added are put at the _back_ of the queue, and if you want to grab an item, you can only see, and grab from the _front_ of the queue. This is useful if you want to process items in the same order as they are added to the queue\n\nIn other words, it is FIFO (first in, first out). If you want last-in first out, see [Stack](../stack/).\n\nThe default implementation in ixfx is immutable, meaning that every operation that changes the queue returns a _new_ queue. A queue instance itself never changes.\n\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueue">Enqueue</button>\n  <button id="btnDequeue">Dequeue</button>\n</div>\n<div class="centered toolbar">\n  <div id="peek"></div>\n</div>\n<div id="vis"></div>\n\n\n## Basics\n\n`enqueue` and `dequeue` are the main means of interacting with a dequeue.\n\n```js\nimport {Queues} from "https://unpkg.com/ixfx/dist/collections.js"\n\n// Initialise\nlet q = Queues.immutable();\n\n// Items are pushed in order from start, so `c`\n// is at the "back", while `a` is at the "front".\nq = q.enqueue(`a`, `b`, `c`);\n\n// Yields `a`\nq.peek;\n\n// Return a new queue with front-most item removed\nq = q.dequeue();\n```\n\n## Iterating\n\nFor the most part, you\'re meant to just access the front-most item of a queue. If you find yourself needing to dig through a queue, it may not be the right data structure.\n\nThat said, there are ways of iterating:\n\n```js\n// Iterate from back-to-front of queue\nq.forEach(item => {\n  // do something with item\n})\n\n// Iterate from front-to-back of queue\nq.forEachFromFront(item => {\n  // do something with item\n});\n```\n\n## Additional properties\n\n```js\n// True if queue is empty\nq.isEmpty;\n\n// How many items in queue\nq.length;\n\n// Returns the underlying array\n// used by the stack. Be careful not to\n// modify or it may break the stack semantics\nq.data;\n```\n\n## Capacity limiting\n\nWhen creating the queue, it\'s possible to set a capacity limit. This can be useful to avoid a _backlog_ of data. For example, if you\'re processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don\'t really care about older things any longer.\n\n```js\nlet q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n```\n\nThe `capacity` naturally sets the total number of items the queue will store. The `discardPolicy` determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is _enqueued_.\n\nValues for `discardPolicy` are:\n* `older`: Removes existing items from the front of the queue to make room for additions. Ie. the oldest items are thrown away\n* `newer`: Removes existing items from the back of the queue to make room for additions. Ie. the newest items are thrown away\n* `additions`: Does not change the existing items, but rather throws away items that are being _enqueued_. \n\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueDiscardVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueueDiscard">Enqueue</button>\n  <button id="btnDequeueDiscard">Dequeue</button>\n  <label for="selDiscard" style="align-self: center">Capacity 3.<br /> Discard policy</label>\n  <select id="selDiscard">\n    <option value="older">older</option>\n    <option value="newer">newer</option>\n    <option value="additions">additions</option>\n  </select>\n</div>\n<div class="centered toolbar">\n  <div id="peekDiscard"></div>\n</div>\n<div id="visDiscard"></div>', "html": '<p><a href="https://clinth.github.io/ixfx/modules/Collections.Queues.html">API Docs: Queues</a></p>\n<p>A queue stores items like a queue at a bakery. Items added are put at the <em>back</em> of the queue, and if you want to grab an item, you can only see, and grab from the <em>front</em> of the queue. This is useful if you want to process items in the same order as they are added to the queue</p>\n<p>In other words, it is FIFO (first in, first out). If you want last-in first out, see <a href="../stack/">Stack</a>.</p>\n<p>The default implementation in ixfx is immutable, meaning that every operation that changes the queue returns a <em>new</em> queue. A queue instance itself never changes.</p>\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueue">Enqueue</button>\n  <button id="btnDequeue">Dequeue</button>\n</div>\n<div class="centered toolbar">\n  <div id="peek"></div>\n</div>\n<div id="vis"></div>\n<h2 id="basics">Basics</h2>\n<p><code is:raw>enqueue</code> and <code is:raw>dequeue</code> are the main means of interacting with a dequeue.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>Queues<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/collections.js"</span>\n\n<span class="token comment">// Initialise</span>\n<span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Items are pushed in order from start, so `c`</span>\n<span class="token comment">// is at the "back", while `a` is at the "front".</span>\nq <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">a</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">b</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">c</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Yields `a`</span>\nq<span class="token punctuation">.</span>peek<span class="token punctuation">;</span>\n\n<span class="token comment">// Return a new queue with front-most item removed</span>\nq <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="iterating">Iterating</h2>\n<p>For the most part, you\'re meant to just access the front-most item of a queue. If you find yourself needing to dig through a queue, it may not be the right data structure.</p>\n<p>That said, there are ways of iterating:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Iterate from back-to-front of queue</span>\nq<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// do something with item</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// Iterate from front-to-back of queue</span>\nq<span class="token punctuation">.</span><span class="token function">forEachFromFront</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// do something with item</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="additional-properties">Additional properties</h2>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// True if queue is empty</span>\nq<span class="token punctuation">.</span>isEmpty<span class="token punctuation">;</span>\n\n<span class="token comment">// How many items in queue</span>\nq<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n\n<span class="token comment">// Returns the underlying array</span>\n<span class="token comment">// used by the stack. Be careful not to</span>\n<span class="token comment">// modify or it may break the stack semantics</span>\nq<span class="token punctuation">.</span>data<span class="token punctuation">;</span></code></pre>\n<h2 id="capacity-limiting">Capacity limiting</h2>\n<p>When creating the queue, it\'s possible to set a capacity limit. This can be useful to avoid a <em>backlog</em> of data. For example, if you\'re processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don\'t really care about older things any longer.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">capacity</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token literal-property property">discardPolicy</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">newer</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>The <code is:raw>capacity</code> naturally sets the total number of items the queue will store. The <code is:raw>discardPolicy</code> determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is <em>enqueued</em>.</p>\n<p>Values for <code is:raw>discardPolicy</code> are:</p>\n<ul>\n<li><code is:raw>older</code>: Removes existing items from the front of the queue to make room for additions. Ie. the oldest items are thrown away</li>\n<li><code is:raw>newer</code>: Removes existing items from the back of the queue to make room for additions. Ie. the newest items are thrown away</li>\n<li><code is:raw>additions</code>: Does not change the existing items, but rather throws away items that are being <em>enqueued</em>.</li>\n</ul>\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueDiscardVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueueDiscard">Enqueue</button>\n  <button id="btnDequeueDiscard">Dequeue</button>\n  <label for="selDiscard" style="align-self: center">Capacity 3.<br /> Discard policy</label>\n  <select id="selDiscard">\n    <option value="older">older</option>\n    <option value="newer">newer</option>\n    <option value="additions">additions</option>\n  </select>\n</div>\n<div class="centered toolbar">\n  <div id="peekDiscard"></div>\n</div>\n<div id="visDiscard"></div>' } };
const $$metadata = createMetadata("/src/pages/data/collections/queue.md", { modules: [{ module: $$module1, specifier: "../../../layouts/MainLayout.astro", assert: {} }], hydratedComponents: [], clientOnlyComponents: [], hydrationDirectives: /* @__PURE__ */ new Set([]), hoisted: [{ type: "inline", value: `
import '/src/components/data/collections/ArrayVisElement';
import '/src/components/data/collections/QueueDiscardVis';
` }, { type: "inline", value: `
import '/src/components/data/collections/ArrayVisElement';
import '/src/components/data/collections/QueueVis';
` }] });
const $$Astro = createAstro("/src/pages/data/collections/queue.md", "https://clinth.github.io/ixfx-docs/", "file:///Users/af4766/repos/ixfx-docs/");
const $$Queue = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Queue;
  const $$content = { "title": "Queue", "astro": { "headers": [{ "depth": 2, "slug": "basics", "text": "Basics" }, { "depth": 2, "slug": "iterating", "text": "Iterating" }, { "depth": 2, "slug": "additional-properties", "text": "Additional properties" }, { "depth": 2, "slug": "capacity-limiting", "text": "Capacity limiting" }], "source": '\n[API Docs: Queues](https://clinth.github.io/ixfx/modules/Collections.Queues.html)\n\nA queue stores items like a queue at a bakery. Items added are put at the _back_ of the queue, and if you want to grab an item, you can only see, and grab from the _front_ of the queue. This is useful if you want to process items in the same order as they are added to the queue\n\nIn other words, it is FIFO (first in, first out). If you want last-in first out, see [Stack](../stack/).\n\nThe default implementation in ixfx is immutable, meaning that every operation that changes the queue returns a _new_ queue. A queue instance itself never changes.\n\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueue">Enqueue</button>\n  <button id="btnDequeue">Dequeue</button>\n</div>\n<div class="centered toolbar">\n  <div id="peek"></div>\n</div>\n<div id="vis"></div>\n\n\n## Basics\n\n`enqueue` and `dequeue` are the main means of interacting with a dequeue.\n\n```js\nimport {Queues} from "https://unpkg.com/ixfx/dist/collections.js"\n\n// Initialise\nlet q = Queues.immutable();\n\n// Items are pushed in order from start, so `c`\n// is at the "back", while `a` is at the "front".\nq = q.enqueue(`a`, `b`, `c`);\n\n// Yields `a`\nq.peek;\n\n// Return a new queue with front-most item removed\nq = q.dequeue();\n```\n\n## Iterating\n\nFor the most part, you\'re meant to just access the front-most item of a queue. If you find yourself needing to dig through a queue, it may not be the right data structure.\n\nThat said, there are ways of iterating:\n\n```js\n// Iterate from back-to-front of queue\nq.forEach(item => {\n  // do something with item\n})\n\n// Iterate from front-to-back of queue\nq.forEachFromFront(item => {\n  // do something with item\n});\n```\n\n## Additional properties\n\n```js\n// True if queue is empty\nq.isEmpty;\n\n// How many items in queue\nq.length;\n\n// Returns the underlying array\n// used by the stack. Be careful not to\n// modify or it may break the stack semantics\nq.data;\n```\n\n## Capacity limiting\n\nWhen creating the queue, it\'s possible to set a capacity limit. This can be useful to avoid a _backlog_ of data. For example, if you\'re processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don\'t really care about older things any longer.\n\n```js\nlet q = Queues.immutable({capacity: 5, discardPolicy: `newer`});\n```\n\nThe `capacity` naturally sets the total number of items the queue will store. The `discardPolicy` determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is _enqueued_.\n\nValues for `discardPolicy` are:\n* `older`: Removes existing items from the front of the queue to make room for additions. Ie. the oldest items are thrown away\n* `newer`: Removes existing items from the back of the queue to make room for additions. Ie. the newest items are thrown away\n* `additions`: Does not change the existing items, but rather throws away items that are being _enqueued_. \n\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueDiscardVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueueDiscard">Enqueue</button>\n  <button id="btnDequeueDiscard">Dequeue</button>\n  <label for="selDiscard" style="align-self: center">Capacity 3.<br /> Discard policy</label>\n  <select id="selDiscard">\n    <option value="older">older</option>\n    <option value="newer">newer</option>\n    <option value="additions">additions</option>\n  </select>\n</div>\n<div class="centered toolbar">\n  <div id="peekDiscard"></div>\n</div>\n<div id="visDiscard"></div>', "html": '<p><a href="https://clinth.github.io/ixfx/modules/Collections.Queues.html">API Docs: Queues</a></p>\n<p>A queue stores items like a queue at a bakery. Items added are put at the <em>back</em> of the queue, and if you want to grab an item, you can only see, and grab from the <em>front</em> of the queue. This is useful if you want to process items in the same order as they are added to the queue</p>\n<p>In other words, it is FIFO (first in, first out). If you want last-in first out, see <a href="../stack/">Stack</a>.</p>\n<p>The default implementation in ixfx is immutable, meaning that every operation that changes the queue returns a <em>new</em> queue. A queue instance itself never changes.</p>\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueue">Enqueue</button>\n  <button id="btnDequeue">Dequeue</button>\n</div>\n<div class="centered toolbar">\n  <div id="peek"></div>\n</div>\n<div id="vis"></div>\n<h2 id="basics">Basics</h2>\n<p><code is:raw>enqueue</code> and <code is:raw>dequeue</code> are the main means of interacting with a dequeue.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>Queues<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/collections.js"</span>\n\n<span class="token comment">// Initialise</span>\n<span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Items are pushed in order from start, so `c`</span>\n<span class="token comment">// is at the "back", while `a` is at the "front".</span>\nq <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">a</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">b</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">c</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Yields `a`</span>\nq<span class="token punctuation">.</span>peek<span class="token punctuation">;</span>\n\n<span class="token comment">// Return a new queue with front-most item removed</span>\nq <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="iterating">Iterating</h2>\n<p>For the most part, you\'re meant to just access the front-most item of a queue. If you find yourself needing to dig through a queue, it may not be the right data structure.</p>\n<p>That said, there are ways of iterating:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Iterate from back-to-front of queue</span>\nq<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// do something with item</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// Iterate from front-to-back of queue</span>\nq<span class="token punctuation">.</span><span class="token function">forEachFromFront</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// do something with item</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="additional-properties">Additional properties</h2>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// True if queue is empty</span>\nq<span class="token punctuation">.</span>isEmpty<span class="token punctuation">;</span>\n\n<span class="token comment">// How many items in queue</span>\nq<span class="token punctuation">.</span>length<span class="token punctuation">;</span>\n\n<span class="token comment">// Returns the underlying array</span>\n<span class="token comment">// used by the stack. Be careful not to</span>\n<span class="token comment">// modify or it may break the stack semantics</span>\nq<span class="token punctuation">.</span>data<span class="token punctuation">;</span></code></pre>\n<h2 id="capacity-limiting">Capacity limiting</h2>\n<p>When creating the queue, it\'s possible to set a capacity limit. This can be useful to avoid a <em>backlog</em> of data. For example, if you\'re processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don\'t really care about older things any longer.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">capacity</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token literal-property property">discardPolicy</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">newer</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>The <code is:raw>capacity</code> naturally sets the total number of items the queue will store. The <code is:raw>discardPolicy</code> determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is <em>enqueued</em>.</p>\n<p>Values for <code is:raw>discardPolicy</code> are:</p>\n<ul>\n<li><code is:raw>older</code>: Removes existing items from the front of the queue to make room for additions. Ie. the oldest items are thrown away</li>\n<li><code is:raw>newer</code>: Removes existing items from the back of the queue to make room for additions. Ie. the newest items are thrown away</li>\n<li><code is:raw>additions</code>: Does not change the existing items, but rather throws away items that are being <em>enqueued</em>.</li>\n</ul>\n<script type="module" hoist>\nimport \'/src/components/data/collections/ArrayVisElement\';\nimport \'/src/components/data/collections/QueueDiscardVis\';\n<\/script>\n<div class="centered toolbar">\n  <button id="btnEnqueueDiscard">Enqueue</button>\n  <button id="btnDequeueDiscard">Dequeue</button>\n  <label for="selDiscard" style="align-self: center">Capacity 3.<br /> Discard policy</label>\n  <select id="selDiscard">\n    <option value="older">older</option>\n    <option value="newer">newer</option>\n    <option value="additions">additions</option>\n  </select>\n</div>\n<div class="centered toolbar">\n  <div id="peekDiscard"></div>\n</div>\n<div id="visDiscard"></div>' } };
  const SCRIPTS = [
    { props: { "type": "module", "hoist": true }, children: `import '/src/components/data/collections/ArrayVisElement';
import '/src/components/data/collections/QueueDiscardVis';` },
    { props: { "type": "module", "hoist": true }, children: `import '/src/components/data/collections/ArrayVisElement';
import '/src/components/data/collections/QueueVis';` }
  ];
  for (const SCRIPT of SCRIPTS)
    $$result.scripts.add(SCRIPT);
  return render`${renderComponent($$result, "Layout", $$MainLayout, { "content": $$content }, { "default": () => render`<p><a href="https://clinth.github.io/ixfx/modules/Collections.Queues.html">API Docs: Queues</a></p><p>A queue stores items like a queue at a bakery. Items added are put at the <em>back</em> of the queue, and if you want to grab an item, you can only see, and grab from the <em>front</em> of the queue. This is useful if you want to process items in the same order as they are added to the queue</p><p>In other words, it is FIFO (first in, first out). If you want last-in first out, see <a href="../stack/">Stack</a>.</p><p>The default implementation in ixfx is immutable, meaning that every operation that changes the queue returns a <em>new</em> queue. A queue instance itself never changes.</p><div class="centered toolbar">
  <button id="btnEnqueue">Enqueue</button>
  <button id="btnDequeue">Dequeue</button>
</div><div class="centered toolbar">
  <div id="peek"></div>
</div><div id="vis"></div><h2 id="basics">Basics</h2><p><code>enqueue</code> and <code>dequeue</code> are the main means of interacting with a dequeue.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span>Queues<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/collections.js"</span>

<span class="token comment">// Initialise</span>
<span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Items are pushed in order from start, so \`c\`</span>
<span class="token comment">// is at the "back", while \`a\` is at the "front".</span>
q <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">a</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">b</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">c</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Yields \`a\`</span>
q<span class="token punctuation">.</span>peek<span class="token punctuation">;</span>

<span class="token comment">// Return a new queue with front-most item removed</span>
q <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="iterating">Iterating</h2><p>For the most part, you're meant to just access the front-most item of a queue. If you find yourself needing to dig through a queue, it may not be the right data structure.</p><p>That said, there are ways of iterating:</p><pre class="language-js"><code class="language-js"><span class="token comment">// Iterate from back-to-front of queue</span>
q<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// do something with item</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// Iterate from front-to-back of queue</span>
q<span class="token punctuation">.</span><span class="token function">forEachFromFront</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// do something with item</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="additional-properties">Additional properties</h2><pre class="language-js"><code class="language-js"><span class="token comment">// True if queue is empty</span>
q<span class="token punctuation">.</span>isEmpty<span class="token punctuation">;</span>

<span class="token comment">// How many items in queue</span>
q<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

<span class="token comment">// Returns the underlying array</span>
<span class="token comment">// used by the stack. Be careful not to</span>
<span class="token comment">// modify or it may break the stack semantics</span>
q<span class="token punctuation">.</span>data<span class="token punctuation">;</span></code></pre><h2 id="capacity-limiting">Capacity limiting</h2><p>When creating the queue, it's possible to set a capacity limit. This can be useful to avoid a <em>backlog</em> of data. For example, if you're processing a queue of pressure-sensor data, if a burst of new data comes in you would rather process the freshest data first, you don't really care about older things any longer.</p><pre class="language-js"><code class="language-js"><span class="token keyword">let</span> q <span class="token operator">=</span> Queues<span class="token punctuation">.</span><span class="token function">immutable</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">capacity</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token literal-property property">discardPolicy</span><span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">newer</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The <code>capacity</code> naturally sets the total number of items the queue will store. The <code>discardPolicy</code> determines how the size is maintained when the capacity limit is hit. This logic runs whenever something is <em>enqueued</em>.</p><p>Values for <code>discardPolicy</code> are:</p><ul>
<li><code>older</code>: Removes existing items from the front of the queue to make room for additions. Ie. the oldest items are thrown away</li>
<li><code>newer</code>: Removes existing items from the back of the queue to make room for additions. Ie. the newest items are thrown away</li>
<li><code>additions</code>: Does not change the existing items, but rather throws away items that are being <em>enqueued</em>.</li>
</ul><div class="centered toolbar">
  <button id="btnEnqueueDiscard">Enqueue</button>
  <button id="btnDequeueDiscard">Dequeue</button>
  <label for="selDiscard" style="align-self: center">Capacity 3.<br> Discard policy</label>
  <select id="selDiscard">
    <option value="older">older</option>
    <option value="newer">newer</option>
    <option value="additions">additions</option>
  </select>
</div><div class="centered toolbar">
  <div id="peekDiscard"></div>
</div><div id="visDiscard"></div>` })}`;
});

export { $$metadata, $$Queue as default, frontmatter, metadata };
