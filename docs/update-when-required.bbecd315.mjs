import { c as createMetadata, a as createAstro, b as createComponent, r as render, d as renderComponent } from './chunks/index.7bfc2e7e.mjs';
import { $ as $$module1, a as $$MainLayout } from './chunks/MainLayout.fae6d6b7.mjs';
import { $ as $$module2 } from './chunks/DemoElement.a29296a2.mjs';
import 'shorthash';
import 'serialize-javascript';
import 'preact/hooks';
import 'preact/jsx-runtime';
import 'lit';
import 'lit/decorators.js';
import './chunks/styles.9b8f8965.mjs';

const metadata = { "headers": [], "source": '\nLet\'s say you want to fetch live JSON data. It would be rude to the site operator to fetch the data continually, so we want to reduce how often the data is fetched. Polling is one option, but it might that we can\'t really know what the optimum polling rate should be.  \n\n[`updateOutdated`](https://clinth.github.io/ixfx/modules/Flow.html#updateOutdated) addresses this dilemma. It only calls a function if it hasn\'t been called for a while, or never called. If, however, it has recently been called, the last result is returned. It is a similar outcome as [throttle](#throttle) - lots of calls get reduced to an occasional call.\n\nInitialisation takes an async function to run, and a interval.\n\n```js\n// Set up one time.\n// Here we\'re invoking `fetch`, and have a min interval of 5 minutes \nconst fetcher = updateOutdated(async () => {\n    const r = await fetch(`https://jsonplaceholder.typicode.com/todos/1`);\n    return await r.json();\n  }, 5 * 60 * 1000);\n```\n\nSomewhere else in your code, when you need the data, _await_ the fetcher. If it hasn\'t run yet, the callback will run (in this case, fetching JSON data). But if it has run within the last 5 minutes, the cached result will be returned rather than a network request being made again.\n\n```js\n// Returns the JSON data from the fetch request (or a cached copy)\nconst json = await fetcher();\n```\n\n[Online demo](https://clinth.github.io/ixfx-demos/flow/fetch-outdated/) ([source](https://github.com/ClintH/ixfx-demos/tree/main/flow/fetch-outdated))\n\nWhat is useful about this pattern is that when you need the data (ie. `await fetcher()`) you can be ignorant to when or how the data is fetched. \n\nNote that execution blocks until data is fetched, so there may be cases where polling might be more appropriate.\n\n`updateOutdated` has a third parameter determining what happens if the provided function throws an error.\n* "fast": Invocation will happen immediately on next attempt, without waiting.\n* "slow": Next invocation will wait `interval` before being attempted\n* "backoff": Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.', "html": `<p>Let's say you want to fetch live JSON data. It would be rude to the site operator to fetch the data continually, so we want to reduce how often the data is fetched. Polling is one option, but it might that we can't really know what the optimum polling rate should be.</p>
<p><a href="https://clinth.github.io/ixfx/modules/Flow.html#updateOutdated"><code is:raw>updateOutdated</code></a> addresses this dilemma. It only calls a function if it hasn't been called for a while, or never called. If, however, it has recently been called, the last result is returned. It is a similar outcome as <a href="#throttle">throttle</a> - lots of calls get reduced to an occasional call.</p>
<p>Initialisation takes an async function to run, and a interval.</p>
<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Set up one time.</span>
<span class="token comment">// Here we're invoking \`fetch\`, and have a min interval of 5 minutes </span>
<span class="token keyword">const</span> fetcher <span class="token operator">=</span> <span class="token function">updateOutdated</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">https://jsonplaceholder.typicode.com/todos/1</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">await</span> r<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Somewhere else in your code, when you need the data, <em>await</em> the fetcher. If it hasn't run yet, the callback will run (in this case, fetching JSON data). But if it has run within the last 5 minutes, the cached result will be returned rather than a network request being made again.</p>
<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Returns the JSON data from the fetch request (or a cached copy)</span>
<span class="token keyword">const</span> json <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://clinth.github.io/ixfx-demos/flow/fetch-outdated/">Online demo</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/flow/fetch-outdated">source</a>)</p>
<p>What is useful about this pattern is that when you need the data (ie. <code is:raw>await fetcher()</code>) you can be ignorant to when or how the data is fetched.</p>
<p>Note that execution blocks until data is fetched, so there may be cases where polling might be more appropriate.</p>
<p><code is:raw>updateOutdated</code> has a third parameter determining what happens if the provided function throws an error.</p>
<ul>
<li>"fast": Invocation will happen immediately on next attempt, without waiting.</li>
<li>"slow": Next invocation will wait <code is:raw>interval</code> before being attempted</li>
<li>"backoff": Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.</li>
</ul>` };
const frontmatter = { "title": "Update when required", "astro": { "headers": [], "source": '\nLet\'s say you want to fetch live JSON data. It would be rude to the site operator to fetch the data continually, so we want to reduce how often the data is fetched. Polling is one option, but it might that we can\'t really know what the optimum polling rate should be.  \n\n[`updateOutdated`](https://clinth.github.io/ixfx/modules/Flow.html#updateOutdated) addresses this dilemma. It only calls a function if it hasn\'t been called for a while, or never called. If, however, it has recently been called, the last result is returned. It is a similar outcome as [throttle](#throttle) - lots of calls get reduced to an occasional call.\n\nInitialisation takes an async function to run, and a interval.\n\n```js\n// Set up one time.\n// Here we\'re invoking `fetch`, and have a min interval of 5 minutes \nconst fetcher = updateOutdated(async () => {\n    const r = await fetch(`https://jsonplaceholder.typicode.com/todos/1`);\n    return await r.json();\n  }, 5 * 60 * 1000);\n```\n\nSomewhere else in your code, when you need the data, _await_ the fetcher. If it hasn\'t run yet, the callback will run (in this case, fetching JSON data). But if it has run within the last 5 minutes, the cached result will be returned rather than a network request being made again.\n\n```js\n// Returns the JSON data from the fetch request (or a cached copy)\nconst json = await fetcher();\n```\n\n[Online demo](https://clinth.github.io/ixfx-demos/flow/fetch-outdated/) ([source](https://github.com/ClintH/ixfx-demos/tree/main/flow/fetch-outdated))\n\nWhat is useful about this pattern is that when you need the data (ie. `await fetcher()`) you can be ignorant to when or how the data is fetched. \n\nNote that execution blocks until data is fetched, so there may be cases where polling might be more appropriate.\n\n`updateOutdated` has a third parameter determining what happens if the provided function throws an error.\n* "fast": Invocation will happen immediately on next attempt, without waiting.\n* "slow": Next invocation will wait `interval` before being attempted\n* "backoff": Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.', "html": `<p>Let's say you want to fetch live JSON data. It would be rude to the site operator to fetch the data continually, so we want to reduce how often the data is fetched. Polling is one option, but it might that we can't really know what the optimum polling rate should be.</p>
<p><a href="https://clinth.github.io/ixfx/modules/Flow.html#updateOutdated"><code is:raw>updateOutdated</code></a> addresses this dilemma. It only calls a function if it hasn't been called for a while, or never called. If, however, it has recently been called, the last result is returned. It is a similar outcome as <a href="#throttle">throttle</a> - lots of calls get reduced to an occasional call.</p>
<p>Initialisation takes an async function to run, and a interval.</p>
<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Set up one time.</span>
<span class="token comment">// Here we're invoking \`fetch\`, and have a min interval of 5 minutes </span>
<span class="token keyword">const</span> fetcher <span class="token operator">=</span> <span class="token function">updateOutdated</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">https://jsonplaceholder.typicode.com/todos/1</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">await</span> r<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Somewhere else in your code, when you need the data, <em>await</em> the fetcher. If it hasn't run yet, the callback will run (in this case, fetching JSON data). But if it has run within the last 5 minutes, the cached result will be returned rather than a network request being made again.</p>
<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Returns the JSON data from the fetch request (or a cached copy)</span>
<span class="token keyword">const</span> json <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://clinth.github.io/ixfx-demos/flow/fetch-outdated/">Online demo</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/flow/fetch-outdated">source</a>)</p>
<p>What is useful about this pattern is that when you need the data (ie. <code is:raw>await fetcher()</code>) you can be ignorant to when or how the data is fetched.</p>
<p>Note that execution blocks until data is fetched, so there may be cases where polling might be more appropriate.</p>
<p><code is:raw>updateOutdated</code> has a third parameter determining what happens if the provided function throws an error.</p>
<ul>
<li>"fast": Invocation will happen immediately on next attempt, without waiting.</li>
<li>"slow": Next invocation will wait <code is:raw>interval</code> before being attempted</li>
<li>"backoff": Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.</li>
</ul>` } };
const $$metadata = createMetadata("/src/pages/flow/update-when-required.md", { modules: [{ module: $$module1, specifier: "../../layouts/MainLayout.astro", assert: {} }, { module: $$module2, specifier: "../../components/DemoElement.ts", assert: {} }], hydratedComponents: [], clientOnlyComponents: [], hydrationDirectives: /* @__PURE__ */ new Set([]), hoisted: [] });
const $$Astro = createAstro("/src/pages/flow/update-when-required.md", "https://clinth.github.io/ixfx-docs/", "file:///Users/af4766/repos/ixfx-docs/");
const $$UpdateWhenRequired = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$UpdateWhenRequired;
  const $$content = { "title": "Update when required", "astro": { "headers": [], "source": '\nLet\'s say you want to fetch live JSON data. It would be rude to the site operator to fetch the data continually, so we want to reduce how often the data is fetched. Polling is one option, but it might that we can\'t really know what the optimum polling rate should be.  \n\n[`updateOutdated`](https://clinth.github.io/ixfx/modules/Flow.html#updateOutdated) addresses this dilemma. It only calls a function if it hasn\'t been called for a while, or never called. If, however, it has recently been called, the last result is returned. It is a similar outcome as [throttle](#throttle) - lots of calls get reduced to an occasional call.\n\nInitialisation takes an async function to run, and a interval.\n\n```js\n// Set up one time.\n// Here we\'re invoking `fetch`, and have a min interval of 5 minutes \nconst fetcher = updateOutdated(async () => {\n    const r = await fetch(`https://jsonplaceholder.typicode.com/todos/1`);\n    return await r.json();\n  }, 5 * 60 * 1000);\n```\n\nSomewhere else in your code, when you need the data, _await_ the fetcher. If it hasn\'t run yet, the callback will run (in this case, fetching JSON data). But if it has run within the last 5 minutes, the cached result will be returned rather than a network request being made again.\n\n```js\n// Returns the JSON data from the fetch request (or a cached copy)\nconst json = await fetcher();\n```\n\n[Online demo](https://clinth.github.io/ixfx-demos/flow/fetch-outdated/) ([source](https://github.com/ClintH/ixfx-demos/tree/main/flow/fetch-outdated))\n\nWhat is useful about this pattern is that when you need the data (ie. `await fetcher()`) you can be ignorant to when or how the data is fetched. \n\nNote that execution blocks until data is fetched, so there may be cases where polling might be more appropriate.\n\n`updateOutdated` has a third parameter determining what happens if the provided function throws an error.\n* "fast": Invocation will happen immediately on next attempt, without waiting.\n* "slow": Next invocation will wait `interval` before being attempted\n* "backoff": Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.', "html": `<p>Let's say you want to fetch live JSON data. It would be rude to the site operator to fetch the data continually, so we want to reduce how often the data is fetched. Polling is one option, but it might that we can't really know what the optimum polling rate should be.</p>
<p><a href="https://clinth.github.io/ixfx/modules/Flow.html#updateOutdated"><code is:raw>updateOutdated</code></a> addresses this dilemma. It only calls a function if it hasn't been called for a while, or never called. If, however, it has recently been called, the last result is returned. It is a similar outcome as <a href="#throttle">throttle</a> - lots of calls get reduced to an occasional call.</p>
<p>Initialisation takes an async function to run, and a interval.</p>
<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Set up one time.</span>
<span class="token comment">// Here we're invoking \`fetch\`, and have a min interval of 5 minutes </span>
<span class="token keyword">const</span> fetcher <span class="token operator">=</span> <span class="token function">updateOutdated</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">https://jsonplaceholder.typicode.com/todos/1</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">await</span> r<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Somewhere else in your code, when you need the data, <em>await</em> the fetcher. If it hasn't run yet, the callback will run (in this case, fetching JSON data). But if it has run within the last 5 minutes, the cached result will be returned rather than a network request being made again.</p>
<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// Returns the JSON data from the fetch request (or a cached copy)</span>
<span class="token keyword">const</span> json <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><a href="https://clinth.github.io/ixfx-demos/flow/fetch-outdated/">Online demo</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/flow/fetch-outdated">source</a>)</p>
<p>What is useful about this pattern is that when you need the data (ie. <code is:raw>await fetcher()</code>) you can be ignorant to when or how the data is fetched.</p>
<p>Note that execution blocks until data is fetched, so there may be cases where polling might be more appropriate.</p>
<p><code is:raw>updateOutdated</code> has a third parameter determining what happens if the provided function throws an error.</p>
<ul>
<li>"fast": Invocation will happen immediately on next attempt, without waiting.</li>
<li>"slow": Next invocation will wait <code is:raw>interval</code> before being attempted</li>
<li>"backoff": Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.</li>
</ul>` } };
  return render`${renderComponent($$result, "Layout", $$MainLayout, { "content": $$content }, { "default": () => render`<p>Let's say you want to fetch live JSON data. It would be rude to the site operator to fetch the data continually, so we want to reduce how often the data is fetched. Polling is one option, but it might that we can't really know what the optimum polling rate should be.</p><p><a href="https://clinth.github.io/ixfx/modules/Flow.html#updateOutdated"><code>updateOutdated</code></a> addresses this dilemma. It only calls a function if it hasn't been called for a while, or never called. If, however, it has recently been called, the last result is returned. It is a similar outcome as <a href="#throttle">throttle</a> - lots of calls get reduced to an occasional call.</p><p>Initialisation takes an async function to run, and a interval.</p><pre class="language-js"><code class="language-js"><span class="token comment">// Set up one time.</span>
<span class="token comment">// Here we're invoking \`fetch\`, and have a min interval of 5 minutes </span>
<span class="token keyword">const</span> fetcher <span class="token operator">=</span> <span class="token function">updateOutdated</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> r <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">https://jsonplaceholder.typicode.com/todos/1</span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">await</span> r<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Somewhere else in your code, when you need the data, <em>await</em> the fetcher. If it hasn't run yet, the callback will run (in this case, fetching JSON data). But if it has run within the last 5 minutes, the cached result will be returned rather than a network request being made again.</p><pre class="language-js"><code class="language-js"><span class="token comment">// Returns the JSON data from the fetch request (or a cached copy)</span>
<span class="token keyword">const</span> json <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetcher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href="https://clinth.github.io/ixfx-demos/flow/fetch-outdated/">Online demo</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/flow/fetch-outdated">source</a>)</p><p>What is useful about this pattern is that when you need the data (ie. <code>await fetcher()</code>) you can be ignorant to when or how the data is fetched.</p><p>Note that execution blocks until data is fetched, so there may be cases where polling might be more appropriate.</p><p><code>updateOutdated</code> has a third parameter determining what happens if the provided function throws an error.</p><ul>
<li>"fast": Invocation will happen immediately on next attempt, without waiting.</li>
<li>"slow": Next invocation will wait <code>interval</code> before being attempted</li>
<li>"backoff": Attempts will get slower and slower until next success. Interval is multipled by 1.2 each time.</li>
</ul>` })}`;
});

export { $$metadata, $$UpdateWhenRequired as default, frontmatter, metadata };
