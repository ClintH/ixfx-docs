import { c as createMetadata, a as createAstro, b as createComponent, r as render, d as renderComponent } from './chunks/index.7bfc2e7e.mjs';
import { $ as $$module1, a as $$MainLayout } from './chunks/MainLayout.fae6d6b7.mjs';
import { $ as $$module2 } from './chunks/DemoElement.a29296a2.mjs';
import { LitElement, css, html } from 'lit';
import { property } from 'lit/decorators.js';
import { a as Palette_exports, b as DomRx_exports, m as makeHelper, p as point_exports, V as Vector_exports, e as radianToDegree, S as SvgElements_exports, l as line_exports, g as DragDrop_exports } from './chunks/chunk-IYXXLC7L.d562e3d6.mjs';
import { e as elStyles } from './chunks/styles.9b8f8965.mjs';
import 'shorthash';
import 'serialize-javascript';
import 'preact/hooks';
import 'preact/jsx-runtime';

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
const tagName = `vector-element`;
class VectorElement extends LitElement {
  static styles = [
    elStyles,
    css`
      :host {
        color: var(--label-color, green);
      }
      #container {
        display: flex;
        align-items: center;
        flex-direction: column;
      }
      #container>svg {
        touch-action: none;
      }
      .drag-sel {
        outline: 2px solid pink;
      }
  `
  ];
  origin;
  pointB;
  pointA;
  palette;
  dragDisposePtA;
  dragDisposePtB;
  constructor() {
    super();
    this.palette = Palette_exports.create();
    this.palette.setElementBase(this);
    this.width = 300;
    this.height = 300;
    this.origin = { x: 150, y: 150 };
    this.pointA = { x: 150, y: 100 };
    this.pointB = { x: 200, y: 200 };
    DomRx_exports.themeChange().on((records) => {
      this.updated();
    });
  }
  getBounds() {
    const svg = makeHelper(this.shadowRoot.querySelector(`svg`));
    return { width: svg.width, height: svg.height };
  }
  titledPoint(svg, id, pt, title, hidden = false) {
    const poleColour = this.palette.get(`fgDim`, `black`);
    const radius = hidden ? 10 : 5;
    const elem = svg.circle({ radius, ...pt }, { fillStyle: hidden ? `transparent` : poleColour, strokeStyle: `none` }, `#${id}`);
    svg.text(title, point_exports.sum(pt, 5, 20), { fillStyle: poleColour, userSelect: false, strokeStyle: `none` }, `#${id}-label`);
    return elem;
  }
  updatePoints(svg, a = this.pointA, b = this.pointB) {
    this.pointA = a;
    this.pointB = b;
    const line = { a, b };
    const vectorPolar = Vector_exports.fromLinePolar(line);
    const vectorCartesian = Vector_exports.fromLineCartesian(line);
    const event = new CustomEvent(`vector-change`, {
      detail: {
        a: this.pointA,
        b: this.pointB,
        polar: vectorPolar,
        cartesian: vectorCartesian,
        angleDeg: radianToDegree(vectorPolar.angleRadian)
      }
    });
    this.dispatchEvent(event);
    const poleColour = this.palette.get(`fgDim`, `black`);
    const triangleMarker2 = {
      id: `triangle`,
      fillStyle: poleColour,
      strokeWidth: 0
    };
    const edge = svg.line(line, {
      markerEnd: triangleMarker2,
      strokeStyle: poleColour,
      strokeWidth: 4
    }, `#line-a-b`);
    const pointB = this.titledPoint(svg, `point-b`, b, `B ${point_exports.toString(b, 0)}`, true);
    const pointA = this.titledPoint(svg, `point-a`, a, `A ${point_exports.toString(a, 0)}`);
    const lineToY = { a: { x: b.x, y: a.y }, b };
    svg.line(lineToY, { strokeDash: `4`, strokeWidth: 2, strokeStyle: poleColour }, `#line-to-y`);
    const lineToX = { a: { x: b.x, y: a.y }, b: a };
    svg.line(lineToX, { strokeDash: `4`, strokeWidth: 2, strokeStyle: poleColour }, `#line-to-x`);
    return { pointB, pointA, edge };
  }
  renderSvg() {
    if (this.dragDisposePtA !== void 0)
      this.dragDisposePtA();
    if (this.dragDisposePtB !== void 0)
      this.dragDisposePtB();
    const me = this;
    const origin = this.origin;
    const poleColour = this.palette.get(`fgDim`, `black`);
    const svg = makeHelper(this.shadowRoot.querySelector(`svg`));
    svg.clear();
    const arrowPadding = 15;
    const w = svg.width;
    const h = svg.height;
    SvgElements_exports.grid(svg.parent, origin, 25, w, h, { strokeWidth: 2, opacity: 0.3 });
    const triangleMarker = {
      id: `triangle`,
      fillStyle: poleColour,
      strokeWidth: 2
    };
    const poleAxisLineX = line_exports.fromNumbers(arrowPadding, origin.y, w - arrowPadding, origin.y);
    svg.line(poleAxisLineX, {
      fillStyle: `none`,
      markerEnd: triangleMarker,
      markerStart: triangleMarker,
      strokeWidth: 3,
      strokeStyle: poleColour,
      opacity: 0.3
    });
    svg.text(`X`, { x: w - arrowPadding, y: origin.y + 20 }, { strokeStyle: `none`, fillStyle: poleColour });
    const poleAxisLineY = line_exports.fromNumbers(origin.x, arrowPadding, origin.x, h - arrowPadding);
    svg.line(poleAxisLineY, {
      fillStyle: `none`,
      markerEnd: triangleMarker,
      markerStart: triangleMarker,
      strokeWidth: 3,
      strokeStyle: poleColour,
      opacity: 0.3
    });
    svg.text(`Y`, { x: origin.x + 15, y: arrowPadding + 5 }, { strokeStyle: `none`, fillStyle: poleColour });
    const { pointA, pointB } = this.updatePoints(svg);
    this.dragDisposePtA = DragDrop_exports.draggable(pointB, {
      abort(reason, state) {
      },
      progress(state) {
        const token = state.token;
        me.updatePoints(svg, void 0, {
          x: token.x + state.delta.x,
          y: token.y + state.delta.y
        });
        return true;
      },
      start() {
        return { allow: true, token: me.pointB };
      },
      success() {
      }
    });
    this.dragDisposePtB = DragDrop_exports.draggable(pointA, {
      progress(state) {
        const token = state.token;
        me.updatePoints(svg, {
          x: token.x + state.delta.x,
          y: token.y + state.delta.y
        });
        return true;
      },
      start() {
        return { allow: true, token: me.pointA };
      }
    });
  }
  async updated() {
    this.renderSvg();
  }
  render() {
    return html`
      <div id="container">
      <svg style="font-size: 1em" viewBox="0 0 ${this.width} ${this.height}" width=${this.width} height=${this.height}> </svg>
        </div>
          `;
  }
}
__decorateClass([
  property()
], VectorElement.prototype, "width", 2);
__decorateClass([
  property()
], VectorElement.prototype, "height", 2);
customElements.define(tagName, VectorElement);

var $$module3 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  tagName: tagName,
  VectorElement: VectorElement
}, Symbol.toStringTag, { value: 'Module' }));

const metadata = { "headers": [{ "depth": 2, "slug": "cartesian-and-polar", "text": "Cartesian and Polar" }, { "depth": 2, "slug": "uses", "text": "Uses" }, { "depth": 2, "slug": "computing", "text": "Computing" }, { "depth": 1, "slug": "unit-vectors", "text": "Unit vectors" }], "source": '\n<script type="module" hoist>\nimport \'/src/components/ReplPad\';\n<\/script>\n\n<div class="tip">\n<ul>\n<li>Demos <a href="https://clinth.github.io/ixfx-demos/geometry/">Geometry</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/geometry">source</a>)</li>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Geometry.Points.html">Geometry.Points module</a></li>\n</div>\n\nA _vector_ consists of _magnitude_ (which can be thought of as length or distance) and _direction_. In essence, it describes how to go from [Point](./point) A to B.\n\nRead more:\n* [Wikipedia](https://en.wikipedia.org/wiki/Euclidean_vector)\n\n\n## Cartesian and Polar\n\nVectors can be described with [Cartesian](../units/#cartesian) or [polar](../units/#polar) coordinates. In ixfx, type `Vector = Points.Point | Polar.Coord`.\n\n<p>Cartesian: <span id="vector-cartesian">?</span><br />\nPolar: <span id="vector-polar">?</span>\n</p>\n<p></p>\n<vector-element id="vectorIntro" client:visible width="300" height="300"  />\n<script type="module" hoist>\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n<\/script>\n\nWhen expressed in Cartesian coordinates, it\'s not obvious that the vector expresses magnitude and direction. It would seem to be the _x_ and _y_ of a single point in space. Instead, the _x_ value represents the movement along the horizontal axis from the origin, and _y_ represents movement along the vertical axis from the origin.\n\nClick on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.\n\nVectors in Polar coordinates are made up angle and magnitude. In ixfx, `angleRadian` and `distance` are used to denote these components. Polar coordinates better express the meaning of a vector, and you\'re less likely to muddle them up with actual points on a plane.\n\nIn ixfx, vectors can be converted back and forth:\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\nconst vectorCartesian = Vectors.toCartesian(somePolarCoordinate);\nconst vectorPolar = Vectors.toPolar(someCartesianCoordinate);\n```\n\n## Uses\n\nVectors are useful in calculating forces such as velocity and acceleration. \n\nFor example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):\n\n```js\nconst computePosition = (position, velocity) => {\n  return {\n    x: position.x + velocity.x,\n    y: position.y + velocity.y\n  }\n}\n\nconst thing = { x: 100, y: 100 };\nconst velocity = { x: 1, y: 2 };\nconst newPosition = computePosition(thing, velocity);\n```\n\nTo handle either kind of vector notation, we can instead use `Vectors.sum`:\n\n```js\nconst thing = { x: 100, y: 100 };\n\n// Eg. with a Cartesian vector\nconst velocityCartesian = { x: 1, y: 2 };\nconst newPosition = Vectors.sum(thing, velocityCartesian);\n\n// Eg. with a polar vector\nconst velocityPolar = { angleRadian: 0.20, distance: 1 };\nconst newPosition2 = Vectors.sum(thing, velocityPolar);\n```\n\n\n## Computing\n\nVectors can be computed from a line, where it is assumed that the line\'s _a_ property is the start, and _b_ is the end. This gives us direction and magnitude.\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\n\n// repl-pad#1\n// A line\nconst line  { \n  a: { x: 10, y: 10 }, \n  b: { x: 20, y: 20 }\n};\n```\n\nVector in Cartesian coordinates\n\n```js\n// repl-pad#1\nconst vectorCartesian = Vectors.fromLineCartesian(line);\n// Yields: { x: ..., y: ... }\n```\n\nVector in Polar coordinates\n\n```js\n// repl-pad#1\nconst vectorPolar = Vectors.fromLinePolar(line);\n// Yields: { angleRadian: ..., distance: ... }\n```\n\nIf you don\'t already have a Line instance, a vector can be created from two given points using `Points.subtract`\n\n```js\nconst vectorCartestian = Points.subtract(a, b);\n```\n\n`vectorCartesian` will thus be the distance and angle between `a` and `b`.\n# Unit vectors\n\nA _unit vector_, or _normalised vector_ is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.\n\nIt can be produced using `normalise`\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\nconst unitVector = Vectors.normalise({ angleRadian: -0.52, distance: 50 });\n```\n', "html": '<script type="module" hoist>\nimport \'/src/components/ReplPad\';\n<\/script>\n<div class="tip">\n<ul>\n<li>Demos <a href="https://clinth.github.io/ixfx-demos/geometry/">Geometry</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/geometry">source</a>)</li>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Geometry.Points.html">Geometry.Points module</a></li>\n</div>\n<p>A <em>vector</em> consists of <em>magnitude</em> (which can be thought of as length or distance) and <em>direction</em>. In essence, it describes how to go from <a href="./point">Point</a> A to B.</p>\n<p>Read more:</p>\n<ul>\n<li><a href="https://en.wikipedia.org/wiki/Euclidean_vector">Wikipedia</a></li>\n</ul>\n<h2 id="cartesian-and-polar">Cartesian and Polar</h2>\n<p>Vectors can be described with <a href="../units/#cartesian">Cartesian</a> or <a href="../units/#polar">polar</a> coordinates. In ixfx, type <code is:raw>Vector = Points.Point | Polar.Coord</code>.</p>\n<p>Cartesian: <span id="vector-cartesian">?</span><br />\nPolar: <span id="vector-polar">?</span>\n</p>\n<p></p>\n<vector-element id="vectorIntro" client:visible width="300" height="300"  />\n<script type="module" hoist>\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n<\/script>\n<p>When expressed in Cartesian coordinates, it\'s not obvious that the vector expresses magnitude and direction. It would seem to be the <em>x</em> and <em>y</em> of a single point in space. Instead, the <em>x</em> value represents the movement along the horizontal axis from the origin, and <em>y</em> represents movement along the vertical axis from the origin.</p>\n<p>Click on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.</p>\n<p>Vectors in Polar coordinates are made up angle and magnitude. In ixfx, <code is:raw>angleRadian</code> and <code is:raw>distance</code> are used to denote these components. Polar coordinates better express the meaning of a vector, and you\'re less likely to muddle them up with actual points on a plane.</p>\n<p>In ixfx, vectors can be converted back and forth:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toCartesian</span><span class="token punctuation">(</span>somePolarCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toPolar</span><span class="token punctuation">(</span>someCartesianCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="uses">Uses</h2>\n<p>Vectors are useful in calculating forces such as velocity and acceleration.</p>\n<p>For example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">computePosition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> velocity</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">x</span><span class="token operator">:</span> position<span class="token punctuation">.</span>x <span class="token operator">+</span> velocity<span class="token punctuation">.</span>x<span class="token punctuation">,</span>\n    <span class="token literal-property property">y</span><span class="token operator">:</span> position<span class="token punctuation">.</span>y <span class="token operator">+</span> velocity<span class="token punctuation">.</span>y\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> velocity <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition <span class="token operator">=</span> <span class="token function">computePosition</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocity<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>To handle either kind of vector notation, we can instead use <code is:raw>Vectors.sum</code>:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Eg. with a Cartesian vector</span>\n<span class="token keyword">const</span> velocityCartesian <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityCartesian<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Eg. with a polar vector</span>\n<span class="token keyword">const</span> velocityPolar <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token number">0.20</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition2 <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityPolar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="computing">Computing</h2>\n<p>Vectors can be computed from a line, where it is assumed that the line\'s <em>a</em> property is the start, and <em>b</em> is the end. This gives us direction and magnitude.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n\n<span class="token comment">// repl-pad#1</span>\n<span class="token comment">// A line</span>\n<span class="token keyword">const</span> line  <span class="token punctuation">{</span> \n  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>Vector in Cartesian coordinates</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad#1</span>\n<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLineCartesian</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: { x: ..., y: ... }</span></code></pre>\n<p>Vector in Polar coordinates</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad#1</span>\n<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLinePolar</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: { angleRadian: ..., distance: ... }</span></code></pre>\n<p>If you don\'t already have a Line instance, a vector can be created from two given points using <code is:raw>Points.subtract</code></p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> vectorCartestian <span class="token operator">=</span> Points<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p><code is:raw>vectorCartesian</code> will thus be the distance and angle between <code is:raw>a</code> and <code is:raw>b</code>.</p>\n<h1 id="unit-vectors">Unit vectors</h1>\n<p>A <em>unit vector</em>, or <em>normalised vector</em> is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.</p>\n<p>It can be produced using <code is:raw>normalise</code></p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n<span class="token keyword">const</span> unitVector <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">normalise</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">0.52</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>' };
const frontmatter = { "title": "Vector", "astro": { "headers": [{ "depth": 2, "slug": "cartesian-and-polar", "text": "Cartesian and Polar" }, { "depth": 2, "slug": "uses", "text": "Uses" }, { "depth": 2, "slug": "computing", "text": "Computing" }, { "depth": 1, "slug": "unit-vectors", "text": "Unit vectors" }], "source": '\n<script type="module" hoist>\nimport \'/src/components/ReplPad\';\n<\/script>\n\n<div class="tip">\n<ul>\n<li>Demos <a href="https://clinth.github.io/ixfx-demos/geometry/">Geometry</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/geometry">source</a>)</li>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Geometry.Points.html">Geometry.Points module</a></li>\n</div>\n\nA _vector_ consists of _magnitude_ (which can be thought of as length or distance) and _direction_. In essence, it describes how to go from [Point](./point) A to B.\n\nRead more:\n* [Wikipedia](https://en.wikipedia.org/wiki/Euclidean_vector)\n\n\n## Cartesian and Polar\n\nVectors can be described with [Cartesian](../units/#cartesian) or [polar](../units/#polar) coordinates. In ixfx, type `Vector = Points.Point | Polar.Coord`.\n\n<p>Cartesian: <span id="vector-cartesian">?</span><br />\nPolar: <span id="vector-polar">?</span>\n</p>\n<p></p>\n<vector-element id="vectorIntro" client:visible width="300" height="300"  />\n<script type="module" hoist>\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n<\/script>\n\nWhen expressed in Cartesian coordinates, it\'s not obvious that the vector expresses magnitude and direction. It would seem to be the _x_ and _y_ of a single point in space. Instead, the _x_ value represents the movement along the horizontal axis from the origin, and _y_ represents movement along the vertical axis from the origin.\n\nClick on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.\n\nVectors in Polar coordinates are made up angle and magnitude. In ixfx, `angleRadian` and `distance` are used to denote these components. Polar coordinates better express the meaning of a vector, and you\'re less likely to muddle them up with actual points on a plane.\n\nIn ixfx, vectors can be converted back and forth:\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\nconst vectorCartesian = Vectors.toCartesian(somePolarCoordinate);\nconst vectorPolar = Vectors.toPolar(someCartesianCoordinate);\n```\n\n## Uses\n\nVectors are useful in calculating forces such as velocity and acceleration. \n\nFor example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):\n\n```js\nconst computePosition = (position, velocity) => {\n  return {\n    x: position.x + velocity.x,\n    y: position.y + velocity.y\n  }\n}\n\nconst thing = { x: 100, y: 100 };\nconst velocity = { x: 1, y: 2 };\nconst newPosition = computePosition(thing, velocity);\n```\n\nTo handle either kind of vector notation, we can instead use `Vectors.sum`:\n\n```js\nconst thing = { x: 100, y: 100 };\n\n// Eg. with a Cartesian vector\nconst velocityCartesian = { x: 1, y: 2 };\nconst newPosition = Vectors.sum(thing, velocityCartesian);\n\n// Eg. with a polar vector\nconst velocityPolar = { angleRadian: 0.20, distance: 1 };\nconst newPosition2 = Vectors.sum(thing, velocityPolar);\n```\n\n\n## Computing\n\nVectors can be computed from a line, where it is assumed that the line\'s _a_ property is the start, and _b_ is the end. This gives us direction and magnitude.\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\n\n// repl-pad#1\n// A line\nconst line  { \n  a: { x: 10, y: 10 }, \n  b: { x: 20, y: 20 }\n};\n```\n\nVector in Cartesian coordinates\n\n```js\n// repl-pad#1\nconst vectorCartesian = Vectors.fromLineCartesian(line);\n// Yields: { x: ..., y: ... }\n```\n\nVector in Polar coordinates\n\n```js\n// repl-pad#1\nconst vectorPolar = Vectors.fromLinePolar(line);\n// Yields: { angleRadian: ..., distance: ... }\n```\n\nIf you don\'t already have a Line instance, a vector can be created from two given points using `Points.subtract`\n\n```js\nconst vectorCartestian = Points.subtract(a, b);\n```\n\n`vectorCartesian` will thus be the distance and angle between `a` and `b`.\n# Unit vectors\n\nA _unit vector_, or _normalised vector_ is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.\n\nIt can be produced using `normalise`\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\nconst unitVector = Vectors.normalise({ angleRadian: -0.52, distance: 50 });\n```\n', "html": '<script type="module" hoist>\nimport \'/src/components/ReplPad\';\n<\/script>\n<div class="tip">\n<ul>\n<li>Demos <a href="https://clinth.github.io/ixfx-demos/geometry/">Geometry</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/geometry">source</a>)</li>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Geometry.Points.html">Geometry.Points module</a></li>\n</div>\n<p>A <em>vector</em> consists of <em>magnitude</em> (which can be thought of as length or distance) and <em>direction</em>. In essence, it describes how to go from <a href="./point">Point</a> A to B.</p>\n<p>Read more:</p>\n<ul>\n<li><a href="https://en.wikipedia.org/wiki/Euclidean_vector">Wikipedia</a></li>\n</ul>\n<h2 id="cartesian-and-polar">Cartesian and Polar</h2>\n<p>Vectors can be described with <a href="../units/#cartesian">Cartesian</a> or <a href="../units/#polar">polar</a> coordinates. In ixfx, type <code is:raw>Vector = Points.Point | Polar.Coord</code>.</p>\n<p>Cartesian: <span id="vector-cartesian">?</span><br />\nPolar: <span id="vector-polar">?</span>\n</p>\n<p></p>\n<vector-element id="vectorIntro" client:visible width="300" height="300"  />\n<script type="module" hoist>\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n<\/script>\n<p>When expressed in Cartesian coordinates, it\'s not obvious that the vector expresses magnitude and direction. It would seem to be the <em>x</em> and <em>y</em> of a single point in space. Instead, the <em>x</em> value represents the movement along the horizontal axis from the origin, and <em>y</em> represents movement along the vertical axis from the origin.</p>\n<p>Click on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.</p>\n<p>Vectors in Polar coordinates are made up angle and magnitude. In ixfx, <code is:raw>angleRadian</code> and <code is:raw>distance</code> are used to denote these components. Polar coordinates better express the meaning of a vector, and you\'re less likely to muddle them up with actual points on a plane.</p>\n<p>In ixfx, vectors can be converted back and forth:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toCartesian</span><span class="token punctuation">(</span>somePolarCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toPolar</span><span class="token punctuation">(</span>someCartesianCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="uses">Uses</h2>\n<p>Vectors are useful in calculating forces such as velocity and acceleration.</p>\n<p>For example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">computePosition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> velocity</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">x</span><span class="token operator">:</span> position<span class="token punctuation">.</span>x <span class="token operator">+</span> velocity<span class="token punctuation">.</span>x<span class="token punctuation">,</span>\n    <span class="token literal-property property">y</span><span class="token operator">:</span> position<span class="token punctuation">.</span>y <span class="token operator">+</span> velocity<span class="token punctuation">.</span>y\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> velocity <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition <span class="token operator">=</span> <span class="token function">computePosition</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocity<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>To handle either kind of vector notation, we can instead use <code is:raw>Vectors.sum</code>:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Eg. with a Cartesian vector</span>\n<span class="token keyword">const</span> velocityCartesian <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityCartesian<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Eg. with a polar vector</span>\n<span class="token keyword">const</span> velocityPolar <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token number">0.20</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition2 <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityPolar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="computing">Computing</h2>\n<p>Vectors can be computed from a line, where it is assumed that the line\'s <em>a</em> property is the start, and <em>b</em> is the end. This gives us direction and magnitude.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n\n<span class="token comment">// repl-pad#1</span>\n<span class="token comment">// A line</span>\n<span class="token keyword">const</span> line  <span class="token punctuation">{</span> \n  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>Vector in Cartesian coordinates</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad#1</span>\n<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLineCartesian</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: { x: ..., y: ... }</span></code></pre>\n<p>Vector in Polar coordinates</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad#1</span>\n<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLinePolar</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: { angleRadian: ..., distance: ... }</span></code></pre>\n<p>If you don\'t already have a Line instance, a vector can be created from two given points using <code is:raw>Points.subtract</code></p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> vectorCartestian <span class="token operator">=</span> Points<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p><code is:raw>vectorCartesian</code> will thus be the distance and angle between <code is:raw>a</code> and <code is:raw>b</code>.</p>\n<h1 id="unit-vectors">Unit vectors</h1>\n<p>A <em>unit vector</em>, or <em>normalised vector</em> is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.</p>\n<p>It can be produced using <code is:raw>normalise</code></p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n<span class="token keyword">const</span> unitVector <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">normalise</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">0.52</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>' } };
const $$metadata = createMetadata("/src/pages/types/geometry/vector.md", { modules: [{ module: $$module1, specifier: "../../../layouts/MainLayout.astro", assert: {} }, { module: $$module2, specifier: "../../../components/DemoElement.ts", assert: {} }, { module: $$module3, specifier: "/src/components/geometry/VectorElement", assert: {} }], hydratedComponents: ["vector-element"], clientOnlyComponents: [], hydrationDirectives: /* @__PURE__ */ new Set(["visible"]), hoisted: [{ type: "inline", value: `
  const e = document.getElementById(\`vectorIntro\`);
  e.addEventListener(\`vector-change\`, evt => {
    const { cartesian, polar } = evt.detail;
    document.getElementById(\`vector-cartesian\`).innerHTML = \`<code>{ x: \${Math.round(cartesian.x)}, y: \${Math.round(cartesian.y)}}</code>\`;
    document.getElementById(\`vector-polar\`).innerHTML = \`<code>{ distance: \${Math.round(polar.distance)}, angleRadian: \${polar.angleRadian.toFixed(2)}</code>\`;
  })
` }, { type: "inline", value: `
import '/src/components/ReplPad';
` }] });
const $$Astro = createAstro("/src/pages/types/geometry/vector.md", "https://clinth.github.io/ixfx-docs/", "file:///Users/af4766/repos/ixfx-docs/");
const $$Vector = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$Vector;
  const $$content = { "title": "Vector", "astro": { "headers": [{ "depth": 2, "slug": "cartesian-and-polar", "text": "Cartesian and Polar" }, { "depth": 2, "slug": "uses", "text": "Uses" }, { "depth": 2, "slug": "computing", "text": "Computing" }, { "depth": 1, "slug": "unit-vectors", "text": "Unit vectors" }], "source": '\n<script type="module" hoist>\nimport \'/src/components/ReplPad\';\n<\/script>\n\n<div class="tip">\n<ul>\n<li>Demos <a href="https://clinth.github.io/ixfx-demos/geometry/">Geometry</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/geometry">source</a>)</li>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Geometry.Points.html">Geometry.Points module</a></li>\n</div>\n\nA _vector_ consists of _magnitude_ (which can be thought of as length or distance) and _direction_. In essence, it describes how to go from [Point](./point) A to B.\n\nRead more:\n* [Wikipedia](https://en.wikipedia.org/wiki/Euclidean_vector)\n\n\n## Cartesian and Polar\n\nVectors can be described with [Cartesian](../units/#cartesian) or [polar](../units/#polar) coordinates. In ixfx, type `Vector = Points.Point | Polar.Coord`.\n\n<p>Cartesian: <span id="vector-cartesian">?</span><br />\nPolar: <span id="vector-polar">?</span>\n</p>\n<p></p>\n<vector-element id="vectorIntro" client:visible width="300" height="300"  />\n<script type="module" hoist>\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n<\/script>\n\nWhen expressed in Cartesian coordinates, it\'s not obvious that the vector expresses magnitude and direction. It would seem to be the _x_ and _y_ of a single point in space. Instead, the _x_ value represents the movement along the horizontal axis from the origin, and _y_ represents movement along the vertical axis from the origin.\n\nClick on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.\n\nVectors in Polar coordinates are made up angle and magnitude. In ixfx, `angleRadian` and `distance` are used to denote these components. Polar coordinates better express the meaning of a vector, and you\'re less likely to muddle them up with actual points on a plane.\n\nIn ixfx, vectors can be converted back and forth:\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\nconst vectorCartesian = Vectors.toCartesian(somePolarCoordinate);\nconst vectorPolar = Vectors.toPolar(someCartesianCoordinate);\n```\n\n## Uses\n\nVectors are useful in calculating forces such as velocity and acceleration. \n\nFor example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):\n\n```js\nconst computePosition = (position, velocity) => {\n  return {\n    x: position.x + velocity.x,\n    y: position.y + velocity.y\n  }\n}\n\nconst thing = { x: 100, y: 100 };\nconst velocity = { x: 1, y: 2 };\nconst newPosition = computePosition(thing, velocity);\n```\n\nTo handle either kind of vector notation, we can instead use `Vectors.sum`:\n\n```js\nconst thing = { x: 100, y: 100 };\n\n// Eg. with a Cartesian vector\nconst velocityCartesian = { x: 1, y: 2 };\nconst newPosition = Vectors.sum(thing, velocityCartesian);\n\n// Eg. with a polar vector\nconst velocityPolar = { angleRadian: 0.20, distance: 1 };\nconst newPosition2 = Vectors.sum(thing, velocityPolar);\n```\n\n\n## Computing\n\nVectors can be computed from a line, where it is assumed that the line\'s _a_ property is the start, and _b_ is the end. This gives us direction and magnitude.\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\n\n// repl-pad#1\n// A line\nconst line  { \n  a: { x: 10, y: 10 }, \n  b: { x: 20, y: 20 }\n};\n```\n\nVector in Cartesian coordinates\n\n```js\n// repl-pad#1\nconst vectorCartesian = Vectors.fromLineCartesian(line);\n// Yields: { x: ..., y: ... }\n```\n\nVector in Polar coordinates\n\n```js\n// repl-pad#1\nconst vectorPolar = Vectors.fromLinePolar(line);\n// Yields: { angleRadian: ..., distance: ... }\n```\n\nIf you don\'t already have a Line instance, a vector can be created from two given points using `Points.subtract`\n\n```js\nconst vectorCartestian = Points.subtract(a, b);\n```\n\n`vectorCartesian` will thus be the distance and angle between `a` and `b`.\n# Unit vectors\n\nA _unit vector_, or _normalised vector_ is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.\n\nIt can be produced using `normalise`\n\n```js\nimport { Vectors } from "https://unpkg.com/ixfx/dist/geometry.js"\nconst unitVector = Vectors.normalise({ angleRadian: -0.52, distance: 50 });\n```\n', "html": '<script type="module" hoist>\nimport \'/src/components/ReplPad\';\n<\/script>\n<div class="tip">\n<ul>\n<li>Demos <a href="https://clinth.github.io/ixfx-demos/geometry/">Geometry</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/geometry">source</a>)</li>\n<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Geometry.Points.html">Geometry.Points module</a></li>\n</div>\n<p>A <em>vector</em> consists of <em>magnitude</em> (which can be thought of as length or distance) and <em>direction</em>. In essence, it describes how to go from <a href="./point">Point</a> A to B.</p>\n<p>Read more:</p>\n<ul>\n<li><a href="https://en.wikipedia.org/wiki/Euclidean_vector">Wikipedia</a></li>\n</ul>\n<h2 id="cartesian-and-polar">Cartesian and Polar</h2>\n<p>Vectors can be described with <a href="../units/#cartesian">Cartesian</a> or <a href="../units/#polar">polar</a> coordinates. In ixfx, type <code is:raw>Vector = Points.Point | Polar.Coord</code>.</p>\n<p>Cartesian: <span id="vector-cartesian">?</span><br />\nPolar: <span id="vector-polar">?</span>\n</p>\n<p></p>\n<vector-element id="vectorIntro" client:visible width="300" height="300"  />\n<script type="module" hoist>\n  const e = document.getElementById(`vectorIntro`);\n  e.addEventListener(`vector-change`, evt => {\n    const { cartesian, polar } = evt.detail;\n    document.getElementById(`vector-cartesian`).innerHTML = `<code>{ x: ${Math.round(cartesian.x)}, y: ${Math.round(cartesian.y)}}</code>`;\n    document.getElementById(`vector-polar`).innerHTML = `<code>{ distance: ${Math.round(polar.distance)}, angleRadian: ${polar.angleRadian.toFixed(2)}</code>`;\n  })\n<\/script>\n<p>When expressed in Cartesian coordinates, it\'s not obvious that the vector expresses magnitude and direction. It would seem to be the <em>x</em> and <em>y</em> of a single point in space. Instead, the <em>x</em> value represents the movement along the horizontal axis from the origin, and <em>y</em> represents movement along the vertical axis from the origin.</p>\n<p>Click on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.</p>\n<p>Vectors in Polar coordinates are made up angle and magnitude. In ixfx, <code is:raw>angleRadian</code> and <code is:raw>distance</code> are used to denote these components. Polar coordinates better express the meaning of a vector, and you\'re less likely to muddle them up with actual points on a plane.</p>\n<p>In ixfx, vectors can be converted back and forth:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toCartesian</span><span class="token punctuation">(</span>somePolarCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toPolar</span><span class="token punctuation">(</span>someCartesianCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="uses">Uses</h2>\n<p>Vectors are useful in calculating forces such as velocity and acceleration.</p>\n<p>For example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">computePosition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> velocity</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    <span class="token literal-property property">x</span><span class="token operator">:</span> position<span class="token punctuation">.</span>x <span class="token operator">+</span> velocity<span class="token punctuation">.</span>x<span class="token punctuation">,</span>\n    <span class="token literal-property property">y</span><span class="token operator">:</span> position<span class="token punctuation">.</span>y <span class="token operator">+</span> velocity<span class="token punctuation">.</span>y\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> velocity <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition <span class="token operator">=</span> <span class="token function">computePosition</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocity<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>To handle either kind of vector notation, we can instead use <code is:raw>Vectors.sum</code>:</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Eg. with a Cartesian vector</span>\n<span class="token keyword">const</span> velocityCartesian <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityCartesian<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Eg. with a polar vector</span>\n<span class="token keyword">const</span> velocityPolar <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token number">0.20</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> newPosition2 <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityPolar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h2 id="computing">Computing</h2>\n<p>Vectors can be computed from a line, where it is assumed that the line\'s <em>a</em> property is the start, and <em>b</em> is the end. This gives us direction and magnitude.</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n\n<span class="token comment">// repl-pad#1</span>\n<span class="token comment">// A line</span>\n<span class="token keyword">const</span> line  <span class="token punctuation">{</span> \n  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> \n  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>Vector in Cartesian coordinates</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad#1</span>\n<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLineCartesian</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: { x: ..., y: ... }</span></code></pre>\n<p>Vector in Polar coordinates</p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token comment">// repl-pad#1</span>\n<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLinePolar</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Yields: { angleRadian: ..., distance: ... }</span></code></pre>\n<p>If you don\'t already have a Line instance, a vector can be created from two given points using <code is:raw>Points.subtract</code></p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">const</span> vectorCartestian <span class="token operator">=</span> Points<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p><code is:raw>vectorCartesian</code> will thus be the distance and angle between <code is:raw>a</code> and <code is:raw>b</code>.</p>\n<h1 id="unit-vectors">Unit vectors</h1>\n<p>A <em>unit vector</em>, or <em>normalised vector</em> is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.</p>\n<p>It can be produced using <code is:raw>normalise</code></p>\n<pre class="language-js"><code is:raw class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>\n<span class="token keyword">const</span> unitVector <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">normalise</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">0.52</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>' } };
  const SCRIPTS = [
    { props: { "type": "module", "hoist": true }, children: `const e = document.getElementById(\`vectorIntro\`);
  e.addEventListener(\`vector-change\`, evt => {
    const { cartesian, polar } = evt.detail;
    document.getElementById(\`vector-cartesian\`).innerHTML = \`<code>{ x: \${Math.round(cartesian.x)}, y: \${Math.round(cartesian.y)}}</code>\`;
    document.getElementById(\`vector-polar\`).innerHTML = \`<code>{ distance: \${Math.round(polar.distance)}, angleRadian: \${polar.angleRadian.toFixed(2)}</code>\`;
  })` },
    { props: { "type": "module", "hoist": true }, children: `import '/src/components/ReplPad';` }
  ];
  for (const SCRIPT of SCRIPTS)
    $$result.scripts.add(SCRIPT);
  return render`${renderComponent($$result, "Layout", $$MainLayout, { "content": $$content }, { "default": () => render`<div class="tip">
<ul>
<li>Demos <a href="https://clinth.github.io/ixfx-demos/geometry/">Geometry</a> (<a href="https://github.com/ClintH/ixfx-demos/tree/main/geometry">source</a>)</li>
<li>API Reference <a href="https://clinth.github.io/ixfx/modules/Geometry.Points.html">Geometry.Points module</a></li>
</ul></div><p>A <em>vector</em> consists of <em>magnitude</em> (which can be thought of as length or distance) and <em>direction</em>. In essence, it describes how to go from <a href="./point">Point</a> A to B.</p><p>Read more:</p><ul>
<li><a href="https://en.wikipedia.org/wiki/Euclidean_vector">Wikipedia</a></li>
</ul><h2 id="cartesian-and-polar">Cartesian and Polar</h2><p>Vectors can be described with <a href="../units/#cartesian">Cartesian</a> or <a href="../units/#polar">polar</a> coordinates. In ixfx, type <code>Vector = Points.Point | Polar.Coord</code>.</p><p>Cartesian: <span id="vector-cartesian">?</span><br>
Polar: <span id="vector-polar">?</span>
</p><p></p>${renderComponent($$result, "vector-element", "vector-element", { "id": "vectorIntro", "client:visible": true, "width": "300", "height": "300", "client:component-hydration": "visible", "client:component-path": $$metadata.getPath("vector-element"), "client:component-export": $$metadata.getExport("vector-element") })}<p>When expressed in Cartesian coordinates, it's not obvious that the vector expresses magnitude and direction. It would seem to be the <em>x</em> and <em>y</em> of a single point in space. Instead, the <em>x</em> value represents the movement along the horizontal axis from the origin, and <em>y</em> represents movement along the vertical axis from the origin.</p><p>Click on a point in the diagram above and drag it around. Note how the Cartesian vector coordinates are derived from the spatial relationship of A to B, not an actual point in space. This can easily get confusing when mixing and matching different coordinates - some vectors, some actual points.</p><p>Vectors in Polar coordinates are made up angle and magnitude. In ixfx, <code>angleRadian</code> and <code>distance</code> are used to denote these components. Polar coordinates better express the meaning of a vector, and you're less likely to muddle them up with actual points on a plane.</p><p>In ixfx, vectors can be converted back and forth:</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>
<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toCartesian</span><span class="token punctuation">(</span>somePolarCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">toPolar</span><span class="token punctuation">(</span>someCartesianCoordinate<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="uses">Uses</h2><p>Vectors are useful in calculating forces such as velocity and acceleration.</p><p>For example, a vector representing velocity might use the magnitude for speed, and the direction to be the angle of movement. If we want to calculate a new position based on velocity (and assuming a Cartesian velocity):</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> <span class="token function-variable function">computePosition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">position<span class="token punctuation">,</span> velocity</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">x</span><span class="token operator">:</span> position<span class="token punctuation">.</span>x <span class="token operator">+</span> velocity<span class="token punctuation">.</span>x<span class="token punctuation">,</span>
    <span class="token literal-property property">y</span><span class="token operator">:</span> position<span class="token punctuation">.</span>y <span class="token operator">+</span> velocity<span class="token punctuation">.</span>y
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> velocity <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newPosition <span class="token operator">=</span> <span class="token function">computePosition</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocity<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>To handle either kind of vector notation, we can instead use <code>Vectors.sum</code>:</p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> thing <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Eg. with a Cartesian vector</span>
<span class="token keyword">const</span> velocityCartesian <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newPosition <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityCartesian<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Eg. with a polar vector</span>
<span class="token keyword">const</span> velocityPolar <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token number">0.20</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> newPosition2 <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span>thing<span class="token punctuation">,</span> velocityPolar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="computing">Computing</h2><p>Vectors can be computed from a line, where it is assumed that the line's <em>a</em> property is the start, and <em>b</em> is the end. This gives us direction and magnitude.</p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>

<span class="token comment">// repl-pad#1</span>
<span class="token comment">// A line</span>
<span class="token keyword">const</span> line  <span class="token punctuation">{</span> 
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> 
  <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>Vector in Cartesian coordinates</p><pre class="language-js"><code class="language-js"><span class="token comment">// repl-pad#1</span>
<span class="token keyword">const</span> vectorCartesian <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLineCartesian</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Yields: { x: ..., y: ... }</span></code></pre><p>Vector in Polar coordinates</p><pre class="language-js"><code class="language-js"><span class="token comment">// repl-pad#1</span>
<span class="token keyword">const</span> vectorPolar <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">fromLinePolar</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Yields: { angleRadian: ..., distance: ... }</span></code></pre><p>If you don't already have a Line instance, a vector can be created from two given points using <code>Points.subtract</code></p><pre class="language-js"><code class="language-js"><span class="token keyword">const</span> vectorCartestian <span class="token operator">=</span> Points<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>vectorCartesian</code> will thus be the distance and angle between <code>a</code> and <code>b</code>.</p><h1 id="unit-vectors">Unit vectors</h1><p>A <em>unit vector</em>, or <em>normalised vector</em> is a vector that maintains its direction information, but has a magnitude of 1. All it tells then is direction, nothing about how far.</p><p>It can be produced using <code>normalise</code></p><pre class="language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> Vectors <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"https://unpkg.com/ixfx/dist/geometry.js"</span>
<span class="token keyword">const</span> unitVector <span class="token operator">=</span> Vectors<span class="token punctuation">.</span><span class="token function">normalise</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">angleRadian</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">0.52</span><span class="token punctuation">,</span> <span class="token literal-property property">distance</span><span class="token operator">:</span> <span class="token number">50</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>` })}`;
});

export { $$metadata, $$Vector as default, frontmatter, metadata };
