import{m as x,s as A,c as I,r as T,a as W}from"./chunk-LHJ7JM7H.7de6f0d4.js";import{_ as m,a as _,b as q,c as u}from"./chunk-FQLUQVDZ.8e87cdc9.js";import{S as X,n as l,i as $}from"./chunk-JBDRQ5KW.018a4769.js";import{g as z}from"./chunk-EHKPP5SR.5374a9f6.js";var R={};m(R,{byValueString:()=>P,getSorter:()=>V,minMaxAvg:()=>j,sortByKey:()=>w,sortByValueNumber:()=>E,sortByValueString:()=>Z});function N(e,r,t,n,a,o,i,s,h){switch(arguments.length){case 1:return e;case 2:return r(e);case 3:return t(r(e));case 4:return n(t(r(e)));case 5:return a(n(t(r(e))));case 6:return o(a(n(t(r(e)))));case 7:return i(o(a(n(t(r(e))))));case 8:return s(i(o(a(n(t(r(e)))))));case 9:return h(s(i(o(a(n(t(r(e))))))));default:for(var y=arguments[0],g=1;g<arguments.length;g++)y=arguments[g](y);return y}}var C=function(e){return function(r,t){return r===t||e(r,t)===0}},S=function(e){return{equals:C(e),compare:function(r,t){return r===t?0:e(r,t)}}},d=function(e){return S(function(r,t){return e.compare(t,r)})},b=function(e){return function(r){return S(function(t,n){return r.compare(e(t),e(n))})}},k={equals:function(e,r){return e===r}},p={equals:k.equals,compare:function(e,r){return e<r?-1:e>r?1:0}};k.equals,p.compare;var U=function(e){return e.slice()},M=function(e){return function(r){return r.length<=1?U(r):r.slice().sort(e.compare)}},D={equals:function(e,r){return e===r}},v={equals:D.equals,compare:function(e,r){return e<r?-1:e>r?1:0}},J=(e=!1)=>N(e?d(v):v,b(r=>r[0])),P=(e=!1)=>N(e?d(v):v,b(r=>r[1])),L=(e=!1)=>N(e?d(p):p,b(r=>r[1])),w=(e=!1)=>M(J(e)),Z=(e=!1)=>M(P(e)),E=(e=!1)=>M(L(e)),V=e=>{switch(e){case"value":return E(!1);case"valueReverse":return E(!0);case"key":return w(!1);case"keyReverse":return w(!0);default:throw new Error(`Unknown sorting value '${e}'. Expecting: value, valueReverse, key or keyReverse`)}},j=(e,r)=>{r===void 0&&(r=n=>n[1]);const t=e.map(r);return x(t)},H={};m(H,{FrequencyMutable:()=>B,Normalise:()=>G,frequencyMutable:()=>O});var G={};m(G,{array:()=>Y,stream:()=>Q});var Q=(e,r)=>{let t=e??Number.MAX_SAFE_INTEGER,n=r??Number.MIN_SAFE_INTEGER;return a=>(t=Math.min(t,a),n=Math.max(n,a),A(a,t,n))},Y=(e,r,t)=>{if(!Array.isArray(e))throw new Error("values param should be an array");const n=x(e),a=r??n.min,o=t??n.max;return e.map(i=>I(A(i,a,o)))},f,c,B=class extends X{constructor(e=void 0){super();_(this,f,void 0),_(this,c,void 0),q(this,f,new Map),e===void 0&&(e=r=>{if(r===void 0)throw new Error("Cannot create key for undefined");return typeof r=="string"?r:JSON.stringify(r)}),q(this,c,e)}clear(){u(this,f).clear(),this.fireEvent("change",void 0)}keys(){return u(this,f).keys()}values(){return u(this,f).values()}toArray(){return Array.from(u(this,f).entries())}debugString(){let e="";for(const[r,t]of u(this,f).entries())e+=`${r}: ${t}, `;return e.endsWith(", ")?e.substring(0,e.length-2):e}frequencyOf(e){if(typeof e=="string")return u(this,f).get(e);const r=u(this,c).call(this,e);return u(this,f).get(r)}relativeFrequencyOf(e){let r;if(typeof e=="string")r=u(this,f).get(e);else{const n=u(this,c).call(this,e);r=u(this,f).get(n)}if(r===void 0)return;const t=this.minMaxAvg();return r/t.total}entries(){return Array.from(u(this,f).entries())}minMaxAvg(){return R.minMaxAvg(this.entries())}entriesSorted(e="value"){return V(e)(this.entries())}add(...e){if(e===void 0)throw new Error("value parameter is undefined");e.map(u(this,c)).forEach(t=>{const n=u(this,f).get(t)??0;u(this,f).set(t,n+1)}),this.fireEvent("change",void 0)}};f=new WeakMap;c=new WeakMap;var O=e=>new B(e),ee={};m(ee,{count:()=>ae,forEach:()=>ne,numericRange:()=>K,numericRangeRaw:()=>te,pingPong:()=>F,pingPongPercent:()=>re,rangePercent:()=>oe});var re=function(e=.1,r,t,n,a=1e3){return r===void 0&&(r=0),t===void 0&&(t=1),n===void 0&&(n=r),l(e,"bipolar","interval"),l(t,"bipolar","end"),l(n,"bipolar","offset"),l(r,"bipolar","start"),F(e,r,t,n,a)},F=function*(e,r,t,n,a=1){if(Number.isNaN(e))throw new Error("interval parameter is NaN");if(Number.isNaN(r))throw new Error("lower parameter is NaN");if(Number.isNaN(t))throw new Error("upper parameter is NaN");if(Number.isNaN(n))throw new Error("upper parameter is NaN");if(r>=t)throw new Error("lower must be less than upper");if(e===0)throw new Error("Interval cannot be zero");const o=t-r;if(Math.abs(e)>=o)throw new Error(`Interval should be between -${o} and ${o}`);let i=e>0;if(t=Math.floor(t*a),r=Math.floor(r*a),e=Math.floor(Math.abs(e*a)),n===void 0?n=r:n=Math.floor(n*a),n>t||n<r)throw new Error(`Start (${n/a}) must be within lower (${r/a}) and upper (${t/a})`);let s=n;yield s/a;let h=!0;for(;;)s=s+(i?e:-e),i&&s>=t?(i=!1,s=t,s===t&&h&&(s=r,i=!0)):!i&&s<=r&&(i=!0,s=r,s===r&&h&&(s=t,i=!1)),yield s/a,h=!1},te=function*(e,r=0,t,n=!1){if(e<=0)throw new Error("Interval is expected to be above zero");t===void 0&&(t=Number.MAX_SAFE_INTEGER);let a=r;do for(;a<t;)yield a,a+=e;while(n)},ne=(e,r)=>{for(const t of e){const n=r(t);if(typeof n=="boolean"&&!n)break}},K=function*(e,r=0,t,n=!1,a){l(e,"nonZero");const o=e<0;if(t!==void 0){if(o&&r<t)throw new Error(`Interval of ${e} will never go from ${r} to ${t}`);if(!o&&r>t)throw new Error(`Interval of ${e} will never go from ${r} to ${t}`)}a=a??1e3,t===void 0?t=Number.MAX_SAFE_INTEGER:t*=a,e=e*a;do{let i=r*a;for(;!o&&i<=t||o&&i>=t;)yield i/a,i+=e}while(n)},ae=function*(e,r=0){if($(e,"","amount"),$(r,"","offset"),e===0)return;let t=0;do e<0?yield-t+r:yield t+r;while(t++<Math.abs(e)-1)},oe=function(e=.01,r=!1,t=0,n=1){return l(e,"percentage","interval"),l(t,"percentage","start"),l(n,"percentage","end"),K(e,t,n,r)},ie={};m(ie,{arrayElement:()=>T,arrayIndex:()=>W,weighted2:()=>se,weightedInteger:()=>ue});var se=(e,r)=>{const t=Math.random()*r,n=Math.round(r/t);return n>r&&console.log(`r: ${t} x: ${n} min: ${e} max: ${r}`),n},ue=(e,r,t)=>{l(e);let n,a,o;if(o="quadIn",n=0,r===void 0)a=e;else if(typeof r=="number")n=e,a=r,t!==void 0&&(o=t);else if(typeof r=="string")a=e,o=r;else throw new Error(`Unexpected value type for maxOrEasing: ${r}`);t!==void 0&&(o=t);const i=z(o);if(i===void 0)throw new Error(`Easing '${o}' not found`);if(l(n),a<=n)throw new Error("Max should be greater than min");const s=I(i(Math.random()));return Math.floor(s*(a-n))+n};export{ee as G,R as K,ie as R,O as f,V as g};
