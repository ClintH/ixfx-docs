import{a as v,g as w,b as $,c as E,m as k,d as x,s as A,e as S}from"./chunk-RRAKEYPR.51ea3209.js";import{M as D,S as R,n as _,o as Q,h as L,f as j,p as B,s as F,u as K,k as V,v as C,x as N,y as q,z,A as I,B as T,r as H,C as J,D as O,E as P,F as W,j as G,H as U,w as X,I as Y}from"./chunk-HKPWQDQW.6ecee2ff.js";import{_ as p,s as Z,d as i}from"./chunk-L7NPGFXB.2df40d37.js";var tt={};p(tt,{Maps:()=>D,Queues:()=>d,Sets:()=>R,add:()=>_,average:()=>v,del:()=>Q,filter:()=>L,find:()=>j,getMinMaxAvg:()=>w,groupBy:()=>B,guardArray:()=>F,has:()=>K,hasAnyValue:()=>V,hasKeyValue:()=>C,map:()=>N,mapToArray:()=>q,mapToObj:()=>z,mutableCircularArray:()=>$,mutableMap:()=>I,mutableMapArray:()=>E,mutableMapCircular:()=>k,mutableMapSet:()=>x,mutableStringSet:()=>T,queue:()=>M,queueMutable:()=>b,randomElement:()=>H,randomIndex:()=>J,randomPluck:()=>O,set:()=>P,shuffle:()=>W,simpleMutableMapArray:()=>Z,stack:()=>A,stackMutable:()=>S,toArray:()=>G,transformMap:()=>U,without:()=>X,zipKeyValue:()=>Y});var d={};p(d,{OverflowPolicy:()=>l,queue:()=>M,queueMutable:()=>b});var l=(t=>(t[t.DiscardOlder=0]="DiscardOlder",t[t.DiscardNewer=1]="DiscardNewer",t[t.DiscardAdditions=2]="DiscardAdditions",t))(l||{}),h=(t,e)=>{t.debug&&console.log(`queue:${e}`)},et=(t,e,a)=>{const s=e.length+a.length,n=t.capacity??s,r=s-n,u=t.overflowPolicy??2;switch(h(t,`queueLen: ${e.length} potentialLen: ${s} toRemove: ${r} policy: ${l[u]}`),u){case 2:return h(t,`enqueue:DiscardAdditions: queueLen: ${e.length} slice: ${s-n} toAddLen: ${a.length}`),e.length===t.capacity?e:[...e,...a.slice(0,r-1)];case 1:return r>=e.length?a.slice(Math.max(0,a.length-n),Math.min(a.length,n)+1):(h(t,` from orig: ${e.slice(0,r-1)}`),[...e.slice(0,r-1),...a.slice(0,Math.min(a.length,n-r+1))]);case 0:return[...e,...a].slice(r);default:throw new Error(`Unknown overflow policy ${u}`)}},g=(t,e,...a)=>{if(t===void 0)throw new Error("opts parameter undefined");const s=e.length+a.length,n=t.capacity&&s>t.capacity,r=n?et(t,e,a):[...e,...a];if(t.capacity&&r.length!==t.capacity&&n)throw new Error(`Bug! Expected return to be at capacity. Return len: ${r.length} capacity: ${t.capacity} opts: ${JSON.stringify(t)}`);if(!t.capacity&&r.length!==s)throw new Error(`Bug! Return length not expected. Return len: ${r.length} expected: ${s} opts: ${JSON.stringify(t)}`);return r},m=(t,e)=>{if(e.length===0)throw new Error("Queue is empty");return e.slice(1)},c=(t,e)=>e[0],y=(t,e)=>e.length===0,f=(t,e)=>t.capacity?e.length>=t.capacity:!1,o=class{constructor(t,e){if(i(this,"opts"),i(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return new o(this.opts,g(this.opts,this.data,...t))}dequeue(){return new o(this.opts,m(this.opts,this.data))}get isEmpty(){return y(this.opts,this.data)}get isFull(){return f(this.opts,this.data)}get length(){return this.data.length}get peek(){return c(this.opts,this.data)}},M=(t={},...e)=>(t={...t},new o(t,[...e])),at=class{constructor(t,e){if(i(this,"opts"),i(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return this.data=g(this.opts,this.data,...t),this.data.length}dequeue(){const t=c(this.opts,this.data);return this.data=m(this.opts,this.data),t}get isEmpty(){return y(this.opts,this.data)}get isFull(){return f(this.opts,this.data)}get length(){return this.data.length}get peek(){return c(this.opts,this.data)}},b=(t={},...e)=>new at({...t},[...e]);
