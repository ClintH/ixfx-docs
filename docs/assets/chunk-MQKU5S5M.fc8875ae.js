import{A as D,M as O,S as H,s as J,d as $,t as S,e as P,h as U,j as W,k,l as T,w as X}from"./chunk-HF2GNML5.47466bb1.js";import{s as Y,S as Z}from"./chunk-G4S3XAFG.00fb0b2a.js";import{_ as g,a as y,b as u,d as n,c as d}from"./chunk-EGNKYH6P.1933f072.js";var tt={};g(tt,{Arrays:()=>D,Maps:()=>O,Queues:()=>j,Sets:()=>H,Stacks:()=>F,circularArray:()=>_,map:()=>p,mapArray:()=>rt,mapCircular:()=>at,mapMutable:()=>dt,mapSet:()=>st,queue:()=>q,queueMutable:()=>Q,setMutable:()=>J,simpleMapArrayMutable:()=>Y,stack:()=>N,stackMutable:()=>V});var l,c,x=class extends Array{constructor(t=0){super();if(y(this,l,void 0),y(this,c,void 0),Number.isNaN(t))throw Error("capacity is NaN");d(this,l,t),d(this,c,0)}add(t){const e=x.from(this);return e[n(this,c)]=t,d(e,l,n(this,l)),n(this,l)>0?d(e,c,n(this,c)+1===n(this,l)?0:n(this,c)+1):d(e,c,n(this,c)+1),e}get pointer(){return n(this,c)}get isFull(){return n(this,l)===0?!1:this.length===n(this,l)}},et=x;l=new WeakMap;c=new WeakMap;var _=t=>new et(t),h,v=class extends Z{constructor(t,e={}){super();y(this,h,new Map),u(this,"groupBy"),u(this,"type"),this.type=t,this.groupBy=e.groupBy??S}get lengthMax(){let t=0;for(const e of n(this,h).values())t=Math.max(t,this.type.count(e));return t}debugString(){const t=Array.from(n(this,h).keys());let e=`Keys: ${t.join(", ")}\r
`;return t.forEach(r=>{const s=n(this,h).get(r);if(s!==void 0){const i=this.type.toArray(s);i!==void 0&&(e+=` - ${r} (${this.type.count(s)}) = ${JSON.stringify(i)}\r
`)}else e+=` - ${r} (undefined)\r
`}),e}get isEmpty(){return n(this,h).size===0}clear(){n(this,h).clear(),super.fireEvent("clear",!0)}addKeyedValues(t,...e){const r=n(this,h).get(t);r===void 0?(n(this,h).set(t,this.type.add(void 0,e)),super.fireEvent("addedKey",{key:t}),super.fireEvent("addedValues",{values:e})):(n(this,h).set(t,this.type.add(r,e)),super.fireEvent("addedValues",{values:e}))}addValue(...t){t.forEach(e=>this.addKeyedValues(this.groupBy(e),e))}hasKeyValue(t,e){const r=n(this,h).get(t);return r===void 0?!1:this.type.has(r,e)}has(t){return n(this,h).has(t)}deleteKeyValue(t,e){const r=n(this,h).get(t);if(r===void 0)return!1;const s=this.type.count(r),i=this.type.without(r,e),a=i.length;return n(this,h).set(t,this.type.add(void 0,i)),s>a}delete(t){return n(this,h).get(t)===void 0?!1:(n(this,h).delete(t),this.fireEvent("deleteKey",{key:t}),!0)}findKeyForValue(t){return Array.from(n(this,h).keys()).find(s=>{const i=n(this,h).get(s);if(i===void 0)throw Error("Bug: map could not be accessed");return!!this.type.has(i,t)})}count(t){const e=n(this,h).get(t);return e===void 0?0:this.type.count(e)}get(t){const e=n(this,h).get(t);if(e!==void 0)return this.type.toArray(e)}getSource(t){return n(this,h).get(t)}keys(){return Array.from(n(this,h).keys())}keysAndCounts(){return this.keys().map(r=>[r,this.count(r)])}merge(t){t.keys().forEach(r=>{const s=t.get(r);s!==void 0&&this.addKeyedValues(r,...s)})}};h=new WeakMap;var rt=(t={})=>{const e=t.comparer===void 0?t.toString===void 0?(i,a)=>t.toString(i)===t.toString(a):$:t.comparer,r={add:(i,a)=>i===void 0?[...a]:[...i,...a],count:i=>i.length,find:(i,a)=>i.find(a),filter:(i,a)=>i.filter(a),toArray:i=>i,has:(i,a)=>i.find(o=>e(o,a))!==void 0,without:(i,a)=>i.filter(o=>!e(o,a))};return new v(r,t)},st=t=>{const e=t?.hash??S,r=(a,o)=>e(a)===e(o),s={add:(a,o)=>P(a,e,...o),count:a=>a.size,find:(a,o)=>U(a,o),filter:(a,o)=>W(a,o),toArray:a=>k(a),has:(a,o)=>T(a,o,r),without:(a,o)=>X(k(a),o,r)};return new v(s,t)},at=t=>{const e=$,r={add:(s,i)=>(s===void 0&&(s=_(t.capacity)),i.forEach(a=>s=s?.add(a)),s),count:s=>s.length,find:(s,i)=>s.find(i),filter:(s,i)=>s.filter(i),toArray:s=>s,has:(s,i)=>s.find(a=>e(a,i))!==void 0,without:(s,i)=>s.filter(a=>!e(a,i))};return new v(r,t)},F={};g(F,{stack:()=>N,stackMutable:()=>V});var it=(t,e,r)=>{const s=e.length+r.length,i=t.overflowPolicy??"additions",a=t.capacity??s,o=s-a;switch(t.debug&&console.log(`Stack.push: stackLen: ${e.length} potentialLen: ${s} toRemove: ${o} policy: ${i}`),i){case"additions":return t.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${e.length} slice: ${s-a} toAddLen: ${r.length}`),e.length===t.capacity?e:[...e,...r.slice(0,r.length-o)];case"newer":return o>=e.length?r.slice(Math.max(0,r.length-a),Math.min(r.length,a)+1):(t.debug&&console.log(` from orig: ${e.slice(0,o-1)}`),[...e.slice(0,o-1),...r.slice(0,Math.min(r.length,a-o+1))]);case"older":return[...e,...r].slice(o);default:throw new Error(`Unknown overflow policy ${i}`)}},L=(t,e,...r)=>{const s=e.length+r.length;return t.capacity&&s>t.capacity?it(t,e,r):[...e,...r]},A=(t,e)=>{if(e.length===0)throw new Error("Stack is empty");return e.slice(0,e.length-1)},m=(t,e)=>e[e.length-1],R=(t,e)=>e.length===0,K=(t,e)=>t.capacity?e.length>=t.capacity:!1,w=class{constructor(t,e){u(this,"opts"),u(this,"data"),this.opts=t,this.data=e}push(...t){return new w(this.opts,L(this.opts,this.data,...t))}pop(){return new w(this.opts,A(this.opts,this.data))}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}get isEmpty(){return R(this.opts,this.data)}get isFull(){return K(this.opts,this.data)}get peek(){return m(this.opts,this.data)}get length(){return this.data.length}},nt=class{constructor(t,e){u(this,"opts"),u(this,"data"),this.opts=t,this.data=e}push(...t){return this.data=L(this.opts,this.data,...t),this.data.length}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}pop(){const t=m(this.opts,this.data);return A(this.opts,this.data),t}get isEmpty(){return R(this.opts,this.data)}get isFull(){return K(this.opts,this.data)}get peek(){return m(this.opts,this.data)}get length(){return this.data.length}},N=(t={},...e)=>new w({...t},[...e]),V=(t,...e)=>new nt({...t},[...e]),j={};g(j,{queue:()=>q,queueMutable:()=>Q});var E=(t,e)=>{t.debug&&console.log(`queue:${e}`)},ot=(t,e,r)=>{const s=e.length+r.length,i=t.capacity??s,a=s-i,o=t.discardPolicy??"additions";switch(E(t,`queueLen: ${e.length} potentialLen: ${s} toRemove: ${a} policy: ${o}`),o){case"additions":return E(t,`enqueue:DiscardAdditions: queueLen: ${e.length} slice: ${s-i} toAddLen: ${r.length}`),e.length===t.capacity?e:[...e,...r.slice(0,a-1)];case"newer":return a>=e.length?r.slice(Math.max(0,r.length-i),Math.min(r.length,i)+1):(E(t,` from orig: ${e.slice(0,a-1)}`),[...e.slice(0,a-1),...r.slice(0,Math.min(r.length,i-a+1))]);case"older":return[...e,...r].slice(a);default:throw new Error(`Unknown overflow policy ${o}`)}},B=(t,e,...r)=>{if(t===void 0)throw new Error("opts parameter undefined");const s=e.length+r.length,i=t.capacity&&s>t.capacity,a=i?ot(t,e,r):[...e,...r];if(t.capacity&&a.length!==t.capacity&&i)throw new Error(`Bug! Expected return to be at capacity. Return len: ${a.length} capacity: ${t.capacity} opts: ${JSON.stringify(t)}`);if(!t.capacity&&a.length!==s)throw new Error(`Bug! Return length not expected. Return len: ${a.length} expected: ${s} opts: ${JSON.stringify(t)}`);return a},z=(t,e)=>{if(e.length===0)throw new Error("Queue is empty");return e.slice(1)},M=(t,e)=>e[0],C=(t,e)=>e.length===0,I=(t,e)=>t.capacity?e.length>=t.capacity:!1,b=class{constructor(t,e){if(u(this,"opts"),u(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return new b(this.opts,B(this.opts,this.data,...t))}dequeue(){return new b(this.opts,z(this.opts,this.data))}get isEmpty(){return C(this.opts,this.data)}get isFull(){return I(this.opts,this.data)}get length(){return this.data.length}get peek(){return M(this.opts,this.data)}},ht=class{constructor(t,e){if(u(this,"opts"),u(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return this.data=B(this.opts,this.data,...t),this.data.length}dequeue(){const t=M(this.opts,this.data);return this.data=z(this.opts,this.data),t}get isEmpty(){return C(this.opts,this.data)}get isFull(){return I(this.opts,this.data)}get length(){return this.data.length}get peek(){return M(this.opts,this.data)}},q=(t={},...e)=>(t={...t},new b(t,[...e])),Q=(t={},...e)=>new ht({...t},[...e]),ut=(t,e)=>{const r=new Map(t.entries());return e.forEach(s=>{if(s[0]===void 0)throw new Error("key cannot be undefined");if(s[1]===void 0)throw new Error("value cannot be undefined");r.set(s[0],s[1])}),r},ct=(t,e)=>{const r=new Map(t.entries());return e.forEach(s=>{if(s.key===void 0)throw new Error("key cannot be undefined");if(s.value===void 0)throw new Error("value cannot be undefined");r.set(s.key,s.value)}),r},lt=(t,e)=>t.has(e),f=(t,...e)=>{if(t===void 0)throw new Error("map parameter is undefined");if(e===void 0)throw new Error("data parameter i.s undefined");if(e.length===0)return t;const r=e[0];return typeof r.key!="undefined"&&typeof r.value!="undefined"?ct(t,e):ut(t,e)},pt=(t,e,r)=>{const s=new Map(t.entries());return s.set(e,r),s},G=(t,e)=>{const r=new Map(t.entries());return r.delete(e),r},p=t=>{if(t===void 0)return p([]);if(Array.isArray(t))return p(f(new Map,...t));const e=t;return{add:(...r)=>{const s=f(e,...r);return p(s)},get:r=>e.get(r),delete:r=>p(G(e,r)),clear:()=>p(),has:r=>e.has(r),entries:()=>e.entries(),isEmpty:()=>e.size===0}},dt=(...t)=>{let e=f(new Map,...t);return{add:(...r)=>{e=f(e,...r)},delete:r=>{e=G(e,r)},clear:()=>{e=f(new Map)},set:(r,s)=>{e=pt(e,r,s)},get:r=>e.get(r),entries:()=>e.entries(),isEmpty:()=>e.size===0,has:r=>lt(e,r)}};export{at as m,N as s};
