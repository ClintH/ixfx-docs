import{a as v,g as w,b as E,c as $,m as k,d as x,s as S,e as A}from"./chunk-O3VPZBOU.e8cd7407.js";import{n as L,S as _,o as B,p as D,h as R,f as V,u as j,v as F,x as Q,k as C,y as K,z as N,B as q,C as z,D as I,E as O,r as T,F as J,H as U,I as G,J as H,j as P,K as X,w as Z,L as W}from"./chunk-RELB4ERA.359f0ce7.js";import{_ as p,s as Y,d as i}from"./chunk-L7NPGFXB.27ec158a.js";var tt={};p(tt,{Maps:()=>L,Queues:()=>d,Sets:()=>_,add:()=>B,average:()=>v,del:()=>D,filter:()=>R,find:()=>V,getMinMaxAvg:()=>w,groupBy:()=>j,guardArray:()=>F,has:()=>Q,hasAnyValue:()=>C,hasKeyValue:()=>K,map:()=>N,mapToArray:()=>q,mapToObj:()=>z,mutableCircularArray:()=>E,mutableMap:()=>I,mutableMapArray:()=>$,mutableMapCircular:()=>k,mutableMapSet:()=>x,mutableStringSet:()=>O,queue:()=>M,queueMutable:()=>b,randomElement:()=>T,randomIndex:()=>J,randomPluck:()=>U,set:()=>G,shuffle:()=>H,simpleMutableMapArray:()=>Y,stack:()=>S,stackMutable:()=>A,toArray:()=>P,transformMap:()=>X,without:()=>Z,zipKeyValue:()=>W});var d={};p(d,{OverflowPolicy:()=>l,queue:()=>M,queueMutable:()=>b});var l=(t=>(t[t.DiscardOlder=0]="DiscardOlder",t[t.DiscardNewer=1]="DiscardNewer",t[t.DiscardAdditions=2]="DiscardAdditions",t))(l||{}),h=(t,e)=>{t.debug&&console.log(`queue:${e}`)},et=(t,e,a)=>{const s=e.length+a.length,n=t.capacity??s,r=s-n,u=t.overflowPolicy??2;switch(h(t,`queueLen: ${e.length} potentialLen: ${s} toRemove: ${r} policy: ${l[u]}`),u){case 2:return h(t,`enqueue:DiscardAdditions: queueLen: ${e.length} slice: ${s-n} toAddLen: ${a.length}`),e.length===t.capacity?e:[...e,...a.slice(0,r-1)];case 1:return r>=e.length?a.slice(Math.max(0,a.length-n),Math.min(a.length,n)+1):(h(t,` from orig: ${e.slice(0,r-1)}`),[...e.slice(0,r-1),...a.slice(0,Math.min(a.length,n-r+1))]);case 0:return[...e,...a].slice(r);default:throw new Error(`Unknown overflow policy ${u}`)}},g=(t,e,...a)=>{if(t===void 0)throw new Error("opts parameter undefined");const s=e.length+a.length,n=t.capacity&&s>t.capacity,r=n?et(t,e,a):[...e,...a];if(t.capacity&&r.length!==t.capacity&&n)throw new Error(`Bug! Expected return to be at capacity. Return len: ${r.length} capacity: ${t.capacity} opts: ${JSON.stringify(t)}`);if(!t.capacity&&r.length!==s)throw new Error(`Bug! Return length not expected. Return len: ${r.length} expected: ${s} opts: ${JSON.stringify(t)}`);return r},m=(t,e)=>{if(e.length===0)throw new Error("Queue is empty");return e.slice(1)},c=(t,e)=>e[0],y=(t,e)=>e.length===0,f=(t,e)=>t.capacity?e.length>=t.capacity:!1,o=class{constructor(t,e){if(i(this,"opts"),i(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return new o(this.opts,g(this.opts,this.data,...t))}dequeue(){return new o(this.opts,m(this.opts,this.data))}get isEmpty(){return y(this.opts,this.data)}get isFull(){return f(this.opts,this.data)}get length(){return this.data.length}get peek(){return c(this.opts,this.data)}},M=(t={},...e)=>(t={...t},new o(t,[...e])),at=class{constructor(t,e){if(i(this,"opts"),i(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return this.data=g(this.opts,this.data,...t),this.data.length}dequeue(){const t=c(this.opts,this.data);return this.data=m(this.opts,this.data),t}get isEmpty(){return y(this.opts,this.data)}get isFull(){return f(this.opts,this.data)}get length(){return this.data.length}get peek(){return c(this.opts,this.data)}},b=(t={},...e)=>new at({...t},[...e]);
