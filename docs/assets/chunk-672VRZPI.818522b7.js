import{A as T,M as U,S as W,s as G,i as x,t as _,a as H,f as Y,b as X,c as F,h as Z,w as tt}from"./chunk-V2CC3OS2.f8999184.js";import{s as et,S as rt,i as at}from"./chunk-E6FEPMVF.c62dcddf.js";import{_ as y,a as v,b as u,d as n,c as d}from"./chunk-YDTVC7MM.cb3895f8.js";var it={};y(it,{Arrays:()=>T,Maps:()=>U,Queues:()=>N,Sets:()=>W,Stacks:()=>L,circularArray:()=>V,map:()=>p,mapArray:()=>nt,mapCircular:()=>ht,mapMutable:()=>vt,mapSet:()=>ot,queue:()=>D,queueMutable:()=>q,setMutable:()=>G,simpleMapArrayMutable:()=>et,stack:()=>Q,stackMutable:()=>B});var l,c,A=class extends Array{constructor(t=0){super();v(this,l,void 0),v(this,c,void 0),at(t,"positive","capacity"),d(this,l,t),d(this,c,0)}add(t){const e=A.from(this);return e[n(this,c)]=t,d(e,l,n(this,l)),n(this,l)>0?d(e,c,n(this,c)+1===n(this,l)?0:n(this,c)+1):d(e,c,n(this,c)+1),e}get pointer(){return n(this,c)}get isFull(){return n(this,l)===0?!1:this.length===n(this,l)}},st=A;l=new WeakMap;c=new WeakMap;var V=t=>new st(t),h,m=class extends rt{constructor(t,e={}){super();v(this,h,new Map),u(this,"groupBy"),u(this,"type"),this.type=t,this.groupBy=e.groupBy??_}get typeName(){return this.type.name}get lengthMax(){let t=0;for(const e of n(this,h).values())t=Math.max(t,this.type.count(e));return t}debugString(){const t=Array.from(n(this,h).keys());let e=`Keys: ${t.join(", ")}\r
`;return t.forEach(r=>{const a=n(this,h).get(r);if(a!==void 0){const s=this.type.toArray(a);s!==void 0&&(e+=` - ${r} (${this.type.count(a)}) = ${JSON.stringify(s)}\r
`)}else e+=` - ${r} (undefined)\r
`}),e}get isEmpty(){return n(this,h).size===0}clear(){n(this,h).clear(),super.fireEvent("clear",!0)}addKeyedValues(t,...e){const r=n(this,h).get(t);r===void 0?(n(this,h).set(t,this.type.add(void 0,e)),super.fireEvent("addedKey",{key:t}),super.fireEvent("addedValues",{values:e})):(n(this,h).set(t,this.type.add(r,e)),super.fireEvent("addedValues",{values:e}))}addValue(...t){t.forEach(e=>this.addKeyedValues(this.groupBy(e),e))}hasKeyValue(t,e){const r=n(this,h).get(t);return r===void 0?!1:this.type.has(r,e)}has(t){return n(this,h).has(t)}deleteKeyValue(t,e){const r=n(this,h).get(t);if(r===void 0)return!1;const a=this.type.count(r),s=this.type.without(r,e),i=s.length;return n(this,h).set(t,this.type.add(void 0,s)),a>i}delete(t){return n(this,h).get(t)===void 0?!1:(n(this,h).delete(t),this.fireEvent("deleteKey",{key:t}),!0)}findKeyForValue(t){return Array.from(n(this,h).keys()).find(a=>{const s=n(this,h).get(a);if(s===void 0)throw Error("Bug: map could not be accessed");return!!this.type.has(s,t)})}count(t){const e=n(this,h).get(t);return e===void 0?0:this.type.count(e)}get(t){const e=n(this,h).get(t);if(e!==void 0)return this.type.toArray(e)}getSource(t){return n(this,h).get(t)}keys(){return Array.from(n(this,h).keys())}keysAndCounts(){return this.keys().map(r=>[r,this.count(r)])}merge(t){t.keys().forEach(r=>{const a=t.get(r);a!==void 0&&this.addKeyedValues(r,...a)})}};h=new WeakMap;var nt=(t={})=>{const e=t.comparer===void 0?t.toString===void 0?(s,i)=>t.toString(s)===t.toString(i):x:t.comparer,r={get name(){return"array"},add:(s,i)=>s===void 0?[...i]:[...s,...i],count:s=>s.length,find:(s,i)=>s.find(i),filter:(s,i)=>s.filter(i),toArray:s=>s,has:(s,i)=>s.find(o=>e(o,i))!==void 0,without:(s,i)=>s.filter(o=>!e(o,i))};return new m(r,t)},ot=t=>{const e=t?.hash??_,r=(i,o)=>e(i)===e(o),a={get name(){return"set"},add:(i,o)=>H(i,e,...o),count:i=>i.size,find:(i,o)=>Y(i,o),filter:(i,o)=>X(i,o),toArray:i=>F(i),has:(i,o)=>Z(i,o,r),without:(i,o)=>tt(F(i),o,r)};return new m(a,t)},ht=t=>{const e=x,r={get name(){return"circular"},add:(a,s)=>(a===void 0&&(a=V(t.capacity)),s.forEach(i=>a=a?.add(i)),a),count:a=>a.length,find:(a,s)=>a.find(s),filter:(a,s)=>a.filter(s),toArray:a=>a,has:(a,s)=>a.find(i=>e(i,s))!==void 0,without:(a,s)=>a.filter(i=>!e(i,s))};return new m(r,t)},L={};y(L,{stack:()=>Q,stackMutable:()=>B});var ut=(t,e,r)=>{const a=e.length+r.length,s=t.overflowPolicy??"additions",i=t.capacity??a,o=a-i;switch(t.debug&&console.log(`Stack.push: stackLen: ${e.length} potentialLen: ${a} toRemove: ${o} policy: ${s}`),s){case"additions":return t.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${e.length} slice: ${a-i} toAddLen: ${r.length}`),e.length===t.capacity?e:[...e,...r.slice(0,r.length-o)];case"newer":return o>=e.length?r.slice(Math.max(0,r.length-i),Math.min(r.length,i)+1):(t.debug&&console.log(` from orig: ${e.slice(0,o-1)}`),[...e.slice(0,o-1),...r.slice(0,Math.min(r.length,i-o+1))]);case"older":return[...e,...r].slice(o);default:throw new Error(`Unknown overflow policy ${s}`)}},R=(t,e,...r)=>{const a=e.length+r.length;return t.capacity&&a>t.capacity?ut(t,e,r):[...e,...r]},C=(t,e)=>{if(e.length===0)throw new Error("Stack is empty");return e.slice(0,e.length-1)},w=(t,e)=>e[e.length-1],K=(t,e)=>e.length===0,O=(t,e)=>t.capacity?e.length>=t.capacity:!1,E=class{constructor(t,e){u(this,"opts"),u(this,"data"),this.opts=t,this.data=e}push(...t){return new E(this.opts,R(this.opts,this.data,...t))}pop(){return new E(this.opts,C(this.opts,this.data))}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}get isEmpty(){return K(this.opts,this.data)}get isFull(){return O(this.opts,this.data)}get peek(){return w(this.opts,this.data)}get length(){return this.data.length}},ct=class{constructor(t,e){u(this,"opts"),u(this,"data"),this.opts=t,this.data=e}push(...t){return this.data=R(this.opts,this.data,...t),this.data.length}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}pop(){const t=w(this.opts,this.data);return C(this.opts,this.data),t}get isEmpty(){return K(this.opts,this.data)}get isFull(){return O(this.opts,this.data)}get peek(){return w(this.opts,this.data)}get length(){return this.data.length}},Q=(t={},...e)=>new E({...t},[...e]),B=(t,...e)=>new ct({...t},[...e]),N={};y(N,{queue:()=>D,queueMutable:()=>q});var g=(t,e)=>{t.debug&&console.log(`queue:${e}`)},lt=(t,e,r)=>{const a=e.length+r.length,s=t.capacity??a,i=a-s,o=t.discardPolicy??"additions";switch(g(t,`queueLen: ${e.length} potentialLen: ${a} toRemove: ${i} policy: ${o}`),o){case"additions":return g(t,`trimQueue:DiscardAdditions: queueLen: ${e.length} slice: ${a-s} toAddLen: ${r.length}`),e.length===t.capacity?e:[...e,...r.slice(0,i-1)];case"newer":if(i>=e.length)return r.slice(Math.max(0,r.length-s),Math.min(r.length,s)+1);{const S=r.slice(0,Math.min(r.length,s-i+1)),$=e.slice(0,e.length-i);g(t,`trimQueue: toRemove: ${i} keeping: ${JSON.stringify($)} from orig: ${JSON.stringify(e)} toAddFinal: ${JSON.stringify(S)}`);const k=[...$,...S];return g(t,`final: ${JSON.stringify(k)}`),k}case"older":return[...e,...r].slice(i);default:throw new Error(`Unknown overflow policy ${o}`)}},j=(t,e,...r)=>{if(t===void 0)throw new Error("opts parameter undefined");const a=e.length+r.length,s=t.capacity&&a>t.capacity,i=s?lt(t,e,r):[...e,...r];if(t.capacity&&i.length!==t.capacity&&s)throw new Error(`Bug! Expected return to be at capacity. Return len: ${i.length} capacity: ${t.capacity} opts: ${JSON.stringify(t)}`);if(!t.capacity&&i.length!==a)throw new Error(`Bug! Return length not expected. Return len: ${i.length} expected: ${a} opts: ${JSON.stringify(t)}`);return i},z=(t,e)=>{if(e.length===0)throw new Error("Queue is empty");return e.slice(1)},M=(t,e)=>e[0],I=(t,e)=>e.length===0,J=(t,e)=>t.capacity?e.length>=t.capacity:!1,b=class{constructor(t,e){if(u(this,"opts"),u(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}forEach(t){for(let e=this.data.length-1;e>=0;e--)t(this.data[e])}forEachFromFront(t){this.data.forEach(e=>t(e))}enqueue(...t){return new b(this.opts,j(this.opts,this.data,...t))}dequeue(){return new b(this.opts,z(this.opts,this.data))}get isEmpty(){return I(this.opts,this.data)}get isFull(){return J(this.opts,this.data)}get length(){return this.data.length}get peek(){return M(this.opts,this.data)}},pt=class{constructor(t,e){if(u(this,"opts"),u(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return this.data=j(this.opts,this.data,...t),this.data.length}dequeue(){const t=M(this.opts,this.data);return this.data=z(this.opts,this.data),t}get isEmpty(){return I(this.opts,this.data)}get isFull(){return J(this.opts,this.data)}get length(){return this.data.length}get peek(){return M(this.opts,this.data)}},D=(t={},...e)=>(t={...t},new b(t,[...e])),q=(t={},...e)=>new pt({...t},[...e]),dt=(t,e)=>{const r=new Map(t.entries());return e.forEach(a=>{if(a[0]===void 0)throw new Error("key cannot be undefined");if(a[1]===void 0)throw new Error("value cannot be undefined");r.set(a[0],a[1])}),r},ft=(t,e)=>{const r=new Map(t.entries());return e.forEach(a=>{if(a.key===void 0)throw new Error("key cannot be undefined");if(a.value===void 0)throw new Error("value cannot be undefined");r.set(a.key,a.value)}),r},gt=(t,e)=>t.has(e),f=(t,...e)=>{if(t===void 0)throw new Error("map parameter is undefined");if(e===void 0)throw new Error("data parameter i.s undefined");if(e.length===0)return t;const r=e[0];return typeof r.key!="undefined"&&typeof r.value!="undefined"?ft(t,e):dt(t,e)},yt=(t,e,r)=>{const a=new Map(t.entries());return a.set(e,r),a},P=(t,e)=>{const r=new Map(t.entries());return r.delete(e),r},p=t=>{if(t===void 0)return p([]);if(Array.isArray(t))return p(f(new Map,...t));const e=t;return{add:(...r)=>{const a=f(e,...r);return p(a)},get:r=>e.get(r),delete:r=>p(P(e,r)),clear:()=>p(),has:r=>e.has(r),entries:()=>e.entries(),isEmpty:()=>e.size===0}},vt=(...t)=>{let e=f(new Map,...t);return{add:(...r)=>{e=f(e,...r)},delete:r=>{e=P(e,r)},clear:()=>{e=f(new Map)},set:(r,a)=>{e=yt(e,r,a)},get:r=>e.get(r),entries:()=>e.entries(),isEmpty:()=>e.size===0,has:r=>gt(e,r)}};export{N as Q,L as S,nt as a,ht as m,Q as s};
