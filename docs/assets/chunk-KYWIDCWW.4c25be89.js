import{S as A,c as d,e as o,f as i,k as M}from"./chunk-4WJCK6OW.7396b794.js";var l,y,f,c,v,g=class extends A{constructor(e,s,a={debug:!1}){super();d(this,l,void 0),d(this,y,void 0),d(this,f,void 0),d(this,c,void 0),d(this,v,void 0);const[t,u]=g.validate(e,s);if(!t)throw new Error(u);o(this,v,e),o(this,f,s),o(this,y,a.debug??!1),o(this,l,e),o(this,c,!1)}get states(){return Object.keys(i(this,f))}static validate(e,s){const a=Object.keys(s),t=new Set,u=new Set;for(let h=0;h<a.length;h++){const r=a[h];if(t.has(r))return[!1,`Key ${r} is already used`];if(t.add(r),typeof a[h]!="string")return[!1,`Key[${h}] is not a string`];const n=s[r];if(n===void 0)return[!1,`Key ${r} value is undefined`];if(typeof n=="string"){if(u.add(n),n===r)return[!1,`Loop present for ${r}`]}else if(Array.isArray(n)){if(!M(n))return[!1,`Key ${r} value is not an array of strings`];if(n.forEach(p=>u.add(p)),n.find(p=>p===r))return[!1,`Loop present for ${r}`]}else if(n!==null)return[!1,`Key ${r} has a value that is neither null, string or array`]}const $=Array.from(u).find(h=>!t.has(h));return $?[!1,`Potential state '${$}' does not exist as a top-level state`]:s[e]===void 0?[!1,`Initial state ${e} not present`]:[!0,""]}next(){const e=i(this,f)[i(this,l)];if(e===null)return null;if(Array.isArray(e))if(typeof e[0]=="string")this.state=e[0];else throw new Error("Error in machine description. Potential state array does not contain strings");else if(typeof e=="string")this.state=e;else throw new Error("Error in machine description. Potential state is neither array nor string");return this.state}get isDone(){return i(this,c)}reset(){o(this,c,!1),o(this,l,i(this,v))}static isValid(e,s,a){if(a[s]===void 0)return[!1,`Machine cannot change to non-existent state ${s}`];const t=a[e];if(Array.isArray(t)){if(!t.includes(s))return[!1,`Machine cannot ${e} -> ${s}. Allowed transitions: ${t.join(", ")}`]}else if(s!==t&&t!=="*")return[!1,`Machine cannot ${e} -> ${s}. Allowed transition: ${t}`];return[!0,"ok"]}isValid(e){return g.isValid(this.state,e,i(this,f))}set state(e){const s=i(this,l),[a,t]=g.isValid(s,e,i(this,f));if(!a)throw new Error(t);i(this,y)&&console.log(`StateMachine: ${s} -> ${e}`),o(this,l,e),i(this,f)[e]===null&&o(this,c,!0),setTimeout(()=>{this.fireEvent("change",{newState:e,priorState:s}),this.isDone&&this.fireEvent("stop",{state:e})},1)}get state(){return i(this,l)}},E=g;l=new WeakMap;y=new WeakMap;f=new WeakMap;c=new WeakMap;v=new WeakMap;export{E as S};
