import{S as A,d as c,f as o,g as n,j as M}from"./chunk-L7NPGFXB.5d5b7d6e.js";var E=(...e)=>{const t={};for(let s=0;s<e.length;s++)s===e.length-1?t[e[s]]=null:t[e[s]]=e[s+1];return t},l,y,f,d,g,v=class extends A{constructor(e,t,s={debug:!1}){super();c(this,l,void 0),c(this,y,void 0),c(this,f,void 0),c(this,d,void 0),c(this,g,void 0);const[r,u]=v.validate(e,t);if(!r)throw new Error(u);o(this,g,e),o(this,f,t),o(this,y,s.debug??!1),o(this,l,e),o(this,d,!1)}get states(){return Object.keys(n(this,f))}static validate(e,t){const s=Object.keys(t),r=new Set,u=new Set;for(let h=0;h<s.length;h++){const i=s[h];if(r.has(i))return[!1,`Key ${i} is already used`];if(r.add(i),typeof s[h]!="string")return[!1,`Key[${h}] is not a string`];const a=t[i];if(a===void 0)return[!1,`Key ${i} value is undefined`];if(typeof a=="string"){if(u.add(a),a===i)return[!1,`Loop present for ${i}`]}else if(Array.isArray(a)){if(!M(a))return[!1,`Key ${i} value is not an array of strings`];if(a.forEach(p=>u.add(p)),a.find(p=>p===i))return[!1,`Loop present for ${i}`]}else if(a!==null)return[!1,`Key ${i} has a value that is neither null, string or array`]}const $=Array.from(u).find(h=>!r.has(h));return $?[!1,`Potential state '${$}' does not exist as a top-level state`]:t[e]===void 0?[!1,`Initial state ${e} not present`]:[!0,""]}next(){const e=n(this,f)[n(this,l)];if(e===null)return null;if(Array.isArray(e))if(typeof e[0]=="string")this.state=e[0];else throw new Error("Error in machine description. Potential state array does not contain strings");else if(typeof e=="string")this.state=e;else throw new Error("Error in machine description. Potential state is neither array nor string");return this.state}get isDone(){return n(this,d)}reset(){o(this,d,!1),o(this,l,n(this,g))}static isValid(e,t,s){if(s[t]===void 0)return[!1,`Machine cannot change to non-existent state ${t}`];const r=s[e];if(Array.isArray(r)){if(!r.includes(t))return[!1,`Machine cannot ${e} -> ${t}. Allowed transitions: ${r.join(", ")}`]}else if(t!==r&&r!=="*")return[!1,`Machine cannot ${e} -> ${t}. Allowed transition: ${r}`];return[!0,"ok"]}isValid(e){return v.isValid(this.state,e,n(this,f))}set state(e){const t=n(this,l),[s,r]=v.isValid(t,e,n(this,f));if(!s)throw new Error(r);n(this,y)&&console.log(`StateMachine: ${t} -> ${e}`),o(this,l,e),n(this,f)[e]===null&&o(this,d,!0),setTimeout(()=>{this.fireEvent("change",{newState:e,priorState:t}),this.isDone&&this.fireEvent("stop",{state:e})},1)}get state(){return n(this,l)}},V=v;l=new WeakMap;y=new WeakMap;f=new WeakMap;d=new WeakMap;g=new WeakMap;export{V as S,E as f};
