import{S as m,b as A}from"./chunk-AWXCQ245.1dcbd11a.js";import{_ as E,b as d,d as o,c as a}from"./chunk-FQLUQVDZ.7e80d7b0.js";var k={};E(k,{StateMachine:()=>$,create:()=>V,descriptionFromList:()=>M,fromList:()=>w});var M=(...e)=>{const t={};for(let s=0;s<e.length;s++)s===e.length-1?t[e[s]]=null:t[e[s]]=e[s+1];return t},w=(...e)=>new $(e[0],M(...e)),V=(e,t,s={debug:!1})=>new $(e,t,s),l,y,f,u,p,v=class extends m{constructor(e,t,s={debug:!1}){super();d(this,l,void 0),d(this,y,void 0),d(this,f,void 0),d(this,u,void 0),d(this,p,void 0);const[r,c]=v.validate(e,t);if(!r)throw new Error(c);o(this,p,e),o(this,f,t),o(this,y,s.debug??!1),o(this,l,e),o(this,u,!1)}get states(){return Object.keys(a(this,f))}static validate(e,t){const s=Object.keys(t),r=new Set,c=new Set;for(let h=0;h<s.length;h++){const i=s[h];if(r.has(i))return[!1,`Key ${i} is already used`];if(r.add(i),typeof s[h]!="string")return[!1,`Key[${h}] is not a string`];const n=t[i];if(n===void 0)return[!1,`Key ${i} value is undefined`];if(typeof n=="string"){if(c.add(n),n===i)return[!1,`Loop present for ${i}`]}else if(Array.isArray(n)){if(!A(n))return[!1,`Key ${i} value is not an array of strings`];if(n.forEach(g=>c.add(g)),n.find(g=>g===i))return[!1,`Loop present for ${i}`]}else if(n!==null)return[!1,`Key ${i} has a value that is neither null, string or array`]}const _=Array.from(c).find(h=>!r.has(h));return _?[!1,`Potential state '${_}' does not exist as a top-level state`]:t[e]===void 0?[!1,`Initial state ${e} not present`]:[!0,""]}next(){const e=a(this,f)[a(this,l)];if(e===null)return null;if(Array.isArray(e))if(typeof e[0]=="string")this.state=e[0];else throw new Error("Error in machine description. Potential state array does not contain strings");else if(typeof e=="string")this.state=e;else throw new Error("Error in machine description. Potential state is neither array nor string");return this.state}get isDone(){return a(this,u)}reset(){o(this,u,!1),o(this,l,a(this,p))}static isValid(e,t,s){if(s[t]===void 0)return[!1,`Machine cannot change to non-existent state ${t}`];const r=s[e];if(Array.isArray(r)){if(!r.includes(t))return[!1,`Machine cannot change '${e} -> ${t}'. Allowed transitions: ${r.join(", ")}`]}else if(t!==r&&r!=="*")return[!1,`Machine cannot '${e} -> ${t}'. Allowed transition: ${r}`];return[!0,"ok"]}isValid(e){return v.isValid(this.state,e,a(this,f))}set state(e){const t=a(this,l),[s,r]=v.isValid(t,e,a(this,f));if(!s)throw new Error(r);a(this,y)&&console.log(`StateMachine: ${t} -> ${e}`),o(this,l,e),a(this,f)[e]===null&&o(this,u,!0),setTimeout(()=>{this.fireEvent("change",{newState:e,priorState:t}),this.isDone&&this.fireEvent("stop",{state:e})},1)}get state(){return a(this,l)}},$=v;l=new WeakMap;y=new WeakMap;f=new WeakMap;u=new WeakMap;p=new WeakMap;export{$ as S,k as a};
