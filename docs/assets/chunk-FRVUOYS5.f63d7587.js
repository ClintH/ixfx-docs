import{A as O,M as D,S as U,s as W,d as $,t as S,e as T,h as G,j as H,k,l as P,w as Z}from"./chunk-UWLZSNHO.b417c615.js";import{s as X,S as Y}from"./chunk-6JTGCZJL.667a6ecc.js";import{_ as g,a as y,b as u,d as n,c as d}from"./chunk-25RM45LF.24c9c7e0.js";var tt={};g(tt,{Arrays:()=>O,Maps:()=>D,Queues:()=>j,Sets:()=>U,Stacks:()=>L,circularArray:()=>_,map:()=>p,mapArray:()=>rt,mapCircular:()=>st,mapMutable:()=>dt,mapSet:()=>at,queue:()=>q,queueMutable:()=>Q,setMutable:()=>W,simpleMapArrayMutable:()=>X,stack:()=>K,stackMutable:()=>N});var l,c,x=class extends Array{constructor(t=0){super();if(y(this,l,void 0),y(this,c,void 0),Number.isNaN(t))throw Error("capacity is NaN");d(this,l,t),d(this,c,0)}add(t){const e=x.from(this);return e[n(this,c)]=t,d(e,l,n(this,l)),n(this,l)>0?d(e,c,n(this,c)+1===n(this,l)?0:n(this,c)+1):d(e,c,n(this,c)+1),e}get pointer(){return n(this,c)}get isFull(){return n(this,l)===0?!1:this.length===n(this,l)}},et=x;l=new WeakMap;c=new WeakMap;var _=t=>new et(t),h,v=class extends Y{constructor(t,e={}){super();y(this,h,new Map),u(this,"groupBy"),u(this,"type"),this.type=t,this.groupBy=e.groupBy??S}get lengthMax(){let t=0;for(const e of n(this,h).values())t=Math.max(t,this.type.count(e));return t}debugString(){const t=Array.from(n(this,h).keys());let e=`Keys: ${t.join(", ")}\r
`;return t.forEach(r=>{const a=n(this,h).get(r);if(a!==void 0){const i=this.type.toArray(a);i!==void 0&&(e+=` - ${r} (${this.type.count(a)}) = ${JSON.stringify(i)}\r
`)}else e+=` - ${r} (undefined)\r
`}),e}get isEmpty(){return n(this,h).size===0}clear(){n(this,h).clear(),super.fireEvent("clear",!0)}addKeyedValues(t,...e){const r=n(this,h).get(t);r===void 0?(n(this,h).set(t,this.type.add(void 0,e)),super.fireEvent("addedKey",{key:t}),super.fireEvent("addedValues",{values:e})):(n(this,h).set(t,this.type.add(r,e)),super.fireEvent("addedValues",{values:e}))}addValue(...t){t.forEach(e=>this.addKeyedValues(this.groupBy(e),e))}hasKeyValue(t,e){const r=n(this,h).get(t);return r===void 0?!1:this.type.has(r,e)}has(t){return n(this,h).has(t)}deleteKeyValue(t,e){const r=n(this,h).get(t);if(r===void 0)return!1;const a=this.type.count(r),i=this.type.without(r,e),s=i.length;return n(this,h).set(t,this.type.add(void 0,i)),a>s}delete(t){return n(this,h).get(t)===void 0?!1:(n(this,h).delete(t),this.fireEvent("deleteKey",{key:t}),!0)}findKeyForValue(t){return Array.from(n(this,h).keys()).find(a=>{const i=n(this,h).get(a);if(i===void 0)throw Error("Bug: map could not be accessed");return!!this.type.has(i,t)})}count(t){const e=n(this,h).get(t);return e===void 0?0:this.type.count(e)}get(t){const e=n(this,h).get(t);if(e!==void 0)return this.type.toArray(e)}getSource(t){return n(this,h).get(t)}keys(){return Array.from(n(this,h).keys())}keysAndCounts(){return this.keys().map(r=>[r,this.count(r)])}merge(t){t.keys().forEach(r=>{const a=t.get(r);a!==void 0&&this.addKeyedValues(r,...a)})}};h=new WeakMap;var rt=(t={})=>{const e=t.comparer===void 0?t.toString===void 0?(i,s)=>t.toString(i)===t.toString(s):$:t.comparer,r={add:(i,s)=>i===void 0?[...s]:[...i,...s],count:i=>i.length,find:(i,s)=>i.find(s),filter:(i,s)=>i.filter(s),toArray:i=>i,has:(i,s)=>i.find(o=>e(o,s))!==void 0,without:(i,s)=>i.filter(o=>!e(o,s))};return new v(r,t)},at=t=>{const e=t?.hash??S,r=(s,o)=>e(s)===e(o),a={add:(s,o)=>T(s,e,...o),count:s=>s.size,find:(s,o)=>G(s,o),filter:(s,o)=>H(s,o),toArray:s=>k(s),has:(s,o)=>P(s,o,r),without:(s,o)=>Z(k(s),o,r)};return new v(a,t)},st=t=>{const e=$,r={add:(a,i)=>(a===void 0&&(a=_(t.capacity)),i.forEach(s=>a=a?.add(s)),a),count:a=>a.length,find:(a,i)=>a.find(i),filter:(a,i)=>a.filter(i),toArray:a=>a,has:(a,i)=>a.find(s=>e(s,i))!==void 0,without:(a,i)=>a.filter(s=>!e(s,i))};return new v(r,t)},L={};g(L,{stack:()=>K,stackMutable:()=>N});var it=(t,e,r)=>{const a=e.length+r.length,i=t.overflowPolicy??"additions",s=t.capacity??a,o=a-s;switch(t.debug&&console.log(`Stack.push: stackLen: ${e.length} potentialLen: ${a} toRemove: ${o} policy: ${i}`),i){case"additions":return t.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${e.length} slice: ${a-s} toAddLen: ${r.length}`),e.length===t.capacity?e:[...e,...r.slice(0,r.length-o)];case"newer":return o>=e.length?r.slice(Math.max(0,r.length-s),Math.min(r.length,s)+1):(t.debug&&console.log(` from orig: ${e.slice(0,o-1)}`),[...e.slice(0,o-1),...r.slice(0,Math.min(r.length,s-o+1))]);case"older":return[...e,...r].slice(o);default:throw new Error(`Unknown overflow policy ${i}`)}},F=(t,e,...r)=>{const a=e.length+r.length;return t.capacity&&a>t.capacity?it(t,e,r):[...e,...r]},R=(t,e)=>{if(e.length===0)throw new Error("Stack is empty");return e.slice(0,e.length-1)},m=(t,e)=>e[e.length-1],A=(t,e)=>e.length===0,V=(t,e)=>t.capacity?e.length>=t.capacity:!1,w=class{constructor(t,e){u(this,"opts"),u(this,"data"),this.opts=t,this.data=e}push(...t){return new w(this.opts,F(this.opts,this.data,...t))}pop(){return new w(this.opts,R(this.opts,this.data))}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}get isEmpty(){return A(this.opts,this.data)}get isFull(){return V(this.opts,this.data)}get peek(){return m(this.opts,this.data)}get length(){return this.data.length}},nt=class{constructor(t,e){u(this,"opts"),u(this,"data"),this.opts=t,this.data=e}push(...t){return this.data=F(this.opts,this.data,...t),this.data.length}forEach(t){this.data.forEach(t)}forEachFromTop(t){[...this.data].reverse().forEach(t)}pop(){const t=m(this.opts,this.data);return R(this.opts,this.data),t}get isEmpty(){return A(this.opts,this.data)}get isFull(){return V(this.opts,this.data)}get peek(){return m(this.opts,this.data)}get length(){return this.data.length}},K=(t={},...e)=>new w({...t},[...e]),N=(t,...e)=>new nt({...t},[...e]),j={};g(j,{queue:()=>q,queueMutable:()=>Q});var E=(t,e)=>{t.debug&&console.log(`queue:${e}`)},ot=(t,e,r)=>{const a=e.length+r.length,i=t.capacity??a,s=a-i,o=t.discardPolicy??"additions";switch(E(t,`queueLen: ${e.length} potentialLen: ${a} toRemove: ${s} policy: ${o}`),o){case"additions":return E(t,`enqueue:DiscardAdditions: queueLen: ${e.length} slice: ${a-i} toAddLen: ${r.length}`),e.length===t.capacity?e:[...e,...r.slice(0,s-1)];case"newer":return s>=e.length?r.slice(Math.max(0,r.length-i),Math.min(r.length,i)+1):(E(t,` from orig: ${e.slice(0,s-1)}`),[...e.slice(0,s-1),...r.slice(0,Math.min(r.length,i-s+1))]);case"older":return[...e,...r].slice(s);default:throw new Error(`Unknown overflow policy ${o}`)}},B=(t,e,...r)=>{if(t===void 0)throw new Error("opts parameter undefined");const a=e.length+r.length,i=t.capacity&&a>t.capacity,s=i?ot(t,e,r):[...e,...r];if(t.capacity&&s.length!==t.capacity&&i)throw new Error(`Bug! Expected return to be at capacity. Return len: ${s.length} capacity: ${t.capacity} opts: ${JSON.stringify(t)}`);if(!t.capacity&&s.length!==a)throw new Error(`Bug! Return length not expected. Return len: ${s.length} expected: ${a} opts: ${JSON.stringify(t)}`);return s},C=(t,e)=>{if(e.length===0)throw new Error("Queue is empty");return e.slice(1)},M=(t,e)=>e[0],z=(t,e)=>e.length===0,I=(t,e)=>t.capacity?e.length>=t.capacity:!1,b=class{constructor(t,e){if(u(this,"opts"),u(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}forEach(t){for(let e=this.data.length-1;e>=0;e--)t(this.data[e])}forEachFromFront(t){this.data.forEach(e=>t(e))}enqueue(...t){return new b(this.opts,B(this.opts,this.data,...t))}dequeue(){return new b(this.opts,C(this.opts,this.data))}get isEmpty(){return z(this.opts,this.data)}get isFull(){return I(this.opts,this.data)}get length(){return this.data.length}get peek(){return M(this.opts,this.data)}},ht=class{constructor(t,e){if(u(this,"opts"),u(this,"data"),t===void 0)throw new Error("opts parameter undefined");this.opts=t,this.data=e}enqueue(...t){return this.data=B(this.opts,this.data,...t),this.data.length}dequeue(){const t=M(this.opts,this.data);return this.data=C(this.opts,this.data),t}get isEmpty(){return z(this.opts,this.data)}get isFull(){return I(this.opts,this.data)}get length(){return this.data.length}get peek(){return M(this.opts,this.data)}},q=(t={},...e)=>(t={...t},new b(t,[...e])),Q=(t={},...e)=>new ht({...t},[...e]),ut=(t,e)=>{const r=new Map(t.entries());return e.forEach(a=>{if(a[0]===void 0)throw new Error("key cannot be undefined");if(a[1]===void 0)throw new Error("value cannot be undefined");r.set(a[0],a[1])}),r},ct=(t,e)=>{const r=new Map(t.entries());return e.forEach(a=>{if(a.key===void 0)throw new Error("key cannot be undefined");if(a.value===void 0)throw new Error("value cannot be undefined");r.set(a.key,a.value)}),r},lt=(t,e)=>t.has(e),f=(t,...e)=>{if(t===void 0)throw new Error("map parameter is undefined");if(e===void 0)throw new Error("data parameter i.s undefined");if(e.length===0)return t;const r=e[0];return typeof r.key!="undefined"&&typeof r.value!="undefined"?ct(t,e):ut(t,e)},pt=(t,e,r)=>{const a=new Map(t.entries());return a.set(e,r),a},J=(t,e)=>{const r=new Map(t.entries());return r.delete(e),r},p=t=>{if(t===void 0)return p([]);if(Array.isArray(t))return p(f(new Map,...t));const e=t;return{add:(...r)=>{const a=f(e,...r);return p(a)},get:r=>e.get(r),delete:r=>p(J(e,r)),clear:()=>p(),has:r=>e.has(r),entries:()=>e.entries(),isEmpty:()=>e.size===0}},dt=(...t)=>{let e=f(new Map,...t);return{add:(...r)=>{e=f(e,...r)},delete:r=>{e=J(e,r)},clear:()=>{e=f(new Map)},set:(r,a)=>{e=pt(e,r,a)},get:r=>e.get(r),entries:()=>e.entries(),isEmpty:()=>e.size===0,has:r=>lt(e,r)}};export{st as m,K as s};
